% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
MazeRoomMaintenance is UtilityFunctions

constants:

   include blakston.khd

resources:

   maze_maint_interior1 = mazeinterior1.roo
   maze_maint_interior2 = mazeinterior2.roo
   maze_maint_interior3 = mazeinterior3.roo
   maze_maint_interior4 = mazeinterior4.roo
   maze_maint_interior5 = mazeinterior5.roo
   maze_maint_interior6 = mazeinterior6.roo
   maze_maint_interior7 = mazeinterior7.roo
   maze_maint_interior8 = mazeinterior8.roo
   maze_maint_interior9 = mazeinterior9.roo
   maze_maint_interior10 = mazeinterior10.roo
   maze_maint_interior11 = mazeinterior11.roo
   maze_maint_interior12 = mazeinterior12.roo
   maze_maint_interior13 = mazeinterior13.roo
   maze_maint_interior14 = mazeinterior14.roo
   maze_maint_interior15 = mazeinterior15.roo
   maze_maint_interior16 = mazeinterior16.roo
   maze_maint_interior17 = mazeinterior17.roo
   maze_maint_interior18 = mazeinterior18.roo
   maze_maint_interior19 = mazeinterior19.roo
   maze_maint_interior20 = mazeinterior20.roo

classvars:

properties:

   poFirstRoom = $
   plMazeRooms = $
   poTreasureRoom = $
   poShrineRoom = $
   poArmorRoom = $
   poBossRoom = $
   
   plMazeClasses = $
   plMazeRooFiles = $

   % We only recreate the maze if players have seen it.
   % Otherwise, no need to change the configuration all the time.
   piMazeHasBeenEnteredByPlayers = FALSE

messages:

   Constructor()
   {
      Send(self,@Recreate);

      return;
   }

   Recreate()
   {
      Send(self,@RecreateMap);
      return;
   }
   
   ClearMap()
   {
      local i;

      if poFirstRoom <> $
      {
         Send(poFirstRoom,@HustleUsersOutOfRoom);
         Send(poFirstRoom,@Delete);
         poFirstRoom = $;
      }
      if poBossRoom <> $
      {
         Send(poBossRoom,@HustleUsersOutOfRoom);
         Send(poBossRoom,@Delete);
         poBossRoom = $;
      }
      if poTreasureRoom <> $
      {
         Send(poTreasureRoom,@HustleUsersOutOfRoom);
         Send(poTreasureRoom,@Delete);
         poTreasureRoom = $;
      }

      foreach i in plMazeRooms
      {
         % Deleted rooms bounce back to RoomDeleted and remove themselves from plMazeRooms
         Send(i,@Delete);
      }
      plMazeRooms = $;
      plMazeRooFiles = $;
      
      plMazeClasses = [&Maze5];
      plMazeRooFiles = [maze_maint_interior20];
%      plMazeRooFiles = [maze_maint_interior1,
%                        maze_maint_interior2,
%                        maze_maint_interior3,
%                        maze_maint_interior4,
%                        maze_maint_interior5,
%                        maze_maint_interior6,
%                        maze_maint_interior7,
%                        maze_maint_interior8,
%                        maze_maint_interior9,
%                        maze_maint_interior10,
%                        maze_maint_interior11,
%                        maze_maint_interior12,
%                        maze_maint_interior13,
%                        maze_maint_interior14,
%                        maze_maint_interior15];
      %plMazeClasses = [&Maze4a, &Maze4b, &Maze4c];
      
      piMazeHasBeenEnteredByPlayers = FALSE;
      return;
   }

   RecreateMap()
   {
      local iTreasureXCoord, iTreasureYCoord, iBossXCoord, iBossYCoord, i, iX, iY;

      % Make sure the maze is deleted
      Send(self,@ClearMap);
      
      % Create first room.
      poFirstRoom = Send(self,@GenerateSpecificRoom,#bFirstRoom=TRUE);
      
      % Create special rooms at random coordinates.
      iTreasureXCoord = Random(2,9);
      iTreasureYCoord = Random(2,9);
      
      iBossXCoord = Random(2,9);
      iBossYCoord = Random(2,9);
      
      % Same coordinates!!
      if iBossXCoord = iTreasureXCoord
         AND iBossYCoord = iTreasureYCoord
      {
         iBossXCoord++;
         if iBossXCoord > 9
         {
            iBossXCoord = 2;
         }
      }

      poTreasureRoom = Send(self,@GenerateSpecificRoom,#bTreasureRoom=TRUE,#x_coord=iTreasureXCoord,#y_coord=iTreasureYCoord);
      poBossRoom = Send(self,@GenerateSpecificRoom,#bBossRoom=TRUE,#x_coord=iBossXCoord,#y_coord=iBossYCoord);
      
      % The rest of the rooms we'll only fill in as players enter the maze.
      
      return;
   }
   
   PingMaze(x_coord=-1, y_coord=-1)
   {
      local i, lCheckTheseCoords;

      lCheckTheseCoords = $;
      if x_coord = 5
         AND y_coord = 0
      {
         % This is the first room. Ping only x = 5, y = 1
         lCheckTheseCoords = [[5,1]];
      }
      else
      {
         lCheckTheseCoords = Cons([x_coord+1, y_coord],lCheckTheseCoords);
         lCheckTheseCoords = Cons([x_coord-1, y_coord],lCheckTheseCoords);
         lCheckTheseCoords = Cons([x_coord, y_coord+1],lCheckTheseCoords);
         lCheckTheseCoords = Cons([x_coord, y_coord-1],lCheckTheseCoords);
      }
      
      foreach i in lCheckTheseCoords
      {
         if Send(self,@GetRoomAtCoords,#x_coord=Nth(i,1),#y_coord=Nth(i,2)) = $
         {
            % This room doesn't exist! Let's make it.
            Send(self,@GenerateSpecificRoom,#x_coord=Nth(i,1),#y_coord=Nth(i,2));
         }
      }

      return;
   }

   FindNextOpenCoordinate()
   {
      local iX, iY, i, bOpen;
      
      iX = 2;
      iY = 2;
      while iX < 10
      {
         while iY < 10
         {
            bOpen = TRUE;
            if poTreasureRoom <> $
            {
               if Send(poTreasureRoom,@GetXCoord) = iX
                  AND Send(poTreasureRoom,@GetYCoord) = iY
               {
                  bOpen = FALSE;
               }
            }
            if poBossRoom <> $
            {
               if Send(poBossRoom,@GetXCoord) = iX
                  AND Send(poBossRoom,@GetYCoord) = iY
               {
                  bOpen = FALSE;
               }
            }
            foreach i in plMazeRooms
            {
               if Send(i,@GetXCoord) = iX
                  AND Send(i,@GetYCoord) = iY
               {
                  bOpen = FALSE;
               }
            }
            if bOpen = TRUE
            {
               return [iX, iY];
            }
            iY++;
         }
         iX++;
      }
      return $;
   }

   GetFirstRoom()
   {
      if poFirstRoom = $
      {
         return Send(self,@CreateFirstRoom);
      }
      else
      {
         return poFirstRoom;
      }
      return $;
   }

   CreateFirstRoom()
   {
      if poFirstRoom = $
      {
         Send(SYS,@CreateOneRoomIfNew,#num=RID_MAZE_ENTRANCE,#class=&MinotaurMazeRoom);
         poFirstRoom = Send(SYS,@FindRoomByNum,#num=RID_MAZE_ENTRANCE);
         Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=RID_MAZE_ENTRANCE);
         return poFirstRoom;
      }

      return $;
   }

   GetBossRoom()
   {
      if poBossRoom = $
      {
         return Send(self,@CreateBossRoom);
      }
      else
      {
         return poBossRoom;
      }
      return $;
   }

   CreateBossRoom()
   {
      if poBossRoom = $
      {
         Send(SYS,@CreateOneRoomIfNew,#num=RID_MAZE_BOSS_ROOM,#class=&MazeBossRoom);
         poBossRoom = Send(SYS,@FindRoomByNum,#num=RID_MAZE_BOSS_ROOM);
         Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=RID_MAZE_BOSS_ROOM);
         return poBossRoom;
      }

      return $;
   }

   RoomDeleted(what=$)
   {
      if what <> $
      {
         if what = poFirstRoom
         {
            poFirstRoom = $;
         }
         if what = poBossRoom
         {
            poBossRoom = $;
         }
         if what = poTreasureRoom
         {
            poTreasureRoom = $;
         }
         
         if FindListElem(plMazeRooms,what)
         {
            plMazeRooms = DelListElem(plMazeRooms,what);
         }
      }
      return;
   }
   
   GetRoomAtCoords(x_coord=-1,y_coord=-1)
   {
      local i;
      
      if Send(poFirstRoom,@GetXCoord) = x_coord
         AND Send(poFirstRoom,@GetYCoord) = y_coord
      {
         return poFirstRoom;
      }
      
      if Send(poTreasureRoom,@GetXCoord) = x_coord
         AND Send(poTreasureRoom,@GetYCoord) = y_coord
      {
         return poTreasureRoom;
      }
      
      if Send(poBossRoom,@GetXCoord) = x_coord
         AND Send(poBossRoom,@GetYCoord) = y_coord
      {
         return poBossRoom;
      }
      
      foreach i in plMazeRooms
      {
         if Send(i,@GetXCoord) = x_coord
            AND Send(i,@GetYCoord) = y_coord
         {
            return i;
         }      
      }

      return $;
   }

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %%%%%%%%%%%%%%%%%%% Maze Room Handling 
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   NewDay()
   {
      local i;
      
      foreach i in plMazeRooms
      {
         Send(i,@NewDay);
      }

      return;
   }

   NewGameHour()
   {
      local i;
      
      foreach i in plMazeRooms
      {
         Send(i,@NewGameHour);
      }

      return;
   }

   GenerateSpecificRoom(x_coord=-1, y_coord=-1, bFirstRoom=FALSE, bTreasureRoom=FALSE, bBossRoom=FALSE)
   {
      local iGeneratedNum, bInterior, oRoom;

      % We use this function to create rooms where we want them.

      if Send(self,@CheckForExistingRoom,#x_coord=x_coord,#y_coord=y_coord) <> $
      {
         return $;
      }

      if bFirstRoom
      {
         if poFirstRoom = $
         {
            Send(SYS,@CreateOneRoomIfNew,#num=RID_MAZE_ENTRANCE,#class=&MinotaurMazeRoom);
            poFirstRoom = Send(SYS,@FindRoomByNum,#num=RID_MAZE_ENTRANCE);
            Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=RID_MAZE_ENTRANCE);
            Send(poFirstRoom,@SetXCoord,#coord_value=5);
            Send(poFirstRoom,@SetYCoord,#coord_value=0);
            return poFirstRoom;
         }
      }
      
      if bTreasureRoom
      {
         if poTreasureRoom = $
         {
            Send(SYS,@CreateOneRoomIfNew,#num=RID_MAZE_TREASURE_ROOM_SPEAR,#class=&MazeTreasureRoomSpear);
            poTreasureRoom = Send(SYS,@FindRoomByNum,#num=RID_MAZE_TREASURE_ROOM_SPEAR);
            Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=RID_MAZE_TREASURE_ROOM_SPEAR);
            Send(poTreasureRoom,@SetXCoord,#coord_value=x_coord);
            Send(poTreasureRoom,@SetYCoord,#coord_value=y_coord);
            return poTreasureRoom;
         }
      }
      
      if bBossRoom
      {
         if poBossRoom = $
         {
            Send(SYS,@CreateOneRoomIfNew,#num=RID_MAZE_BOSS_ROOM,#class=&MazeBossRoom);
            poBossRoom = Send(SYS,@FindRoomByNum,#num=RID_MAZE_BOSS_ROOM);
            Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=RID_MAZE_BOSS_ROOM);
            Send(poBossRoom,@SetXCoord,#coord_value=x_coord);
            Send(poBossRoom,@SetYCoord,#coord_value=y_coord);
            return poBossRoom;
         }
      }
      
      % Ok, we're not making a specific room. Let's randomize!
      
      iGeneratedNum = Send(self,@GetNextAvailableRID);
      Send(SYS,@CreateOneRoomIfNew,#num=iGeneratedNum,#class=&MazeInteriorRoom,#base_room=Nth(plMazeRooFiles,Random(1,Length(plMazeRooFiles))));
      Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=iGeneratedNum);
      oRoom = Send(SYS,@FindRoomByNum,#num=iGeneratedNum);
      Send(oRoom,@SetXCoord,#coord_value=x_coord);
      Send(oRoom,@SetYCoord,#coord_value=y_coord);
      
      plMazeRooms = Cons(oRoom,plMazeRooms);

      return $;
   }
   
   GenerateNewRoom(from_room=$,from_direction=0)
   {
      local oRoom, iGeneratedNum, lMazeClasses, iTargetXCoord, iTargetYCoord, oExistingRoom, bInterior;
      
      %
      %
      % CREATE EDGE ROOMS HERE
      %
      
      iTargetXCoord = Send(from_room,@GetXCoord);
      switch(from_direction)
      {
         case MAZE_DIRECTION_NORTH:
            break;
         case MAZE_DIRECTION_SOUTH:
            break;
         case MAZE_DIRECTION_WEST:
            iTargetXCoord--;
            break;
         case MAZE_DIRECTION_EAST:
            iTargetXCoord++;
            break;
      }
      
      iTargetYCoord = Send(from_room,@GetYCoord);
      switch(from_direction)
      {
         case MAZE_DIRECTION_NORTH:
            iTargetYCoord++;
            break;
         case MAZE_DIRECTION_SOUTH:
           iTargetYCoord--;
            break;
         case MAZE_DIRECTION_WEST:
            break;
         case MAZE_DIRECTION_EAST:
            break;
      }

%      if iTargetYCoord < 1
%         OR iTargetYCoord > 10
%         OR iTargetXCoord < 1
%         OR iTargetXCoord > 10
%      {
%         Debug("Player somehow attempted to enter out of bounds maze room!");
%         return $;
%      }

      lMazeClasses = $;
      bInterior = TRUE;
      
      if iTargetXCoord = 1
      {
         lMazeClasses = [&MazeWestBorder];
      }
      
      if iTargetXCoord = 10
      {
         lMazeClasses = [&MazeEastBorder];
      }
      
      if iTargetYCoord = 1
      {
         lMazeClasses = [&MazeSouthBorder];
      }
      
      if iTargetYCoord = 10
      {
         lMazeClasses = [&MazeNorthBorder];
      }
      
      if Send(from_room,@GetXCoord) = 5
         AND Send(from_room,@GetYCoord) = 0
      {
         % We are entering the maze.
         lMazeClasses = [&Maze4a, &Maze4b, &Maze4c, &Maze5];
         iTargetXCoord = 4;
         iTargetYCoord = 1;
      }
      
      if iTargetXCoord = 1
         AND iTargetYCoord = 1
      {
         lMazeClasses = [&MazeSouthWestCorner];
      }
      
      if iTargetXCoord = 10
         AND iTargetYCoord = 1
      {
         lMazeClasses = [&MazeSouthEastCorner];
      }
      
      if iTargetXCoord = 1
         AND iTargetYCoord = 10
      {
         lMazeClasses = [&MazeNorthWestCorner];
      }
      
      if iTargetXCoord = 10
         AND iTargetYCoord = 10
      {
         lMazeClasses = [&MazeNorthEastCorner];
      }
      
      if lMazeClasses <> $
      {
         bInterior = FALSE;
      }

      oExistingRoom = Send(self,@CheckForExistingRoom,#x_coord=iTargetXCoord,#y_coord=iTargetYCoord);
      if oExistingRoom <> $
      {
         % Link the two rooms together
         Send(from_room,@SetConnectedRoom,#from_room=oExistingRoom,#from_direction=Send(self,@ReverseDirection,#direction=from_direction));
         Send(oExistingRoom,@SetConnectedRoom,#from_room=from_room,#from_direction=from_direction);

         return oExistingRoom;
      }
      else
      {
         iGeneratedNum = Send(self,@GetNextAvailableRID);
         
         if NOT bInterior
         {
            Send(SYS,@CreateOneRoomIfNew,#num=iGeneratedNum,
                                         #class=Nth(lMazeClasses,Random(1,Length(lMazeClasses))));
         }
         else
         {
            Send(SYS,@CreateOneRoomIfNew,#num=iGeneratedNum,#class=&MazeInteriorRoom,#base_room=Nth(plMazeRooFiles,Random(1,Length(plMazeRooFiles))));
         }
         Send(Send(SYS,@GetStatistics),@AddToRoomCount,#iNum=iGeneratedNum);
      
         oRoom = Send(SYS,@FindRoomByNum,#num=iGeneratedNum);
      
         % Link the two rooms together
         Send(from_room,@SetConnectedRoom,#from_room=oRoom,#from_direction=Send(self,@ReverseDirection,#direction=from_direction));
         Send(oRoom,@SetConnectedRoom,#from_room=from_room,#from_direction=from_direction);
         
         % Set your grid coordinates
         Send(oRoom,@SetXCoord,#coord_value=iTargetXCoord);
         Send(oRoom,@SetYCoord,#coord_value=iTargetYCoord);
      
         plMazeRooms = Cons(oRoom,plMazeRooms);

         return oRoom;
      }
         
      Debug("GenerateNewRoom failed spectacularly");
      
      return $;
   }

   CheckForExistingRoom(x_coord=0,y_coord=0)
   {
      local i;
      
      foreach i in plMazeRooms
      {
         if Send(i,@GetXCoord) = x_coord
            AND Send(i,@GetYCoord) = y_coord
         {
            return i;
         }
      }

      return $;
   }

   ReverseDirection(direction=0)
   {
      switch(direction)
      {
         case MAZE_DIRECTION_NORTH:
            return MAZE_DIRECTION_SOUTH;
         case MAZE_DIRECTION_EAST:
            return MAZE_DIRECTION_WEST;
         case MAZE_DIRECTION_SOUTH:
            return MAZE_DIRECTION_NORTH;
         case MAZE_DIRECTION_WEST:
            return MAZE_DIRECTION_EAST;
      }
      Debug("ReverseDirection returned 0!");
      return 0;
   }

   GetNextAvailableRID()
   {
      local iRID, i, bExists;

      iRID = RID_MAZE_ROOM_START;

      if plMazeRooms = $
      {
         return iRID;
      }

      while iRID <= RID_MAZE_ROOM_END
      {
         bExists = FALSE;
         foreach i in plMazeRooms
         {
            if Send(i,@GetRoomNum) = iRID
            {
               bExists = TRUE;
            }
         }

         if NOT bExists
         {
            return iRID;
         }

         iRID = iRID + 1;
      }

      return 0;
   }

   GetExit()
   {
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
