% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Player is Battler

% Don't instantiate this class--use things derived from it

constants:

   include blakston.khd
   include protocol.khd

   TRAINING_POINT_CAP = 320000
   
   ACCUMULATED_WISDOM_TO_TRAINING_POINTS_CAP = 320000

   % Three minutes
   BOND_REPORT_INTERVAL = 1000 * 60 * 3
   
   % One minute
   DEATH_RIFT_INTERVAL = 1000 * 60

   KARMA_TUNE_A_INVERSE = 20
   KARMA_TUNE_B_INVERSE = 5

   %%% COMBAT PACING PARAMETERS
   % These parameters control how often it is possible to have combat
   % assuming readily available opponents.   Xian 4/3/96
   %
   % Parameter: Base Regeneration Time (sec)
   % Meaning:   Time needed for a nearly-killed player of stamina 25 
   %             to rest fully or player of intelligence 25 to recover mana
   % Formula:   BASE_REGEN_TIME / 1000
   % Currently: 150 sec = 2.5 min
   % Note:      The fastest time scale
   %
   % Parameter: Vigor Recovery Time (sec)
   % Meaning:   Time needed to fully rest after complete vigor depletion
   % Formula:   REST_THRESHOLD * REST_TIME / 1000
   % Currently: 200 sec = 3.3 min
   % Note:      Should be slower than health and mana refresh
   % 
   % Parameter: Food Digestion Time (sec)
   % Meaning:   Time needed to completely empty a full stomach
   % Formula:   10000 / FOOD_USE_RATE
   % Currently: 833 sec = 13.9 min
   % Note:      Need empty stomach to get vigor boost from food
   BASE_REGEN_TIME = 150000

   % Rate at which stomach empties.
   FOOD_USE_RATE = 12

   % Smallest worthwhile change to vigor (X 10e-4)
   MIN_VIGOR_CHANGE = 20000

   % Effective vigor debit per attack (X 10e-4)
   ATTACK_EXERTION = 5000

   % Number of ms required to gain one vigor point
   REST_TIME = 2500          

   % Number of ms to lose one boosted health or mana point.
   BOOST_DECAY_TIME = 30000 

   % Currently: 10 improves every 15-22 minutes.
   ADVANCE_TIMER_MIN =   900000
   ADVANCE_TIMER_MAX =   1320000
   ADVANCEMENT_LIMIT =   10

   PKPOINTER_TIME = 10*60*1000

   PLAYER_TRANSLATION_LEGS_MASK = 0xff
   PLAYER_TRANSLATION_LEGS_MUL = 1
   PLAYER_TRANSLATION_BODY_MASK = 0xff00
   PLAYER_TRANSLATION_BODY_MUL = 0x100
   PLAYER_TRANSLATION_Skin_MASK = 0xff0000
   PLAYER_TRANSLATION_Skin_MUL = 0x10000

   PLAYER_TRANSLATION2_HAIR_MASK = 0xff
   PLAYER_TRANSLATION2_HAIR_MUL = 1
   PLAYER_TRANSLATION2_ARMS_MASK = 0xff00
   PLAYER_TRANSLATION2_ARMS_MUL = 0x100

   BASE_NEED = 105

   % If vigor gets this low, see if second wind skill kicks in.
   SECONDWIND_THRESHOLD = 25

   % If health gets below this percentage of max health, see if zealous fervor skill kicks in.
   ZEALOUS_FERVOR_THRESHOLD = 25
   
   % How steep is the curve for learning new levels of spells?
   %  A higher number means a greater slope (less points at low levels)
   POINTS_SLOPE = 7                 

   % Sets a reasonable lower level on the number of percents needed to
   %  advance to the next level of spells/skills.
   MIN_NEEDED_TO_ADVANCE = 75       
                                    
   % How many weapon swings until we get an improve check?
   SWINGS_PER_IMPROVE_CHECK = 75    

   % What's the length after having a player attacked before we let "mules" 
   %  cast on them again.  Currently set to 15 minutes.  Should be bigger 
   %  than logoff ghost time (currently 10 mins)
   ATTACKED_PLAYER_WAIT = 15 * 60

   % Damage is capped at piBase_Max_Health divided by this number.  Reduces
   %  newbie slaughter.
   MAX_HEALTH_DAMAGE_FRACTION = 3

   % Damage is overall capped to this number.  Gives a slight edge to people
   %  with higher hps.
   MAX_DAMAGE_PER_HIT = 30

   % What's the maximum stat we can have after modification?
   MAXIMUM_STAT = 100

   % how long to wait before sending another pvp notify sound (seconds)
   PVP_NOTIFY_DECAY = 5 * 60
   
   % Reincarnation:
   % Every earned training point is 1 accumulated wisdom point.
   % Every earned improve in a skill or spell gives accumulated wisdom points equal to the level of the skill or spell.
   % Level 1 = 1, level 3 = 3, level 6 = 6.
   % Meditating does NOT count for this, otherwise we'd be giving people accumulated wisdom for earning AND spending training points.
   %
   % When you reincarnate, your hit points are converted into accumulated wisdom as the bonus percentage for reincarnation.
   % For example, if you have 1000 accumulated wisdom,
   %    and you reincarnate with 20 hp, you retain 1000 wisdom - no bonus.
   %    But reincarnating with 150 hp gives a full percentage bonus of 20%.
   %    Giving you 200 free wisdom.
   
resources:

   include player.lkod

   player_cant_broadcast = \
      "You can't broadcast a message--you don't have enough mana."
   player_squelched = "You are prevented from communicating for now."
   player_cant_send = \
      "You can't send this message--you don't have enough mana."
   player_silent_room = "Your telepathic abilities will not work here."

   player_use_broken = "You can't use %s%s--it's broken."
   player_cant_use = "You can't use that."
   player_using_already = "You are already using that."
   player_use_full = "You are using too many things like that already."
   player_use_full_hands = "Your hands are too full to use that."
   player_not_using = "You are not using that."
   player_not_holding = "You are not even holding %s%s."
   player_regbag_empty = "The reagent bag is empty."
   
   player_hit_color_red = "~r"
   player_hit_color_blue = "~b"
   player_hit_color_none = ""

   player_token_reward = \
      "Let me give you %s%s as payment for returning the token."
   player_token_reward_heavy = \
      "Feel free to take the %s%s by your feet as payment for returning the "
      "token."
   player_improve_maxhealth = "~I~BYou suddenly feel a little tougher."
   player_improve_health_invigorate = \
      "~I~BYou feel invigorated by your success."
   player_spits = "You spit on the corpse of your unworthy foe."
   player_regain_angel = \
      "Due to your weakness, your protective guardian angel returns."
   player_no_angel = "You suddenly feel more vulnerable."

   player_join_faction = \
      "~IYour name is entered on the roll of membership for %s%s's political "
      "faction."
   player_lost_token_hall = \
      "The token refuses to enter the guild hall and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_arena = \
      "The token refuses to enter the arena and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_survival = \
      "You suddenly lose your grasp on the token as you are pulled "
      "across dimensions."
   player_lost_token_generic = \
      "The token refuses to enter this room and writhes in your hands.  "
      "You cannot hold it."
   player_intrigue_shut = "~IThe Royal Court no longer needs your services."
   player_lost_intriguing = \
      "~IYou doubt you are still worthy of notice by the Royal Court."
   player_faction_time = \
      "~IYour liege is no longer convinced of your loyalty. You should visit "
      "your liege at court again."
   player_faction_attacked = \
      "~BYou have attacked a member of your own faction!"
   player_non_intriguing_attacked = \
      "~BYou have displeased your liege by attacking a potential future ally!"
   player_unfactioned = \
      "~IYour liege has no use for one such as you, lacking in prowess or "
      "devotion.  Your name has been stricken from the roll of membership.~n"

   player_cancel_rescue = \
      "~IYour aggression halts your attempt to escape from the "
      "current situation."

   player_cancel_rescue_phase = \
      "~IThe protective magics that might have rescued you instead "
      "snap and fade as you phase out of existence."
   player_cancel_rescue_newowner = \
      "~IYour change of location disrupts Shal'ille's attempt to whisk "
      "you to safety."

   player_temp_safe = \
      "~I~BYou feel your guardian angel is near to you."
   player_temp_safe_end = \
      "~I~BYou feel your guardian angel has departed once more."

   player_improved = "~I~BYou have improved in the art of %s."
   player_improved_wav_rsc = imp.wav
   player_aggressor = "Shal'ille frowns upon your unprovoked attack."
   player_aggressor_minion = \
      "Shal'ille frowns upon your unprovoked attack on %s%s's minion."
   player_safety_caught = \
      "Hey!  You almost hit %s%s!  Good thing your safety was on!"
   player_safety_caught_minion = \
      "Hey!  You almost hit %s%s's minion! Good thing your safety was on!"
   player_own_minion = \
      "You cannot attack your own minion!"

   player_safe_server = \
      "You are not allowed to attack other players in this world."
   player_no_enter = \
      "Your guardian angel holds you back and prevents you from entering here."
   player_no_enter_ladder = \
      "You cannot enter a guild hall while part of a ladder competition."
   player_assgame_soon = \
      "~kRoq tells you, \"~IA new Assassin's Circle shall be initiated "
      "shortly.\""

   player_tougher_wav_rsc = tougher.wav
   player_missed_something_wave_rsc = swordmis.wav
   player_killed_something = "You killed %s%s."
   player_killed_player = \
      "You have killed another player and have been branded a murderer."
   player_wanted_now = "You are now wanted for the murder of %s%s."
   player_haunted_on = "%s%s's violent death summons forth a revenant."
   player_haunted_off = "The revenant is satisfied."
   
   player_training_inform = "You now have ~B%i~B training points!"
   player_reached_maxtraining = \
      "You now have ~B%i~B training points and can not gain any more!  "
      "Cast the Meditate spell and say the name of a spell or skill out loud "
      "to use your points to train it."
   player_gained_training = "You have gained ~B%i~B training points!"
   player_spent_training = "You have spent ~B%i~B training points!"
   player_logon_bonus = \
      "You have received your daily training bonus of ~B%i~B points!  "
      "Come back tomorrow for more!"
   player_experience_gained = "You have gained ~B%i~B experience points!"
   player_experience_bonus = "Your guild powers grant you an additional ~B%i~B bonus experience points!"
   player_experience_lost = "You have lost ~B~r%i~B experience points!"

   player_unbound_energy_wiped = "The volatile energy surrounding you "
      "dissipates in the violently twisting aether."
   player_unbound_energy_gained = "You gather ~B~t%i~v~B unbound energy "
      "from your fallen enemy."
   player_unbound_energy_lost = "You channel ~B~t%i~v~B unbound energy "
      "to shape your spell."
   player_unbound_energy_wasted = "Your mind is too preoccupied with your "
      "recent encounter to make any use of the subtle energies dispersing "
      "before your eyes."

   player_health_gain_maxed = "Your health cannot increase any further."

   player_cant_hit_newbie = \
      "You are not yet experienced enough to fight other players."
   player_cant_hit_newbie_minion = \
      "This creature is the servant of another player - you are not yet "
      "experienced enough to fight it."
   player_guardian_angel = \
      "A guardian angel whispers to you, \"You may not attack %s%s.\""
   player_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot protect you here.\""
   player_angel_rejoins = "Your guardian angel rejoins you."
   player_lose_node = "You lose your connection to the mana node in %s."

   player_hit_immunity =  "%s%s%s laughs off your pitiful blow."
   player_hit_resisted = "%s%s%s shrugs off your attack."
   player_hit_anti_resisted = "%s%s%s staggers backwards from the blow."
   player_hit_anti_immunity = \
      "%s%s%s convulses and seems to be suffering badly."
   
   player_immune_to_hit = "%sMysteriously, you feel almost no pain!"
   player_resists_hit = "%sMuch of the pain fades away."
   player_anti_resists_hit = \
      "%sThe pain seems to resonate and grow inside you."
   player_anti_immune_to_hit = \
      "%sYour body is wracked with pain of incredible magnitude."
   
   player_was_missed = "%s%s%s misses you."
   player_was_hit = "%s%s%s hits you."
   player_was_slashed = "%s%s%s slashes your side, leaving a nasty cut."
   player_was_bludgeoned = "%s%s%s bludgeons you, causing a large bruise."
   player_was_pierced = "%s%s%s slyly pierces you while you were distracted."
   player_was_thrusted = "%s%s%s skewers you with a deft thrust.  Sluish!"
   player_was_burned = "%s%s%s's fire flares brightly, leaving you charred."
   player_was_shocked = "%s%s%s grins as a jolt of electricity hits you."
   player_was_frozen = "%s%s%s stings you with a jolt of cold."
   player_was_quaked = "%s%s%s's tremors shake you about."
   player_was_holyhit = "%s%s%s hits you with a jolt of purity."
   player_was_unholyhit = \
      "%s%s%s hits you, and you feel your soul has been invaded."
   player_was_stung = "%s%s%s dances away after having stung you badly."
   player_was_bitten = "%s%s%s bites you several times, leaving you bloody."
   player_was_clawed = "%s%s%s rends your flesh with razor sharp claws."
   player_was_punched = "%s%s%s hits you with a solid punch."
   player_was_kicked = "%s%s%s slams a foot into your gut."
   
   player_out_of_room = "%s%s is not here."
   player_not_supported = "Not supported yet"
   
   player_attack_out_of_range = "%s%s is too far away to hit with %s%s."
   player_attack_out_of_punch_range = "You can't reach %s%s with your %s."
   player_attack_out_of_spell_range = "%s%s is out of range."
   player_attack_not_in_view = "You can't see your selected target."

   player_no_target_self = "You cannot attack yourself."
   player_no_target_self_spell = "You cannot cast this spell on yourself."
   
   player_out_of_ladder = "%s%s is not part of your ladder competition."
   player_is_in_ladder = "%s is participating in the ladder competition.\n"
   player_ranked_in_ladder_one = "%s achieved rank %i in the First Meridian Ladder.\n"
   player_ranked_in_ladder = "%s achieved rank %i in ladder competition %i.\n"

   player_cant_apply = "You can't use %s%s on other things."
   
   player_wave_hit = hit.wav
   
   player_level_music = perc2.mp3
   
   % These are now old resources..... here in case we want to de-hack...
   player_desc_guild = "%q of %s%q."
   player_no_guild = "No known guild affiliation."
   player_faction_duke = "A staunch servant of Duke Akardius.\n"
   player_faction_princess = "Firmly loyal to Princess Kateriina.\n"
   player_faction_rebel = "A freedom fighter supporting Jonas.\n"
   player_faction_neutral = \
      "Not a court vassal, yet affected by the Meridian Council."
   player_not_intriguing = "Not yet concerned with affairs at the Royal Court."

   player_race_orc = "%s appears to be of half-orc ancestry.\n"
   player_race_demon = "%s appears to be of half-demon ancestry.\n"
   player_race_elf = "%s appears to be of half-elf ancestry.\n"
   player_race_undine = "%s appears to be of half-undine ancestry.\n"
   player_race_drow = "%s appears to be of drow ancestry.\n"
   player_race_dragon = "%s appears to be of draconian ancestry.\n"
   player_race_gnome = "%s appears to be of gnomish ancestry.\n"
   player_race_automaton = "%s appears to be an artificial construct.\n"

   player_opt_out_pvp = \
      "%s is a dedicated practitioner of Shal'ille's peaceful path.\n"

   player_nl = "\n"
   player_sp = " "
   player_dot = "."

   % Master fixed info resource.
   player_fixed_info = "%r%r%r%r%s%r%r%s%q%r%r%r%r"

   % Mastery strings for hall of heroes statues
   player_statue_greatest_adventurer = "%s is the greatest adventurer in the land."
   player_statue_greatest_wizard = "%s is the greatest wizard in the land."
   player_statue_greatest_warrior = "%s is the greatest warrior in the land."
   player_statue_master_shal = "%s is the current master of Shal'ille."
   player_statue_master_qor = "%s is the current master of Qor."
   player_statue_master_riija = "%s is the current master of Riija."
   player_statue_master_faren = "%s is the current master of Faren."
   player_statue_master_kraanan = "%s is the current master of Kraanan."
   player_statue_master_jala = "%s is the current master of Jala."
   player_statue_master_weaponcraft = "%s is the current master of Weaponcraft."
   player_statue_master_knightcraft = "%s is the current master of Knightcraft."
   player_statue_master_banditry = "%s is the current master of Banditry."
   player_statue_master_witchery = "%s is the current master of Witchery."
   player_statue_master_sorcery = "%s is the current master of Sorcery."
   player_statue_master_alchemy = "%s is the current master of Alchemy."

   % Hometown strings.
   player_hometown_rsc = "%s%s%s%q%s\n"
   player_citizen_adventurers_league = " has called the Adventurer's League home"
   player_citizen_barloque = " has been a Barloquan"
   player_citizen_tos = " has been a citizen of Tos"
   player_citizen_cornoth = " hailed from Cor Noth"
   player_citizen_jasper = " has called Jasper home"
   player_citizen_marion = " has been a Marionite"
   player_citizen_raza = " is of Raza"
   player_citizen_hazar = " is of Hazar"
   player_citizen_kocatan = " has lived in Ko'catan"
   player_citizen_unknown = " has wandered"
   player_of = " of "
   player_for = " for "
   player_years = " years."
   player_year = " year."
   player_under_one_year = " less than a year."

   player_guild_rsc = "%q%s%s%q.\n"
   player_is_holding = "%s is holding %s%s.\n"
   player_is_wearing = "%s is wearing %s%s.\n"
   player_donation_title = "Noble benefactor of Meridian in %q."
   player_donation_separator = ", "
   player_is_justicar = "Elected Royal Justicar of the Meridian."

   player_known_for_mastery = "Known far and wide for mastery of "
   player_and = " and "
   player_magics = " magics"
   player_skills = "weaponcraft skills"
   
   %
   %  Players may master one skill or spell above all others,
   %     gaining exceptional abilities. These are generally
   %     improvements to usability or effectiveness against multiple targets.
   %     They are not simply damage boosts.
   %
   %  Mace fighting: Player has a might-based chance to stun with mace attacks.
   %  Archery: 
   %  
   %
   %
   %
   %  Tumbling: When you tumble out of the way of a melee attack, you move to the side of the target and attempt to strike them.
   %  Sneak: You are always sneaking.
   %  Hide: You are always hidden.
   %  Tight Grip: You counter enemy disarm attempts with a disarm attempt of your own (whether or not you have the disarm skill).
   %  Track: Your Track range increases to 5 rooms distant.
   %
   %  COMPLETE:
   %  Axe Wielding: greatly reduced vigor drain for Cleave.
   %  Inert Form: Your resistance to elemental status effects is tripled.
   %
   %  Hammer wielding: Player can perform a short 'leap attack', jumping forward to strike an opponent that would otherwise be out of range (range 2-4).
   %  Scimitar wielding: Player can drain a point of vigor from other players when they deal slashing damage with a scimitar equipped.
   %  Fencing: Player gains defense equal to half their fencing weapon's offense bonus.
   %  Dagger Wielding: Player's parry defense rises as their health drops, up to double.
   %  Hermitage: You are virtually immune to hexes.
   %
   %  Fireball: Player's fireballs deal splash damage in a radius around the target.
   %  Lightning bolt: Player's lightning bolt chains to also hit the closest additional enemy to the target. Prioritizes player enemies over monster enemies.
   %  Earthquake: Player's earthquake has tripled radius.
   %  Flame dash: Player's flame dash range is tripled.
   %
   player_mastered_skill_num = \
      "%s is a notable %s master.\n"
   player_mastered_spell_num = \
      "%s is a renowned %s adept.\n"

   % Here's the new extended resources....
   player_desc_guild_faction_neutral = \
      "%q of %s%q.  Not associated with any faction, yet concerned with the "
      "intrigue of the Royal Court."
   player_desc_guild_faction_duke = \
      "%q of %s%q.  A devoted servant of Duke Akardius."
   player_desc_guild_faction_princess = \
      "%q of %s%q.  Firmly loyal to Princess Kateriina."
   player_desc_guild_not_intriguing = \
      "%q of %s%q.  Not yet concerned with affairs at the Royal Court."

   player_no_guild_faction_neutral = \
      "No known guild affiliation. Not associated with any faction, yet "
      "concerned with the intrigue of the Royal Court."
   player_no_guild_faction_duke = \
      "No known guild affiliation. A devoted servant of Duke Akardius."
   player_no_guild_faction_princess = \
      "No known guild affiliation. Firmly loyal to Princess Kateriina."
   player_no_guild_not_intriguing = \
      "No known guild affiliation. Not yet concerned with affairs at the "
      "Royal Court."

   player_dagger_shatters = "Your black dagger crumbles into dust."

   player_desc_enchanted_none = "%q"
   player_desc_enchanted = "%s has %s%s.\n\n%s"
   
   player_too_full = "You are too full to eat."
   player_too_full_drink = "You are too full to drink."

   player_to_hunters = "You detect that %s%s could be found somewhere around %s"

   player_dead_male_icona_rsc = playerXa.bgf
   player_dead_male_iconb_rsc = playerXb.bgf
   player_dead_female_icona_rsc = heraXa.bgf
   player_dead_female_iconb_rsc = heraXb.bgf
   
   player_dead_male_name_rsc = "dead male body"
   player_dead_female_name_rsc = "dead female body"
   
   playerm_death_wav = pdeath.wav
   playerf_death_wav = pdeathf.wav

   player_token_death = \
      "As you die, the token pulsates, and you feel an odd sensation..."

   player_dance = \
      "You swallow your pride and get down to the ditty in your head."
   player_cant_dance = \
      "You can't dance, all the stuff in your hands is cramping your style!"
   player_cant_dance_resting = \
      "You're sitting right now.  Let's not take this \'getting down\' stuff "
      "too literally, ok?"
   player_stop_dance = \
      "You lose your rhythm and settle out of your dancing frenzy." 

   player_wave = "You wave your hand."
   player_point = "You point."
   
   player_sword_overlay_icon_rsc = swordov.bgf
   player_mace_overlay_icon_rsc = maceov.bgf
   player_scimitar_overlay_icon_rsc = scimov.bgf
   player_short_sword_overlay_icon_rsc = shswdov.bgf
   player_hammer_overlay_icon_rsc = hamrov.bgf
   player_axe_overlay_icon_rsc = axeov.bgf
   
   player_window_overlay_hand = povhand.bgf
   player_window_overlay_glow = povglow.bgf

   player_male_icon_rsc = bta.bgf
   player_female_icon_rsc = btb.bgf  
   
   player_legs_a_rsc = bfa.bgf
   player_legs_b_rsc = bfb.bgf
   player_legs_c_rsc = bfc.bgf
   player_legs_d_rsc = bfd.bgf
  
   player_rightarm_a_rsc = bra.bgf
   player_rightarm_b_rsc = brb.bgf
   
   player_leftarm_a_rsc = bla.bgf
   player_leftarm_b_rsc = blb.bgf
   
   player_rightarm_robes_male_beer = brc.bgf
   player_rightarm_robes_female_beer = brd.bgf
   
   player_right_arm_gauntlets_female_beer = brj.bgf
   player_right_arm_gauntlets_male_beer = brk.bgf
   
   player_right_arm_male_beer = brl.bgf
   player_right_arm_female_beer = brm.bgf
   
   % hair for Rob
   player_toupee_q_rsc = ptq.bgf

   player_sound_learn_spell = splearn.wav

   player_angel = "Your guardian angel"
   intrigue_ambassador = "Baron Springer of Cor Noth Township"

   player_newbie_honor_string = "This soul is new to the lands of Meridian 59."

   player_newbie_commands = \
      "\n~BBasic Commands for Meridian 59:~B\n"
      "~IUse these mouse and keyboard commands to interact with the world.\n"
      "These are the default commands.  You can change the keyboard commands "
      "by going to the menu item~I ~wGame > Configuration.\n"
      "~rright-click on an object ~b- examines an object, letting you see "
      "more detail.  Right-click on the sign in this area to learn more.\n"
      "~rspace bar ~b- go through doors, like the blue door to the north.\n"
      "~rE key ~b- attack monsters.  You may want to wield a weapon first!\n"
      "~n~IType the following commands (red text) into the text bar below. "
      "You can press the RETURN key to move to the chat window.~I\n"
      "~rsay (message) ~b- send a message to everyone in the same room.\n"
      "~rtell (player name) (message) ~b- Send a message to a single player "
      "in private.\n"
      "~rbroadcast (message) ~b- send a message to everyone that is logged "
      "on.\n"
      "~rwho ~b- shows a list of all the people logged into the game right "
      "now.\n"
      "~rmail ~b- opens up your mail folder.  Read the messages from your "
      "guardian angel!\n"
      "~rhelp ~b- opens our web-based help pages.  It will take a few "
      "seconds to load.\n"

   player_safety_on_mail = \
      "Your safety is currently on, meaning you cannot cast hostile spells or "
      "attack innocent players."
   player_safety_off_mail = \
      "Your safety is currently off.  If you do not wish to attack innocent "
      "players, I heartily recommend that you turn it on."

   player_ready_to_kill = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword against other "
      "players if you so desire.  It is with a heavy heart that I take my "
      "leave of you, but I trust that you will do fine without me."
      "\n\n"
      "You also have many other rights and responsibilities available to "
      "you.  You can now join a guild with other friends.  Guilds are a good "
      "way to gain protection from those that would do you harm.  Joining a "
      "good guild will make the difference between merely surviving or "
      "thriving in the world.  Guilds can also get into wars with other "
      "guilds, so be careful that you don't make too many enemies."
      "\n\n"
      "I must warn you that engaging in lethal combat against other players "
      "may soil your good name.  If you strike an innocent, or cast "
      "a spell which harms him, you may be branded an outlaw, an onus which "
      "only fades upon your death.  If you slay an innocent in cold blood, "
      "you will be blacklisted as a murderer, and this is a weight upon your "
      "soul which does not easily depart.  This puts you at risk:  since "
      "murderers and outlaws are not innocents, one may attack them without "
      "being named a murderer or an outlaw."
      "\n\n"
      "Also note that assisting an outlaw or murder by casting helpful spells "
      "upon them will brand you an outlaw in the eyes of society.  You must "
      "choose your friends and your enemies well!"
      "\n\n"
      "If you do not wish to engage in the unsavory practice of attacking "
      "innocents or assisting the unlawful, it is heartily recommended that "
      "you do not enable attacking innocents in your game preferences.  This "
      "is also called your \"safety\" since it keeps you safe from being "
      "outcast as an unlawful outlaw or murderer.  While your safety is on, "
      "you are not permitted to either attack innocents or cast spells that "
      "are hostile to them.  This can be crucial when one stray sword blow "
      "can make you an outlaw.  However, rest assured that you will always be "
      "permitted to strike outlaws and murderers, since it is crucial that "
      "you always have the option of defending yourself from their "
      "treacherous ways."
      "\n\n"
      "%s"
      "\n\n"
      "Finally, some last bits of advice as I depart.  Do not despair if "
      "you are sent to the underworld by some monster or even another "
      "player.  Death is part of the cycle, and learning to recover from "
      "death is important.  Put some items away in the vault in Barloque for "
      "times when you find yourself killed and unable to get items from your "
      "corpse.  Also, ask politely for assistance and you will often find "
      "someone willing to lend a helping hand.  Make some friends and you "
      "will find that nothing is truly beyond your reach."
      "\n\n"
      "Have fun in Meridian!"
      "\n\n"
      "  -- Your guardian angel"

   player_ready_to_guild = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword with fellow "
      "players and engage in guild politics.  It is with a heavy heart that I "
      "take my leave of you, but I trust that you will do fine without me.\n\n"
      "%s\n\n"
      "  -- Your guardian angel"

   player_tutorial_mail = "Subject: You're doing well for yourself.\n"
      "It's nice to see that you seem to be doing well.  "
      "I thought I might take this time to explain some finer points of "
      "the world of Meridian to you."
      "\n\n"
      "There are a variety of spells and skill schools that you can "
      "advance in.  However, learning from all spell and skill schools "
      "dilutes your focus, and slows down your learning.  The more you "
      "narrow your focus onto one or two particular spell schools, the "
      "quicker you will advance in that spell school, and the sooner you "
      "will be offered new spells in that school.  Stray from the path, "
      "however, and you will find that teachers may not offer you spells that "
      "they had previously offered you.  Thus, you must choose very early on "
      "whether or not you prefer the versatility of being able to pull from a "
      "multitude of low level spells and skills, or the power of excelling in "
      "one or two.  Therefore, be sure that you examine any potential ability "
      "before you acquire it!"
      "\n\n"
      "No advancement is more prized than increasing your endurance by "
      "gaining health points.  Note you that those who go toe to toe with "
      "monsters are more likely to advance in health than those who stay "
      "safely out of harm's way, slinging fireballs.  Also, attacking "
      "insignificant foes earns you no points for valor, and offers no hope "
      "of advancement."
      "\n\n"
      "Your vigor is crucial - it helps determine how fast your health and "
      "mana returns to you - a tired warrior will find these resources "
      "fleeting.  Vigor can be restored either through needed rest or a "
      "hearty meal."
      "\n\n"
      "I congratulate you on your recent success.  I know the bards will sing "
      "of your future exploits."
      "\n\n"
      "  -- Your guardian angel"

   player_first_mail = "Subject: Welcome!\n"
      "Welcome to Meridian 59!  I hope you enjoy the exciting world waiting "
      "for you!"
      "\n\n"
      "You have entered an on-line community, meaning that you may well be "
      "playing with several other players at a time.  Making allies and "
      "dealing with potential enemy players is as much a part of Meridian 59 "
      "as killing monsters.  We hope you feel at home in your new online "
      "community."
      "\n\n"
      "I am your guardian angel, and thus I shall protect you from the spells "
      "and swords of other players for a short time.  Use this time to "
      "acquaint yourself with the world, and to gather your resources.  Know "
      "you that the shops of the land are always safe zones, and the inns are "
      "good places to rest and recover your strength."
      "\n\n"
      "Spells and skills will almost certainly be crucial to your success.  "
      "Note that a young warrior's skills are stronger than a inexperienced "
      "wizard's spells, but at the higher end, the sorcerer is far more "
      "formidable to deal with given his variety of options.  The apprentice "
      "will almost always need the steady sword of the mercenary by his side "
      "to get that far, so find comrades who complement your abilities."
      "\n\n"
      "You can learn a lot by talking to the little people: the shopkeepers, "
      "the bankers, the innkeepers.  Ask them for help.  Sometimes, they "
      "may even wish for you to run an errand for them if you ask."
      "\n\n"
      "For your first quest, you may wish to research which hometown you were "
      "born in.  You can ask any of the towns' people you meet for their "
      "opinions about the different towns.  To permanently select a hometown, "
      "you need to adventure to the Hall of Genealogy in the town of Cor Noth "
      "and look through the books there.  Take your time selecting your "
      "hometown, as it may determine how other people interact with you."
      "\n\n"
      "Death is unkind to you - avoid it!  A death can make you weaker, and "
      "all of your possessions are left where you met your demise, where any "
      "scavenger, human or otherwise, may take it as they please.  Best that "
      "you join an ally on your travels that they may gather your valuables "
      "should you meet such an unfortunate fate."
      "\n\n"
      "Lastly, if you wish to leave this land for a bit, it is recommended to "
      "log off in a safe place, such as an Inn or Adventurer's Hall.  For "
      "brief exits from the game, you can use the spell Phase to disconnect "
      "you from this plane of existence, rendering you unable to be harmed.  "
      "However if you Phase or log off without your guardian angel for longer "
      "than 8 minutes for innocents (3 minutes for murderers), you will take "
      "a penalty (dropping item(s) and losing skill and spell points) and be "
      "sent back to the last safe location you visited."
      "\n\n"
      "We hope that you enjoy your stay in our land."
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail = "Subject: Death\n"
      "It saddens me that you fell in combat and into the underworld.  It is "
      "a dangerous life as an adventurer, as you have undoubtedly learned."
      "\n\n"
      "Since you are so young, I have pleaded to the gods that you should be "
      "spared some of the penalty for death.  Normally, the shock of leaving "
      "the underworld would reduce your maximum health and penalize you a "
      "small part of the spells and skills you have learned so far.  I will "
      "spare you the cost of your health, and only a few of your spells and "
      "skill will be reduced after you leave the underworld."
      "\n\n"
      "You will also notice that your possessions are gone.  They were left "
      "behind at your corpse where you died.  The items will only remain "
      "there a limited amount of time, so you must act quickly."
      "\n\n"
      "If you don't know where you died, then you should broadcast for help.  "
      "Type \"broadcast Can someone help me find my items?\" right now and "
      "watch for someone to respond to you.  Tell that person what you can "
      "remember about where you were fighting.  Often you will find someone "
      "kind to help you, or they might even help you get better equipment "
      "than you had before.  There are many kind souls in this land"
      "\n\n"
      "If you know where you died, the portal archways in the underworld will "
      "take you directly to the inns of the cities of the mainland.  The "
      "large rip in space in the western side of the underworld is often the "
      "quickest way back.  It randomly switches between the different inns.  "
      "Look (right-click by default) the portal to see where it leads.  If it "
      "leads to the place you want to go, enter it quickly!  It will not lead "
      "there for very long."
      "\n\n"
      "Do not be discouraged!  Many powerful warriors have stumbled into the "
      "fires of the underworld.  What makes them powerful is that they "
      "decided to fight on, gaining power and ability to vanquish the "
      "terrible monsters that felled them before!"
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail_notice = \
      "Your guardian angel has sent you a special game mail on how to cope "
      "with death.  Type ~Imail~I and read the last game mail from your "
      "guardian angel."

   player_intrigue_mail = "Subject: Invitation to visit the Royal Court\n"
      "Oh, most worthy adventurer.  Tales of your exploits have been oft told "
      "here at the Court, and recently, the Meridian Council itself declared "
      "you to possess considerable promise. Perhaps someday you will be "
      "given the honor of studying and guarding one of the Five Tokens."
      "\n\n"
      "The Council serves our fair land by using their acquired knowledge to "
      "benefit daily life. For the most part, they are honest and impartial "
      "in their decisions - guided by the Priestess of Shal'ille. However, "
      "Duke Akardius and Princess Kateriina and their factions of followers "
      "try to sway the Council down differing paths:"
      "\n\n"
      "Duke Akardius wishes for more of the Council's energies to be used for "
      "the benefit of commerce and the study of lore, while the Princess "
      "seeks their aid in advancing knowledge of magic. Both believe their "
      "path is the way to reduce the plague of monsters which terrify the "
      "land these days."
      "\n\n"
      "There are also boorish tales of a third faction of rebels.  They "
      "are dissatisfied with the current political climate and seek to "
      "bring their leader to rule our lands.  I do not know much about "
      "these rebels, nor do I care to learn anything.  You are on your own "
      "if you wish to learn about them."
      "\n\n"
      "Should you desire to join any of these factions, seek the Liege. "
      "As a faction member, you can help to influence the Council yourself, "
      "and share in the benefits of belonging to the party in power. You will "
      "need to demonstrate fealty to your Liege on a regular basis to "
      "keep your name on the rolls. Even if you join neither faction, you "
      "will still be influenced by the Council's decisions - as are all."
      "\n\n"
      "Fair partings, and perhaps we will someday meet at the court."
      "\n\n"
      "----Baron of Cor Noth Township, Gerah Springer."

   player_Debug_playercanlearn = \
      "Do the math for %s to learn a %i level spell from the %s school.  "
      "%i points from spells already known (%i from this school).  Intellect "
      "reduces the needed by %i for a total of %i percent needed.  Currently "
      "possesses %i percent to compensate for the need."

   player_Debug_playercanlearn_scarcity = \
      "Due to the scarcity of spells at that level in that school, "
      "the need has been reduced to %i more points."
   
   player_Debug_nokarma = "%s cannot learn %s due to karma restrictions."
   player_Debug_noway = "It is impossible for %s to ever get the %s spell."

   player_sound_sword1 = sword1.wav
   player_sound_sword2 = sword2.wav
   player_sound_sword3 = sword3.wav

   player_sound_metal1 = swrdmtl1.wav
   player_sound_metal2 = swrdmtl2.wav
   player_sound_metal3 = swrdmtl3.wav

   player_sound_hit_monster_flesh1 = fhit1b.wav
   player_sound_hit_monster_flesh2 = fhit2b.wav
   player_sound_hit_monster_flesh3 = fhit3b.wav

   player_sound_hit_monster_leather1 = lhit1b.wav
   player_sound_hit_monster_leather2 = lhit2b.wav
   player_sound_hit_monster_leather3 = lhit3b.wav

   player_sound_hit_monster_metal1 = mhit1b.wav
   player_sound_hit_monster_metal2 = mhit2b.wav
   player_sound_hit_monster_metal3 = mhit3b.wav

   % in increasing order of agony
   player_sound_male_ouch1 = ouchm1.wav
   player_sound_male_ouch2 = ouchm2.wav
   player_sound_male_ouch3 = ouchm3.wav
   player_sound_male_ouch4 = ouchm4.wav

   player_sound_female_ouch1 = ouchf1.wav
   player_sound_female_ouch2 = ouchf2.wav
   player_sound_female_ouch3 = ouchf3.wav
   player_sound_female_ouch4 = ouchf4.wav

   player_eavesdrop_login_str = "~B~g[~n%s has logged in.~B~g]"
   player_eavesdrop_str = "~B~g[~n%s tells %s, \"%q~n\"~B~g]"
   player_eavesdrop_logout_str = "~B~g[~n%s has disconnected.~B~g]"

   player_admin_added_spell = "Spell added."
   player_admin_modified_spell = "Spell modified."
   player_admin_removed_spell = "Spell removed."
   player_admin_added_skill = "Skill added."
   player_admin_modified_skill = "Skill modified."
   player_admin_removed_skill = "Skill removed."

   player_logged_on_wav_rsc = player_login_or_out.wav
   player_logged_off_wav_rsc = player_logout2.wav

   death_rift_stayed_too_long = \
      "Having lingered too long while still alive, you find "
      "yourself ejected back into reality!"
   second_wind_finished = \
      "You feel more relaxed as your second wind dissipates."
   zealous_fervor_finished = \
      "Your zealous fervor fades."

   player_monster_attack_string = "monster attack"
   player_no_weapon_string = "no weapon"

   cannot_attack_ally = "You can't attack %s, %s's your ally!"
   cannot_attack_guildmate = "You can't attack %s, %s's your guildmate!"

   group_experience_rsc = \
      "You absorb a small amount of the energy released "
      "from %s's slaying of the %s."

   rod_gained_charge_msg = \
      "You sense that at least one of your magic items gained a "
      "charge from the released energy of your kill."
   rods_fully_recharged_by_safe_place_msg = \
      "This place of safety has recharged your magical rods."
   hexes_removed_by_safe_place_msg = \
      "As you reach safety, you feel your curse ebb."

   player_truced = "Shal'ille's magic compels you to respect the truce."

   Jig_cannot_attack = \
      "It wouldn't feel right to attack the %s while you two are "
      "dancing so well together!"

   phased_out_cant_use = \
      "You try to use your item, but your phased hands pass right through it."
   cannot_attack_phased_self_rsc = \
      "You can't attack anyone while phased out."
   cannot_attack_phased_player_rsc = \
      "Your strike would just go right through someone who is phased out."
   phase_fatigue_cleared = \
      "This area of peace lifts your phase fatigue."
   phased_player_description = \
      "This is the ghosted body of %q, whose consciousness has travelled to "
      "another plane of existence."
      
   bad_line_of_sight = \
      "Your hindered line of sight makes a successful hit more difficult."

   reincarnated_once = \
      "%s has found enlightenment once.\n"
   reincarnated_times = \
      "%s has found enlightenment %d times.\n"

   ready_to_reincarnate_msg = \
      "You are ready to reincarnate. Perhaps you should explore the Hall of Genealogy "
      "in Cor Noth."
   reincarnation_progress_msg = \
      "You have acquired toughness and knowledge equivalent to %i percent of the "
      "qualification for your next reincarnation."

   pvp_notify_wav = gong.wav

   lightning_attunement_msg = \
      "~BThe Essence of Lightning grants you attunement with the element of shock. "
      "For the rest of this life, your base resistance to shock has been increased by %d%%, "
      "your maximum resistance to shock has been increased by %d%%, "
      "and you will deal %d%% increased shock damage with any source."
   ice_attunement_msg = \
      "~BYour experience in the Prism of Ice has left your soul permanently chilled. "
      "For the rest of this life, your base resistance to cold has been increased by %d%%, "
      "your maximum resistance to cold has been increased by %d%%, "
      "and you will deal %d%% increased cold damage with any source."
   acid_attunement_msg = \
      "~BHaving experienced the utmost corrosive energies of the plane of acid, you come away "
      "with greater understanding of its element. "
      "For the rest of this life, your base resistance to acid has been increased by %d%%, "
      "your maximum resistance to acid has been increased by %d%%, "
      "and you will deal %d%% increased acid damage with any source."
   fire_attunement_msg = \
      "~BThe fire of battle lingers with you. Something of the plane of fire remains. "
      "For the rest of this life, your base resistance to fire has been increased by %d%%, "
      "your maximum resistance to fire has been increased by %d%%, "
      "and you will deal %d%% increased fire damage with any source."
   death_attunement_msg = \
      "~BYou are nigh upon the power the High Sorcerers have sought for centuries. "
      "Soon you may master death in ways they never could. "
      "For the rest of this life, your base resistance to unholy has been increased by %d%%, "
      "your maximum resistance to unholy has been increased by %d%%, "
      "and you will deal %d%% increased unholy damage with any source."
   life_attunement_msg = \
      "~BYour muscles vibrate with the power of rebirth. Your soul seems closer, tangible, "
      "and one with your body. "
      "For the rest of this life, your base resistance to holy has been increased by %d%%, "
      "your maximum resistance to holy has been increased by %d%%, "
      "and you will deal %d%% increased holy damage with any source."
   all_six_prisms_defeated_msg = \
      "~BAs the alignment comes to fruition and power roars through your every nerve, "
      "you realize that the balance the nomads of Biskalane have hoped for has not been achieved "
      "in the land itself - rather, it has been achieved in you. The six elements flow through you "
      "with the even measures of mastery, offering decisive power. It is time to end the High Sorcerers "
      "and finally heal the Diffraction they have caused in their foolish quest for immortality."

   attempting_cleave_msg = \
      "~B~oYou tense for a mighty cleaving swing!"
   no_enemies_in_range_msg = \
      "~oThere are no enemies in range for a cleaving attack."

   hold_rings_rsc = holdrings.bgf
   
   rewarded_money_msg = \
      "~BYou have been rewarded with %i shillings!"

   vrMaleDraconianHeadIcon = dragonbornmask.bgf
   vrFemaleDraconianHeadIcon = dragonbornmaskf.bgf

   admin_icon_blank = blank.bgf
   
   lose_song_due_to_mana_change_msg = \
      "Due to the change in your maximum mana, you lose the reservation of one of your songs!"

   report_acc_wisdom_training_points_less_cap_msg = \
      "Throughout your lifetimes in this world, you have accumulated %i wisdom. "
      "If you were to reincarnate now, that is how many Training Points you would start your new life with."
   report_acc_wisdom_bonus = \
      "You would then receive a permanent %i\% bonus on that amount for the health you have reached in this life."
   report_acc_wisdom_training_points_at_cap_msg = \
      "Throughout your lifetimes in this world, you have accumulated %i wisdom. "
      "Unfortunately, you can only take at most 320,000 Training Points with you into the next life. "
      "That is how many Training Points you would start your new life with."

   % AW goes up. When you cross thresholds, you receive stat points.
   % Stat points 1-10 are easy to reach.
   % 1: 10,000
   % 2: 20,000
   % 3: 30,000
   % 4: 45,000
   % 5: 80,000
   % 6: 120,000
   % 7: 165,000
   % 8: 205,000
   % 9: 260,000
   % 10: 320,000         <------- fully built mark. 320k TP is the highest you can ever get.
   %
   % After that, it gets incredibly hard
   % AW goes from 0 to 134,217,727
   %
   % 11: 1,000,000
   % 12: 4,000,000
   % 13: 8,000,000
   % 14: 13,000,000
   % 15: 19,000,000
   % 16: 26,000,000
   % 17: 40,000,000
   % 18: 60,000,000
   % 19: 90,000,000
   % 20: 134,217,727
   
   attained_enlightenment = \
      "~B~oYour mind and spirit surge with power as you suddenly realize a new level of enlightenment. "
      "You now have %i extra stat points born of your newfound spiritual strength. "
      "You can apply these stat points with an ancient trinket, by reincarnating, or by training with "
      "a master teacher."
   
   attained_enlightenment_ten_points = \
      "~B~oYou have reached your tenth level of enlightenment! You now have %i extra stat points born of pure spiritual strength. "
      "From this point on, continued enlightenments will be extremely difficult."
      
   max_accumulated_wisdom_achieved = \
      "~B~oYou have achieved total enlightenment. You can no longer accumulate wisdom. Your total spiritual strength is 20 extra stat points."

   gained_might_msg = \
      "~BYou feel stronger. Your Might is now %i!"
   gained_intellect_msg = \
      "~BThe workings of the world become more apparent to you. Your Intellect is now %i!"
   gained_stamina_msg = \
      "~BYou feel more solid and durable. Your Stamina is now %i!"
   gained_agility_msg = \
      "~BYou feel more agile. Your Agility is now %i!"
   gained_mysticism_msg = \
      "~BYou feel more connected with the flow of the world's energies. Your Mysticism is now %i!"
   gained_aim_msg = \
      "~BYou feel confident that you can strike more accurately. Your Aim is now %i!"

   unassigned_stat_points = \
      "You have %i unassigned stat points remaining."

   schools_report = \
      "You take a moment of introspection. Looking inward, you see knowledge of:"
   schools_report_shal = \
      "%i Shal'ille"
   schools_report_qor = \
      "%i Qor"
   schools_report_wc = \
      "%i Weaponcraft"
   schools_report_kc = \
      "%i Knightcraft"
   schools_report_banditry = \
      "%i Banditry"
   schools_report_sorcery = \
      "%i Sorcery"
   schools_report_witchery = \
      "%i Witchery"
   schools_report_alchemy = \
      "%i Alchemy"
   schools_report_kraanan = \
      "%i Kraanan"
   schools_report_faren = \
      "%i Faren"
   schools_report_riija = \
      "%i Riija"
   schools_report_jala = \
      "%i Jala"
   schools_report_bestiary = \
      "%i Bestiary"
   schools_report_shadowcraft = \
      "%i Shadowcraft"
   schools_report_intelligence_remaining = \
      "You are intelligent enough to learn %i more levels."
   schools_report_level_one_note = \
      "As a reminder, levels one and two of any school are easier to learn; together, they count as one full level." 

   lost_base_max_health_msg = \
      "~B~wYou lost ~r%i~w maximum health!!"

   new_corpse_information = \
      "~rYour loot can be "
      "obtained by getting close to your body and interacting with it like a chest. "
      "~BYour loot is inside your corpse like a chest.~B "
      "You can also summon your corpse by saying 'summon' to Priestess Xiana."

   start_holding_breath = \
      "You start holding your breath."
   undine_breath = \
      "Your undine side rejoices. You can breathe underwater!"
   automaton_breath = \
      "As an automaton, you don't require air the same way others do."
   relief_take_breath = \
      "With relief, you take a breath of open air, and begin shaking off your drowning experience."
   take_breath = \
      "You take a breath of open air."
      
   consumed_free_stat_reset = \
      "Your abilities become set in stone."
   consumed_ancient_token_reset = \
      "Your Ancient Trinket vanishes."

   master_is_phased_out_cannot_attack = \
      "Minions of an inaccessible player cannot be attacked."
   
   kill_wisdom_steal = \
      "Your senses thrill with victory. You have acquired %i wisdom from %s!"
   kill_wisdom_lose = \
      "You failed miserably, and lost %i wisdom to %s."
   
   Marauders_leave_you_alone = \
      "~BAfter laughing at your death, the Marauders lose interest in you."

   Ladder_ended_msg = \
      "~B[###] Thanks for participating in the ladder! Check your bio for your rank "
      "and your inventory for your rewards!"
      

   ladder_two_challenge_used_a_shard = \
      "~o~B[>>>] Challenge - Use one of each shard: %s used"
   ladder_two_challenge_one_complete = \
      "~o~B[>>>] Challenge - Use one of each shard: challenge complete!"
      
classvars:

   viHand_space = 2
   viBody_space = 1

   viQuiver_space = 1
   viNeck_space = 1
   viHead_space = 1
   viLeg_space = 1
   viAmulet_space = 1
   viThroat_space = 1

   viFinger_space = 2
   viGauntlet_space = 1

   % Our actual max is this plus a bonus for might.
   viBulk_hold_max = 2550
   viWeight_hold_max = 2550

   viMax_vigor = 200

properties:

   vrIcon = player_male_icon_rsc

   poSession
   pbLogged_on = FALSE

   % This is used to determine raises in hit points only.
   poKill_target = $
   piGain_chance = 0
   piExperience = 0

   % This keeps track of training points that players accumulate when 
   % killing mobs.
   piTraining_points = 0
   piInform = TRUE

   % This keeps track of unbound energy, which is used for free spell casts.
   piUnbound_energy = 0
   pbFree_cast = FALSE

   % This keeps track of when we've last received our daily training points.
   piReward_timestamp = 0

   % For those crazy people who stay logged on 24/7 and may forget to relog
   % and cash in on their daily training points, we grant the points every 24
   % hours of online time.
   ptReward_timer = $

   % Flags for various character attributes.
   piFlags = 0
   piFlags2 = 0
   piFlags3 = 0

   % Set of flags with player preferences.
   piPreferences = CF_DEFAULT_PREF

   % player starts unguilded--doesn't do much yet
   poGuild = $
   piGuildRejoinTimestamp = 0

   % Evil twin object
   poEvilTwin = $

   % list of spells we know, in the form of a 3-part compound
   plSpells = $

   % list of skills we know, in the form of a 3-part compound
   plSkills = $

   % A list of the total percentage points the player has in the various
   %  spell and skill schools.
   plSchools = $

   % A list of the weighted casts the player has made in various schools.
   % Weighted because higher level spells will contribute more points to
   % the total. Used to give bonuses to improving spells.
   % See spell.kod for details.
   plSchoolCasts = $

   % The number of swings with the current weapon
   piWeaponSwings = 0

   % A compound of if the player can advance and the WC proficiency needed
   % to use the weapon. The proficiency number is the number / 1000, while
   % the bonus to advance is the number mod 1000.
   piWeaponInfo = 0

   % converted guild commands list to a bitvector.
   piGuild_commands = 0

   piLast_restart_time = 0

   % Permanent character base stats.
   piMight = 0
   piIntellect = 0
   piStamina = 0
   piAgility = 0
   piMysticism = 0
   piAim = 0

   % Modifiers to those base stats.
   piMightMod = 0
   piIntellectMod = 0
   piStaminaMod = 0
   piAgilityMod = 0
   piMysticismMod = 0
   piAimMod = 0

   %%% Variable character values.

   % The player sees piMax_Health in their client.
   % piBase_Max_Health is their base without any modifiers
   % IMPORTANT NOTE: For higher accuracy, a battler's current health 
   %(and only current health) is inflated by a factor of 100. Doing so 
   % avoids truncation errors but is not revealed to users in any way.
   piHealth = 2000
   piMax_Health = 20
   piBase_Max_Health = 20

   piMax_Mana = 20
   piMana = 20

   % piKarma is measured in hundredths of karma units
   piKarma = 0

   % Percent stomach is full.
   piStomach = 0

   % Different races have different hunger capacities.
   piStomachMax = 100

   % Governs health and mana replacement rates
   piVigor = 100
   % Accumulates small vigor debits from attacks, etc.
   piExertion = 0

   % This replaces a timer
   piTimeLastStomachUpdate = 0

   % stuff in use
   plUsing = $

   % Timers 
   ptHealth = $
   ptAdvancement = $
   ptRest = $
   ptFortitude = $
   ptUnboundEnergy = $

   % Poison info
   ptPoison = $
   piPoisonStrength = 0

   % List of objects adding overlays to us.
   plOverlays = $

   % List of objects with window overlays.
   plWindow_overlays = $

   % Object that set our icon (usually armor)
   poIcon_set = $

   % Object that ditched our hair (usually helmets)
   poHair_remove = $

   % object that set our legs (usually pants)
   poLegs_set = $
   poArms_set = $

   % Object that sets our entire look (overrides any part changes)
   poIllusion_set = $

   piBody_translations = 0
   piBody_translations2 = 0

   % Default: green shirt, brown pants.
   piDefault_Clothes = 143 | (121 * PANTS_MUL)

   % Light source at player.
   % Default strength of light source at player is 5
   piLight = 5

   % Attack modifiers to attack roll & damage (includes items & spells)
   plAttack_modifiers = $

   % Defense modifiers to defense roll & damage (includes items & spells)
   plDefense_modifiers = $

   % Gear preferences for 'set' and 'loadout'
   plLoadout_list = $

   piGender = GENDER_MALE

   piVigor_rest_threshold = 80

   % The user's string description, typed when created (and editable in game).
   psPlayerDescription = $

   % graphics stuff

   prLegs = player_legs_a_rsc
   prRight_arm = player_rightarm_a_rsc
   prLeft_arm = player_leftarm_a_rsc

   prHead = charinfo_head_ax_icon
   prEyes = charinfo_eyes_ax_icon
   prMouth = charinfo_nose_ax_icon
   prNose = charinfo_mouth_ax_icon
   prToupee = charinfo_hair_cd_icon

   % Animation type.  If none, then use piAction
   % piAnimation should be PANM_NONE in between KOD calls.
   piAnimation = PANM_NONE 

   % Action, such as "smiling", that player is currently doing
   piAction = 1

   % piNodeList is a bitvector of all of the mana nodes that the player has
   %  successfully melded with.  List of available nodelists in the
   %  blakston.khd constants file.
   piNodeList = 0

   piBorn_year = 0

   % Faction stuff.
   piFactionEffect = 0
   piFaction = FACTION_NEUTRAL
   piFactionServiceUpdate = 0
   piFactionTimeUpdated = 0
   ptFactionTimer = $

   piKill_count = 0
   piKill_count_decay = 0
   piJustified_kill_count = 0

   ptAttackTimer = $

   plHonor = $

   piMonsterChasers = 0

   piView = $

   poBondedItem = $
   ptBondedItemReport = $

   piLastDeathTime = 0

   % Temp safe timer for giving players a period of safety after a death
   ptTempSafe = $
   
   % This keeps the duration of our Second Wind skill's "downtime"
   ptSecondWind = $

   % This keeps the duration of our Zealous Fervor skill's downtime
   ptZealousFervor = $

   % Measures how long we have to wait before we're rescued.
   ptRescue = $

   % piTimeAttackedPlayer records the last time we attacked a player.
   %  This is used in conjunction with the constant ATTACKED_PLAYER_WAIT
   %  to disallow casting by angeled "mules".
   piTimeAttackedPlayer = 0 

   % piTimeAttackedByPlayer records the last time we were attacked by a player.
   piTimeAttackedByPlayer = 0
   
   % records the last time we were hit
   piTimeLastHitByBattler = 0
   
   % piDeathcost is used to tell the underworld what percent of normal
   %  penalties to apply when the players leaves.  FALSE means no penalties.
   piDeathCost = 100

   % List of integer years in which the player has donated money to the game.
   % Used to construct a string for their description.
   plDonationYears = $

   % Some spells let players choose teleport destinations by binding a location.
   piBound_Room = $
   piBound_row = 0
   piBound_col = 0
   piBound_fine_row = 0
   piBound_fine_col = 0
   piBound_angle = ANGLE_SOUTH

   % Is the player currently using a Death Rift spell?
   ptDeathRiftTimer = $

   % This list keeps track of selfcast buffs for passive improvement.
   % Passive improvement will also check reserved buffs, but at a lower imp rate.
   plPassiveImprovement = $

   % Crystalize Mana Surge data
   ptCrystalizeManaSurgeTimer = $
   piCrystalizeManaSurging = FALSE

   % Players will naturally fall out of groups if they aren't getting kills
   ptLeaveBuilderGroupTimer = $

   % Player's corpse tracking
   plCorpses = $

   % Time remaining phased out
   ptPhaseTimer = $
   ptPhaseVisualEffectTimer = $
   piRemainingPhaseTime = 60000 * 8
   ptCanPhaseTimer = $

   piPlayerRace = RACE_HUMAN
   piRacialMightMod = 0
   piRacialIntellectMod = 0
   piRacialStaminaMod= 0
   piRacialAgilityMod = 0
   piRacialMysticismMod = 0
   piRacialAimMod = 0
   piRacialVigorMod = 0
   
   % Tracks the number of this character's reincarnations
   % New system: this is the number of extra stat points
   piReincarnations = 0
   % Do we have a free stat reset for reincarnation?
   pbReincarnationStatsReset = FALSE
   % Let's not spam newbies with this until they have a clue what it is.
   pbInformReincarnationProgress = FALSE

   % Banditry stance object
   poStance = $

   % Spells reserved on mana. Format [spell, mana reserved, state, spellpower]
   plReservedSpells = $
   % Songs reserved on mana. Format [song, mana reserved]
   % We keep less info because radius enchants do their effects elsewhere.
   plReservedSongs = $
   piBaseMax_mana = 0

   % Has the player opted out of PvP?
   pbOptOutPvP = FALSE

   % Timer for refreshing phase time if players have been logged on for 5 minutes
   ptLoggedOnRefreshPhaseTimer = $

   % Which elemental prisms have we defeated in Biskalane?
   % [Lightning, Ice, Acid, Fire, Death, Life]
   plPrismsDefeated = $

   % Is player a sorcerer?
   pbTattooed = FALSE
   
   % If this is TRUE, player cannot improve spellcasts.
   pbUsedBloodMagic = FALSE
   
   % Which skill has this player mastered?
   piMasteredSkill = 0
   piMasteredSpell = 0

   % Some races have custom heads. We save our info here in that case.
   prSaveEyes = $
   prSaveNose = $
   prSaveMouth = $
   
   % What was our human skin color on creation?
   piOriginalSkinColor = PT_BLUE_TO_SKIN1
   
   % What's our total knowledge over all reincarnations?
   piAccumulatedWisdom = -1
   
   plDelayedAdditionalAttacks = $
   
   % Is this attack a leap attack? Knock back enemies on hit.
   pbLeapKnockback = FALSE

   % Data used by the skill Unstable Infusion (charged clutch stance) to never choose the same element in a row
   piLastUnstableInfusionChoice = ATCK_SPELL_FIRE

   % Does this player have a statue?
   piRenowned = FALSE
   
   % Underwater or areas with no air
   ptBreathTimer = $
   piBreathTime = 1000
   piBreathRemaining = 60000
   piNaturalBreathTime = 60000

   % Is the person engaged in backup stat changing?
   pbClearedStatsRecently = FALSE
   
   % Do marauders hate this person?
   pbMarauderAntagonist = FALSE
   
   % What ladder was this player in? And what rank?
   piParticipatedInLadderNumber = 0
   piFinalLadderRank = 0
   pbNotifyLadderEnded = TRUE
   
   % What challenges has this player completed?
   plLadderChallengeData = $
   piLadderNumChallengesCompleted = 0
   
   % [Elemental Imbalance on/off],
   % [Desecration on/off],
   % [Sanctification on/off]
   plSkillConfig = $
   
   piLastAutomaticCommandMinionAttackTime = 0

messages:

   Constructor()
   {
      % Let the poor bastards eat something.
      piTimeLastStomachUpdate = GetTime();
      piReward_timestamp = GetTime();

      Send(self,@ClearPrismsDefeated);
      
      % Don't confuse newbies with reincarnation progress.
      % A quest chain is required before this becomes relevant.
      pbInformReincarnationProgress = FALSE;

      plCreatureTypes = Cons(CREATURE_TYPE_HUMANOID,plCreatureTypes);
      plCreatureTypes = Cons(CREATURE_TYPE_INTELLIGENT,plCreatureTypes);

      propagate;
   }

   Delete()
   {
      local i;

      Send(self,@QuitGuild);
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }
      
      Send(self,@ClearDelayedAdditionalAttacks);

      if ptBreathTimer <> $
      {
         DeleteTimer(ptBreathTimer);
         ptBreathTimer = $;
      }

      if ptRest <> $
      {
         DeleteTimer(ptRest);
         ptRest = $;
      }

      if ptFortitude <> $
      {
         DeleteTimer(ptFortitude);
         ptFortitude = $;
      }

      if ptUnboundEnergy <> $
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }

      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth = $;
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptPoison <> $
      {
         DeleteTimer(ptPoison);
         ptPoison = $;
      }

      if ptAdvancement <> $
      {
         DeleteTimer(ptAdvancement);
         ptAdvancement = $;
      }

      if ptZealousFervor <> $
      {
         DeleteTimer(ptZealousFervor);
         ptZealousFervor = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
               #num=SKID_ZEALOUS_FERVOR),#type=ENCHANTMENT_PLAYER);
      }

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
               #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }

      if ptTempSafe <> $
      {
         DeleteTimer(ptTempSafe);
         ptTempSafe = $;
      }

      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
               #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
         piCrystalizeManaSurging = FALSE;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      Send(self,@CancelRescue);

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      Send(self,@RemoveAllEnchantments,#report=FALSE);

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      Send(self,@ClearStance);
      Send(self,@ClearElementalImbalance);

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp = self);
      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);

      Send(Send(SYS,@GetAssassinGame),@RemoveFromGame,#who=self);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);
      plSchools = $;

      propagate;
   }

   Reincarnate(race=0)
   {
      Send(SYS,@UserReincarnated,#what=self);
      Send(self,@ReincarnateCharacter);
      Send(self,@SetPlayerRace,#race=race);
      
      if piMight > Send(self,@GetMaxMight)
      {
         piMight = Send(self,@GetMaxMight);
      }
      
      if piIntellect > Send(self,@GetMaxIntellect)
      {
         piIntellect = Send(self,@GetMaxIntellect);
      }
      
      if piStamina > Send(self,@GetMaxStamina)
      {
         piStamina = Send(self,@GetMaxStamina);
      }
      
      if piAgility > Send(self,@GetMaxAgility)
      {
         piAgility = Send(self,@GetMaxAgility);
      }
      
      if piMysticism > Send(self,@GetMaxMysticism)
      {
         piMysticism = Send(self,@GetMaxMysticism);
      }
      
      if piAim > Send(self,@GetMaxAim)
      {
         piAim = Send(self,@GetMaxAim);
      }
      
      % No longer increment reincarnations
      %++piReincarnations;

      Send(self,@SetReincarnationStatsReset,#value=TRUE);
      Post(self,@SendStatChange);

      return;
   }

   CanReincarnate()
   {
      % New system, can reincarnate any time
      return TRUE;

      if Send(self,@GetReincarnationSum) >= Send(self,@GetNextReincarnationSum)
         AND piReincarnations < 10
      {
         return TRUE;
      }

      return FALSE;
   }

   ReportReincarnationProgress()
   {
      local iReincarnationSum;
      
      % New system, can reincarnate any time
      return;

      if Send(self,@IsLoggedOn)
         AND Send(SETTINGS_OBJECT,@GetReincarnationEnabled)
         AND piReincarnations < 10
         AND pbInformReincarnationProgress
      {
         iReincarnationSum = Send(self,@GetReincarnationSum);
         if iReincarnationSum >= Send(self,@GetNextReincarnationSum)
         {
            Send(self,@MsgSendUser,#message_rsc=ready_to_reincarnate_msg);
            
            Send(Send(SYS,@GetGameQuestMaintenance),@EvaluatePlayer,#who=self,#vbTriggered=TRUE);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=reincarnation_progress_msg,#parm1=(iReincarnationSum*100)/Send(self,@GetNextReincarnationSum));
         }
      }
      return;
   }

   GetAccumulatedWisdom()
   {
      return piAccumulatedWisdom;
   }

   ReportAccumulatedWisdom()
   {
      if piAccumulatedWisdom < ACCUMULATED_WISDOM_TO_TRAINING_POINTS_CAP
      {
         Send(self,@MsgSendUser,#message_rsc=report_acc_wisdom_training_points_less_cap_msg,#parm1=piAccumulatedWisdom);
         if piBase_Max_Health >= 80
         {
            Send(self,@MsgSendUser,#message_rsc=report_acc_wisdom_bonus,#parm1=Bound((piBase_Max_Health-75)/5,0,25));
         }
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=report_acc_wisdom_training_points_at_cap_msg,#parm1=piAccumulatedWisdom);
      }
      return;
   }

   UpdateAccumulatedWisdom()
   {
      % Intended to happen one time only for existing characters
      Send(self,@AddAccumulatedWisdom,#amount=Send(self,@GetReincarnationAccumulatedWisdomExisting) + piTraining_points);
      Send(self,@ReportAccumulatedWisdom);
      return;
   }

   AddAccumulatedWisdom(amount=0)
   {
      local bHumanDoubler,bAutomatonZeroer;
      
      if piAccumulatedWisdom = MAX_SUPER_SAFE_INT
      {
         return;
      }

      if piAccumulatedWisdom + amount >= MAX_SUPER_SAFE_INT
      {
         piAccumulatedWisdom = MAX_SUPER_SAFE_INT;
         Send(self,@MsgSendUser,#message_rsc=max_accumulated_wisdom_achieved);
         piReincarnations = 20;
         return;
      }
      else
      {
         piAccumulatedWisdom = piAccumulatedWisdom + amount;
         
         if piAccumulatedWisdom < -1000000
         {
            piAccumulatedWisdom = MAX_SUPER_SAFE_INT;
            piReincarnations = 20;
         }
         Post(self,@DrawAccumulatedWisdom);
      }
      
      if piPlayerRace = RACE_HUMAN
      {
         bHumanDoubler = 2;
      }
      else
      {
         bHumanDoubler = 1;
      }
      
      if piPlayerRace = RACE_AUTOMATON
      {
         bAutomatonZeroer = 0;
      }
      else
      {
         bAutomatonZeroer = 1;
      }

      if piReincarnations = 0
         AND piAccumulatedWisdom >= 10000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 1
         AND piAccumulatedWisdom >= 20000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 2
         AND piAccumulatedWisdom >= 30000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 3
         AND piAccumulatedWisdom >= 45000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 4
         AND piAccumulatedWisdom >= 80000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 5
         AND piAccumulatedWisdom >= 120000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 6
         AND piAccumulatedWisdom >= 165000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 7
         AND piAccumulatedWisdom >= 205000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 8
         AND piAccumulatedWisdom >= 260000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 9
         AND piAccumulatedWisdom >= 320000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment_ten_points,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 10
         AND piAccumulatedWisdom >= 1000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 11
         AND piAccumulatedWisdom >= 4000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 12
         AND piAccumulatedWisdom >= 8000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 13
         AND piAccumulatedWisdom >= 13000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 14
         AND piAccumulatedWisdom >= 19000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 15
         AND piAccumulatedWisdom >= 26000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 16
         AND piAccumulatedWisdom >= 40000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 17
         AND piAccumulatedWisdom >= 60000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      if piReincarnations = 18
         AND piAccumulatedWisdom >= 90000000
      {
         piReincarnations++;
         Send(self,@MsgSendUser,#message_rsc=attained_enlightenment,#parm1=piReincarnations*bHumanDoubler*bAutomatonZeroer);
      }
      return;
   }

   SubtractAccumulatedWisdom(amount=0)
   {
      if piAccumulatedWisdom - amount <= 0
      {
         piAccumulatedWisdom = 0;
      }
      else
      {
         piAccumulatedWisdom = piAccumulatedWisdom - amount;
      }
      return;
   }

   GetReincarnationAccumulatedWisdomExisting()
   {
      local i, iSum, oAbility;
      
      iSum = 0;
      
      % This uses different calculations than AW normally does.
      % This is for conversion from old reincarnation system to new.
      % This will give existing characters large AW pools.
      
      foreach i in plSkills
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSum = iSum + (Send(self,@DecodeSkillAbility,#compound=i)*Send(oAbility,@GetMeditateRatio));
      }

      foreach i in plSpells
      {
         oAbility = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=i));
         iSum = iSum + (Send(self,@DecodeSpellAbility,#compound=i)*Send(oAbility,@GetMeditateRatio));
      }

      return iSum;
   }

   GetReincarnationSum()
   {
      local iLearnPoints, iBaseMaxHealthPoints;

      % New equation combines level points and hit points.
      % vlLevelPoints = [1,2,4,6,8,10];
      %
      %

      % Learn points ranges from 16 at 5/5 at 1 int to 40 at 6/6/6/6 at 60 int
      iLearnPoints = Send(self,@GetTotalLearnPoints)*4;

      % Hit points can max out at 130 for Demon, up to 160 for Orc, so 130-160
      iBaseMaxHealthPoints = Send(self,@GetBaseMaxHealth);

      % Let's apply quadruple multiplier to schools.
      % 5/5 = 64, 6/6/6/6 = 160
      % 130 + 160 = 290 most demon can attain
      % 160 + 144 = 304 most orc can attain
      % 150 + 112 = 262 most elf can attain
      % 170 + 80  = 250 most draconian can attain - Draconians cannot reach 260 pts for r10!

      return iBaseMaxHealthPoints + iLearnPoints;
   }

   GetNextReincarnationSum()
   {
      % 71  1   - 21 scale   - 50 hp level 3
      % 92  2
      % 113 3
      % 134 4
      % 155 5
      % 176 6
      % 197 7
      % 218 8
      % 239 9
      % 260 10  - 260 represents 130 HP + 33 learn points or 6/6/6/3 (30 stam + 45 int)
      %                          150 HP + 28 learn points or 6/6/5   (50 stam + 30 int)
      %                          160 HP + 25 learn points or 6/6/4   (60 stam + 25 int)

      % 74 1    - 24 scale
      % 98 2
      % 122 3
      % 146 4
      % 170 5
      % 194 6
      % 218 7
      % 242 8
      % 266 9
      % 290 for reincarnation ten

      return Send(SETTINGS_OBJECT,@GetReincarnationSumBase)+((piReincarnations+1)*Send(SETTINGS_OBJECT,@GetReincarnationSumMultiple));
   }

   HasReincarnationStatsReset()
   {
      return pbReincarnationStatsReset;
   }
   
   SetReincarnationStatsReset(value=FALSE)
   {
      pbReincarnationStatsReset = value;
      return;
   }

   GetNumReincarnations()
   {
      return piReincarnations;
   }

   GetBaseEmpowerments()
   {
      local lBaseEmpowerments, i;

      switch(piPlayerRace)
      {
         case RACE_HALF_ORC:
            lBaseEmpowerments = Cons([ATCK_WEAP_SLASH, 15],lBaseEmpowerments);
            break;
         case RACE_HALF_DEMON:
            lBaseEmpowerments = Cons([-ATCK_SPELL_ACID, 15],lBaseEmpowerments);
            break;
         case RACE_HALF_ELF:
            lBaseEmpowerments = Cons([ATCK_WEAP_MAGIC, 20],lBaseEmpowerments);
            break;
         case RACE_HALF_UNDINE:
            lBaseEmpowerments = Cons([-ATCK_SPELL_COLD, 15],lBaseEmpowerments);
            break;
         case RACE_DRACONIAN:
            lBaseEmpowerments = Cons([ATCK_WEAP_PUNCH, 15],lBaseEmpowerments);
            break;
         case RACE_DROW:
            lBaseEmpowerments = Cons([-ATCK_SPELL_UNHOLY, 15],lBaseEmpowerments);
            lBaseEmpowerments = Cons([-ATCK_SPELL_HOLY,-300],lBaseEmpowerments);
         case RACE_GNOME:
            lBaseEmpowerments = Cons([ATCK_WEAP_NERUDITE, 20],lBaseEmpowerments);
            break;
         case RACE_AUTOMATON:
            lBaseEmpowerments = $;
            break;
      }

      if Nth(plPrismsDefeated,NTH_LIGHTNING_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_SHOCK,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      if Nth(plPrismsDefeated,NTH_ICE_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_COLD,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      if Nth(plPrismsDefeated,NTH_ACID_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_ACID,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      if Nth(plPrismsDefeated,NTH_FIRE_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_FIRE,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      if Nth(plPrismsDefeated,NTH_DEATH_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_UNHOLY,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      if Nth(plPrismsDefeated,NTH_LIFE_PRISM) = 1
      {
         lBaseEmpowerments = Send(SYS,@AddEmpowerment,#empowerment_list=lBaseEmpowerments,
                                                      #what=-ATCK_SPELL_HOLY,
                                                      #value=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
      }

      return lBaseEmpowerments;
   }

   GetRacialHexResistance(race=$)
   {
      if race = $
      {
         % Use our own race.
         race = piPlayerRace;
      }

      switch(race)
      {
         case RACE_HUMAN:
            return 66;
         case RACE_HALF_DEMON:
            return 33;
         case RACE_DROW:
            return -33;
         case RACE_AUTOMATON:
            return -66;
      }

      return 0;
   }

   GetRacialBaseResistances(race=$)
   {
      if race = $
      {
         % Use our own race.
         race = piPlayerRace;
      }
      
      if race = RACE_HALF_ORC
      {
         return [ [-ATCK_SPELL_UNHOLY, 20 ],
                  [-ATCK_SPELL_HOLY, -15 ],
                  [ATCK_WEAP_PIERCE, 10 ],
                  [ATCK_WEAP_SLASH, 10 ] ];
      }
      
      if race = RACE_HALF_DEMON
      {
         return [ [-ATCK_SPELL_FIRE, 20 ],
                  [-ATCK_SPELL_COLD, -25 ],
                  [-ATCK_SPELL_ACID, 10],
                  [ATCK_WEAP_NERUDITE, 10 ]];
      }
      
      if race = RACE_HALF_ELF
      {
         return [ [-ATCK_SPELL_UNHOLY, -15 ],
                  [-ATCK_SPELL_HOLY, 20 ],
                  [-ATCK_SPELL_ALL, 10 ],
                  [ATCK_WEAP_MAGIC, 10 ] ];
      }
      
      if race = RACE_HALF_UNDINE
      {
         return [ [-ATCK_SPELL_COLD, 10 ],
                  [-ATCK_SPELL_SHOCK, -25 ],
                  [ATCK_WEAP_BLUDGEON, 10 ] ];
      }
      
      if race = RACE_DRACONIAN
      {
         return [ [ATCK_WEAP_SLASH, 10],
                  [ATCK_WEAP_PIERCE, 5],
                  [ATCK_WEAP_THRUST, 5],
                  [-ATCK_SPELL_ACID, 20],
                  [ATCK_WEAP_BLUDGEON, -10]];
      }
      
      if race = RACE_DROW
      {
         return [ [-ATCK_SPELL_COLD, 10],
                  [ATCK_WEAP_PIERCE, 10],
                  [-ATCK_SPELL_ACID, -25]];
      }
      
      if race = RACE_GNOME
      {
         return [ [ATCK_WEAP_CLAW, 10],
                  [ATCK_WEAP_WHIP, 10],
                  [ATCK_WEAP_BITE, 10],
                  [ATCK_WEAP_STING, 10],
                  [-ATCK_SPELL_FIRE, -25]];
      }

      if race = RACE_AUTOMATON
      {
         return [ [-ATCK_SPELL_FIRE, -40 + piReincarnations],
                  [-ATCK_SPELL_COLD, -40 + piReincarnations],
                  [-ATCK_SPELL_ACID, -40 + piReincarnations],
                  [-ATCK_SPELL_SHOCK, -40 + piReincarnations],
                  [ATCK_WEAP_THRUST, 20 + piReincarnations],
                  [ATCK_WEAP_SLASH, 20 + piReincarnations],
                  [ATCK_WEAP_BLUDGEON, 20 + piReincarnations],
                  [ATCK_WEAP_PIERCE, 20 + piReincarnations]];
      }
      
      return $;
   }

   GetRacialMaxResistanceMod(type=-ATCK_SPELL_FIRE)
   {
      if piPlayerRace = RACE_HALF_ORC
      {
         switch(type)
         {
            case -ATCK_SPELL_UNHOLY:
               return 5;
            case -ATCK_SPELL_HOLY:
               return -5;
            case ATCK_WEAP_PIERCE:
               return 2;
            case ATCK_WEAP_SLASH:
               return 2;
         }
      }
      if piPlayerRace = RACE_HALF_DEMON
      {
         switch(type)
         {
            case -ATCK_SPELL_FIRE:
               return 5;
            case -ATCK_SPELL_ACID:
               return 2;
            case ATCK_WEAP_NERUDITE:
               return 2;
            case -ATCK_SPELL_COLD:
               return -7;
         }
      }
      if piPlayerRace = RACE_HALF_ELF
      {
         switch(type)
         {
            case -ATCK_SPELL_UNHOLY:
               return -5;
            case -ATCK_SPELL_HOLY:
               return 5;
            case -ATCK_SPELL_ALL:
               return 2;
            case ATCK_WEAP_MAGIC:
               return 2;
         }
      }
      if piPlayerRace = RACE_HALF_UNDINE
      {
         switch(type)
         {
            case -ATCK_SPELL_SHOCK:
               return -7;
            case -ATCK_SPELL_COLD:
               return 2;
            case ATCK_WEAP_BLUDGEON:
               return 2;
         }
      }
      if piPlayerRace = RACE_DRACONIAN
      {
         switch(type)
         {
            case ATCK_WEAP_BLUDGEON:
               return -7;
            case ATCK_WEAP_SLASH:
               return 2;
            case ATCK_WEAP_PIERCE:
               return 1;
            case ATCK_WEAP_THRUST:
               return 1;
            case -ATCK_SPELL_ACID:
               return 5;
         }
      }
      if piPlayerRace = RACE_DROW
      {
         switch(type)
         {
            case -ATCK_SPELL_ACID:
               return -7;
            case -ATCK_SPELL_COLD:
               return 2;
            case ATCK_WEAP_PIERCE:
               return 2;
         }
      }
      if piPlayerRace = RACE_GNOME
      {
         switch(type)
         {
            case -ATCK_SPELL_FIRE:
               return -7;
            case ATCK_WEAP_CLAW:
               return 2;
            case ATCK_WEAP_WHIP:
               return 2;
            case ATCK_WEAP_BITE:
               return 2;
            case ATCK_WEAP_STING:
               return 2;
         }
      }
      if piPlayerRace = RACE_AUTOMATON
      {
         switch(type)
         {
            case -ATCK_SPELL_FIRE:
               return -15;
            case -ATCK_SPELL_COLD:
               return -15;
            case -ATCK_SPELL_SHOCK:
               return -15;
            case -ATCK_SPELL_ACID:
               return -15;
            case ATCK_WEAP_THRUST:
               return 2;
            case ATCK_WEAP_SLASH:
               return 2;
            case ATCK_WEAP_PIERCE:
               return 2;
            case ATCK_WEAP_BLUDGEON:
               return 2;
         }
      }
      return 0;
   }

   GetMaxResistanceMod(type=-ATCK_SPELL_FIRE)
   {
      local iSum;

      iSum = Send(self,@GetRacialMaxResistanceMod,#type=type);

      if type = -ATCK_SPELL_SHOCK
         AND Nth(plPrismsDefeated,NTH_LIGHTNING_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      if type = -ATCK_SPELL_COLD
         AND Nth(plPrismsDefeated,NTH_ICE_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      if type = -ATCK_SPELL_ACID
         AND Nth(plPrismsDefeated,NTH_ACID_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      if type = -ATCK_SPELL_FIRE
         AND Nth(plPrismsDefeated,NTH_FIRE_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      if type = -ATCK_SPELL_UNHOLY
         AND Nth(plPrismsDefeated,NTH_DEATH_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      if type = -ATCK_SPELL_HOLY
         AND Nth(plPrismsDefeated,NTH_LIFE_PRISM) = 1
      {
         iSum = iSum + Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward);
      }

      return iSum;
   }

   SetPlayerRace(race=0)
   {
      if piPlayerRace = RACE_DRACONIAN
         and race <> RACE_DRACONIAN
      {
         Send(self,@RemoveDraconianHead);
      }
      
      if race = RACE_HUMAN
      {
         Send(self,@SetSkinTranslation,#translation=piOriginalSkinColor);
         Send(self,@SetDefaultClothes,#shirt_color=Bound(piOriginalSkinColor-1,1,$),#pants_color=Bound(piOriginalSkinColor-1,1,$));
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_HUMAN);

         piRacialMightMod = 0;
         piRacialIntellectMod = 0;
         piRacialStaminaMod = 0;
         piRacialAgilityMod = 0;
         piRacialMysticismMod = 0;
         piRacialAimMod = 0;

         piNaturalBreathTime = 60000;

         piRacialVigorMod = 0;
         piStomachMax = 100;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }

      if race = RACE_HALF_ORC
      {
         Send(self,@SetSkinTranslation,#translation=140);
         Send(self,@SetDefaultClothes,#shirt_color=5,#pants_color=5);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_HALF_ORC);

         piRacialMightMod = 10;
         piRacialIntellectMod = 0;
         piRacialStaminaMod = 10;
         piRacialAgilityMod = -20;
         piRacialMysticismMod = 0;
         piRacialAimMod = -20;

         piNaturalBreathTime = 90000;

         piRacialVigorMod = 40;
         piStomachMax = 120;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }

      if race = RACE_HALF_DEMON
      {
         Send(self,@SetSkinTranslation,#translation=135);
         Send(self,@SetDefaultClothes,#shirt_color=0,#pants_color=0);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_HALF_DEMON);

         piRacialMightMod = -20;
         piRacialIntellectMod = 10;
         piRacialStaminaMod = -20;
         piRacialAgilityMod = 0;
         piRacialMysticismMod = 10;
         piRacialAimMod = 0;

         piNaturalBreathTime = 30000;

         piRacialVigorMod = -20;
         piStomachMax = 60;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_HALF_ELF
      {
         Send(self,@SetSkinTranslation,#translation=145);
         Send(self,@SetDefaultClothes,#shirt_color=10,#pants_color=10);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_HALF_ELF);

         piRacialMightMod = 0;
         piRacialIntellectMod = -20;
         piRacialStaminaMod = 0;
         piRacialAgilityMod = 10;
         piRacialMysticismMod = -20;
         piRacialAimMod = 10;

         piNaturalBreathTime = 60000;

         piRacialVigorMod = 20;
         piStomachMax = 80;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_DROW
      {
         Send(self,@SetSkinTranslation,#translation=142);
         Send(self,@SetDefaultClothes,#shirt_color=7,#pants_color=7);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_DROW);

         piRacialMightMod = 0;
         piRacialIntellectMod = 20;
         piRacialStaminaMod = 0;
         piRacialAgilityMod = 0;
         piRacialMysticismMod = -40;
         piRacialAimMod = 0;

         piNaturalBreathTime = 90000;

         piRacialVigorMod = 0;
         piStomachMax = 80;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_HALF_UNDINE
      {
         Send(self,@SetSkinTranslation,#translation=11);
         Send(self,@SetDefaultClothes,#shirt_color=6,#pants_color=6);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_HALF_UNDINE);

         piRacialMightMod = 0;
         piRacialIntellectMod = 10;
         piRacialStaminaMod = 0;
         piRacialAgilityMod = 10;
         piRacialMysticismMod = -20;
         piRacialAimMod = -20;

         piNaturalBreathTime = 240000;

         piRacialVigorMod = 0;
         piStomachMax = 100;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_GNOME
      {
         Send(self,@SetSkinTranslation,#translation=139);
         Send(self,@SetDefaultClothes,#shirt_color=4,#pants_color=4);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_GNOME);

         piRacialMightMod = 0;
         piRacialIntellectMod = 5;
         piRacialStaminaMod = -40;
         piRacialAgilityMod = -10;
         piRacialMysticismMod = 0;
         piRacialAimMod = 20;

         piNaturalBreathTime = 30000;

         piRacialVigorMod = -40;
         piStomachMax = 60;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_DRACONIAN
      {
         Send(self,@SetSkinTranslation,#translation=1);
         Send(self,@SetDefaultClothes,#shirt_color=1,#pants_color=1);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_DRACONIAN);
         
         if piPlayerRace <> RACE_DRACONIAN
         {
            Send(self,@ApplyDraconianHead);
         }

         piRacialMightMod = 0;
         piRacialIntellectMod = -20;
         piRacialStaminaMod = 20;
         piRacialAgilityMod = -20;
         piRacialMysticismMod = 0;
         piRacialAimMod = 0;

         piNaturalBreathTime = 120000;

         piRacialVigorMod = 70;
         piStomachMax = 140;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
     
      if race = RACE_AUTOMATON
      {
         Send(self,@SetSkinTranslation,#translation=PT_BLUE_TO_GRAY);
         Send(self,@SetDefaultClothes,#shirt_color=XLAT_TO_GRAY,#pants_color=XLAT_TO_GRAY);
         plResistances = Send(self,@GetRacialBaseResistances,#race=RACE_AUTOMATON);

         piRacialMightMod = 50;
         piRacialIntellectMod = 0;
         piRacialStaminaMod = 50;
         piRacialAgilityMod = 50;
         piRacialMysticismMod = 0;
         piRacialAimMod = 50;

         piNaturalBreathTime = 120000;

         piRacialVigorMod = 50;
         piStomachMax = 1;
         piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);
         piVigor = piVigor_rest_threshold;
         Post(self,@NewVigor);

         piPlayerRace = race;
      }
      
      Post(self,@RecalcLight);

      Post(self,@DrawResistances);
     
      return;
   }

   ApplyDraconianHead()
   {
      % Save face info.
      prSaveEyes = Send(self,@GetEyesRsc);
      prSaveNose = Send(self,@GetNoseRsc);
      prSaveMouth = Send(self,@GetMouthRsc);

      % Make all the face overlays invis, and remove hair.
      Send(self,@SetEyes,#eyes=admin_icon_blank);
      Send(self,@SetNose,#nose=admin_icon_blank);
      Send(self,@SetMouth,#mouth=admin_icon_blank);      
      Send(self,@RemoveHair,#what=self);

      if Send(self,@GetGender) = GENDER_FEMALE
      {
         Send(self,@SetHead,#head=vrFemaleDraconianHeadIcon);
      }

      if Send(self,@GetGender) = GENDER_MALE
      {
         Send(self,@SetHead,#head=vrMaleDraconianHeadIcon);
      }
      
      return;
   }

   RaceCanUseItemType(type=ITEM_USE_HEAD)
   {
      if piPlayerRace = RACE_DRACONIAN
         AND (type & ITEM_USE_HEAD)
      {
         return FALSE;
      }
      return TRUE;
   }
   
   RemoveDraconianHead()
   {
      % Put the face back on.
      Send(self,@SetEyes,#eyes=prSaveEyes);
      Send(self,@SetNose,#nose=prSaveNose);
      Send(self,@SetMouth,#mouth=prSaveMouth);
      Send(self,@ResetHair);

      % Clear out face resources.
      prSaveEyes = $;
      prSaveNose = $;
      prSaveMouth = $;

      if Send(self,@GetGender) = GENDER_FEMALE
      {
         Send(self,@SetHead,#head=charinfo_head_kx_icon);
      }

      if Send(self,@GetGender) = GENDER_MALE
      {
         Send(self,@SetHead,#head=charinfo_head_ax_icon);
      }

      return;
   }

   GetPurgeResistance(caster=$)
   {
      if Send(self,@HasSkill,#num=SKID_PIETY)
      {
         return Send(Send(SYS,@FindSkillByNum,#num=SKID_PIETY),@GetPurgeResistance,#who=self,#caster=caster);
      }
      return 0;
   }

   GetBlindResistance()
   {
      local i, sum;
      
      sum = 0;
      foreach i in plRadiusEnchantments
      {
         sum = Send(First(i),@AddBlindResistance,#power=Nth(i,2),#resistance=sum);
      }

      if piPlayerRace = RACE_GNOME
      {
         sum = sum + 20;
      }

      return sum;
   }

   GetHoldResistance()
   {
      if piPlayerRace = RACE_HALF_UNDINE
      {
         return 20;
      }
      return 0;
   }

   GetPlayerRace()
   {
      return piPlayerRace;
   }

   GetTotalRawStatPoints()
   {
      % Players get one more stat point per reincarnation.
      
      % Humans get two per reincarnation.
      if piPlayerRace = RACE_HUMAN
      {
         return 200 + piReincarnations*2;
      }
      
      % Automatons get no extra points.
      if piPlayerRace = RACE_AUTOMATON
      {
         return 200;
      }
      
      return 200 + piReincarnations;
   }

   GetBaseResistances()
   {
      local lResistances, i;
      
      lResistances = ListCopy(plResistances);

      lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_ILLUSION,#value=Send(self,@GetIntellect)/2);
      lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_ILLUSION,#value=Send(self,@GetSkillAbility,#Skill_num=SKID_HONESTY)/3);

      foreach i in plRadiusEnchantments
      {
         lResistances = Send(First(i),@ModifyResistances,#resistance_list=lResistances,#lRadiusState=i);
      }

      if Nth(plPrismsDefeated,NTH_LIGHTNING_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_SHOCK,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      if Nth(plPrismsDefeated,NTH_ICE_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_COLD,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      if Nth(plPrismsDefeated,NTH_ACID_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_ACID,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      if Nth(plPrismsDefeated,NTH_FIRE_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_FIRE,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      if Nth(plPrismsDefeated,NTH_DEATH_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_UNHOLY,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      if Nth(plPrismsDefeated,NTH_LIFE_PRISM) = 1
      {
         lResistances = Send(SYS,@AddResistance,#resistance_list=lResistances,#what=-ATCK_SPELL_HOLY,#value=Send(SETTINGS_OBJECT,@GetPrismResistanceReward));
      }

      return lResistances;
   }
   
   CalculateVigorThreshold()
   {
      local i, iItemVigorBonus;

      iItemVigorBonus = 0;
      % Account for any items that may affect max vigor
      foreach i in plUsing
      {
         if Send(i,@AdjustsMaxVigor)
         {
            iItemVigorBonus = iItemVigorBonus + Send(i,@GetVigorChange);
         }
      }

      return bound(80 + iItemVigorBonus
                      + piRacialVigorMod
                      + ((Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) + 1) / 5)
                      + ((Send(self,@GetSkillAbility,#Skill_num=SKID_SALABHASANA) + 1) / 5)
                      + 40 * Send(self,@HasMasteredThisSkill,#num=SKID_FORTITUDE),0,200);
   }

   %%% Player flags

   SetPlayerFlag(flag=0,value=FALSE,flagset=1)
   "This always requires the POSITIVE flag name."
   {
      local ccond;

      if flagset = 1 AND (flag & PFLAG_PKILL_ENABLE) AND value
      {
         if (piFlags & PFLAG_PKILL_ENABLE)
         {
            return;
         }
         else
         {
            ccond = player_safety_off_mail;
            if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
            {
               ccond = player_safety_on_mail;
            }

            if Send(SYS,@IsPKAllowed)
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                 #dest_list=[self],#nest_list=[4,player_ready_to_kill,4,ccond]);
            }
            else
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                 #dest_list=[self],#nest_list=[4,player_ready_to_guild,4,ccond]);
            }
         }
      }

      if flagset = 1
      {
         if NOT Value
         {
            piFlags = piFlags & ~flag;
         }
         else
         {
            piFlags = piFlags | flag;
         }
      }
      else if flagset = 2
      {
         if NOT Value
         {
            piFlags2 = piFlags2 & ~flag;
         }
         else
         {
            piFlags2 = piFlags2 | flag;
         }
      }
      else if flagset = 3
      {
         if NOT Value
         {
            piFlags3 = piFlags3 & ~flag;
         }
         else
         {
            piFlags3 = piFlags3 | flag;
         }
      }

      if (poOwner <> $)
         AND (flagset = 1)
         AND (flag & (PFLAG_MURDERER | PFLAG_OUTLAW | PFLAG_INVISIBLE))
      {
         % Tell room about change in case there are ramifications.
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if flag = PFLAG_MORPHED
      {
         Post(self,@DrawOffense);
      }

      if flag = PFLAG_NO_MOVE
         OR flag = PFLAG_NO_FIGHT
         OR flag = PFLAG_NO_MAGIC
         OR flag = PFLAG_MORPHED
      {
         Post(self,@DrawDefense);
      }

      return;
   }

   CheckPlayerFlag(flag=0,flagset=1)
   "This always checks to be sure that the flag exists."
   {
      if flagset = 1
      {
         return (piFlags & flag);
      }

      if flagset = 2
      {
         return (piFlags2 & flag);
      }

      if flagset = 3
      {
         return (piFlags3 & flag);
      }

      return FALSE;
   }

   % Player preference flags (e.g. safety, tempsafe etc.)
   SetPlayerPreference(flag = 0, value = 0)
   {
      if value
      {
         piPreferences = piPreferences | flag;
      }
      else
      {
         piPreferences = piPreferences & ~flag;
      }

      return;
   }

   CheckPlayerPreference(flag = 0)
   {
      if (flag = CF_SAFETY_OFF) AND NOT Send(SYS,@IsPKAllowed)
      {
         return FALSE;
      }

      return (piPreferences & flag);
   }

   % Added a nodraw paramater to this function to deal with buggy Jala
   % implementation. Can remove this and 3 instances of it used in 
   % player.kod when Jala fixed
   ResetPlayerFlagList(nodraw=FALSE)
   {
      local i;

      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=FALSE);

      piFlags = (piFlags & PFLAG_MASK);
      piFlags2 = (piFlags2 & PFLAG2_MASK);
      piFlags3 = (piFlags3 & PFLAG3_MASK);
      if Send(self,@IsResting)
      {
         piFlags = piFlags | PFLAG_NO_MOVE;
         piFlags = piFlags | PFLAG_NO_FIGHT;
         piFlags = piFlags | PFLAG_NO_MAGIC;
      }

      foreach i in plEnchantments
      {
         Send(Nth(i,2),@SetSpellPlayerFlag,#who=self);
      }

      foreach i in plReservedSpells
      {
         Send(Nth(i,1),@SetSpellPlayerFlag,#who=self);
      }

      foreach i in plUsing
      {
         Send(i,@SetItemPlayerFlag,#who=self);
      }

      if Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=self)
      {
         Send(self,@SetPlayerDrawFX,#drawfx=DRAWFX_DITHERGREY);
      }

      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetEnchantmentList)
         {
            Send(Nth(i,2),@SetSpellPlayerFlag,#who=self,#state=Nth(i,3));
         }
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if nodraw=FALSE
      {
         Post(self,@DrawOffense);
         Post(self,@DrawDefense);
      }

      return;
   }

   GetGameSecurityFlag(flag = 0)
   {
      return 0;
   }

   GetLastRestartTime()
   {
      return piLast_restart_time;
   }

   SetLastRestartTime(time = 0)
   {
      piLast_restart_time = time;

      return piLast_restart_time;
   }

   %%% Vigor

   NewVigor()
   "Ensures vigor stays in bounds.  Also checks for second wind skill. "
   "NOTE: Do not modify vigor below SECONDWIND_THRESHOLD if you do not "
   "want the skill to kick in. Vigor display will be driven from here."
   {
      if piVigor < SECONDWIND_THRESHOLD
         AND ptSecondWind = $
         AND pbLogged_on
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) > 0
         AND Send(Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND),
                  @DoSkill,#who=self)
      {
         Send(self,@StartSecondWind);
      }

      piVigor = bound(piVigor,1,viMax_vigor);
      Send(self,@DrawVigor);

      return;
   }

   StartZealousFervor()
   {
      local oFervor, iTime;

      if Send(self,@GetSkillAbility,#Skill_num=SKID_ZEALOUS_FERVOR) = 0
      {
         return FALSE;
      }

      oFervor = Send(SYS,@FindSkillByNum,#num=SKID_ZEALOUS_FERVOR);
      iTime = Send(oFervor,@GetWaitTime,#who=self);
      ptZealousFervor = CreateTimer(self,@EndZealousFervorTimer,iTime);
      
      return TRUE;
   }

   EndZealousFervorTimer()
   {
      ptZealousFervor = $;
      Send(self,@EndZealousFervor);

      return;
   }

   EndZealousFervor()
   {
      if ptZealousFervor <> $
      {
         DeleteTimer(ptZealousFervor);
         ptZealousFervor = $;
      }

      % This prevents repeated triggering of the zealous fervor skill.
      if piHealth < (ZEALOUS_FERVOR_THRESHOLD * (Send(self,@GetMaxHealth)*100))/100
      {
         piHealth = (ZEALOUS_FERVOR_THRESHOLD * (Send(self,@GetMaxHealth)*100))/100;
      }

      Send(self,@NewHealth);
      Send(self,@MsgSendUser,#message_rsc=zealous_fervor_finished);
      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
            #num=SKID_ZEALOUS_FERVOR),#type=ENCHANTMENT_PLAYER);

      return;
   }

   GetZealousFervorTimer()
   {
      return ptZealousFervor;
   }

   StartSecondWind()
   {
      local oWind, iTime;

      if Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) = 0
      {
         return FALSE;
      }

      oWind = Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND);
      iTime = Send(oWind,@GetWaitTime,#who=self);
      ptSecondWind = CreateTimer(self,@EndSecondWindTimer,iTime);
      Send(self,@SetVigorRestThreshold);

      return TRUE;
   }

   EndSecondWindTimer()
   {
      ptSecondWind = $;
      Send(self,@EndSecondWind);

      return;
   }

   EndSecondWind()
   {
      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
      }

      % This prevents repeated triggering of the second wind skill.
      if piVigor < SECONDWIND_THRESHOLD
      {
         piVigor = SECONDWIND_THRESHOLD;
      }

      Send(self,@SetVigorRestThreshold);
      Send(self,@NewVigor);
      Send(self,@MsgSendUser,#message_rsc=second_wind_finished);
      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
            #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);

      return;
   }

   GetSecondWindTimer()
   {
      return ptSecondWind;
   }

   GetVigorRestThreshold()
   {
      return piVigor_rest_threshold;
   }

   SetVigorRestThreshold()
   {
      % Don't go above rest threshold if we're still waiting for Second Wind.
      if ptSecondWind <> $
      {
         piVigor_rest_threshold = 10;
      }

      piVigor_rest_threshold = Send(self,@CalculateVigorThreshold);

      Send(self,@DrawVigor);

      return;
   }

   StartFortitude()
   {
      if ptFortitude = $
         AND piVigor < piVigor_rest_threshold
         AND NOT Send(self,@IsResting)
      {
         ptFortitude = CreateTimer(self,@DoFortitude,Send(self,@GetRestTime)*4);
      }
      return;
   }

   DoFortitude(timer=$)
   {
      local iRestAmount, oFortitude;

      ptFortitude = $;

      if piPlayerRace = RACE_AUTOMATON
      {
         iRestAmount = (-10000 * piReincarnations)/10;
         Send(self,@RestAddExertion,#amount=iRestAmount);
      }
      else if Send(self,@HasSkill,#num=SKID_FORTITUDE)
         AND NOT Send(self,@IsResting)
      {
         iRestAmount = -10000;
         oFortitude = Send(SYS,@FindSkillByNum,#num=SKID_FORTITUDE);
         iRestAmount = Send(oFortitude,@ModifyRestExertion,#who=self,#iRestAmount=iRestAmount);
         Send(self,@RestAddExertion,#amount=iRestAmount);
      }
      return;
   }

   CancelFortitude()
   {
      if ptFortitude <> $
      {
         DeleteTimer(ptFortitude);
         ptFortitude = $;
      }
      return;
   }

   AddExertion(amount = 0, SetToThreshold = FALSE)
   {
      local iExertionAdded, iPercentReduced, iVigorLost, i;

      if Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      iExertionAdded = amount;

      if iExertionAdded > 0
      {
         foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
         {
            iExertionAdded = Send(Nth(i,2),@ModifyExertion,
                                    #state=Nth(i,3),#amount=iExertionAdded);
         }
      
         if poOwner <> $
         {
            foreach i in Send(poOwner,@GetObjectAttributes)
            {
               if IsClass(i,&RoomThreat)
               {
                  iExertionAdded = Send(i,@ModifyExertion,#amount=iExertionAdded);
               }
            }
         }

         % Parliament adjustment for exertion reduction.  Remove a % from
         % the amount added.
         iPercentReduced = Send(Send(SYS,@GetParliament),@GetFactionVigorBonus,#who=self);
         iExertionAdded = (iExertionAdded * (100 - iPercentReduced))/100;
      }

      piExertion = piExertion + iExertionAdded;

      if abs(piExertion) > MIN_VIGOR_CHANGE OR SetToThreshold
      {
         if SetToThreshold AND piVigor < piVigor_rest_threshold
         {
            piVigor = piVigor_Rest_threshold;
            piExertion = 0;
         }
         else
         {
            iVigorLost = piExertion / 10000;
            piVigor = piVigor - iVigorLost;
            piExertion = piExertion - (iVigorLost * 10000);
         }

         Send(self,@NewVigor);
      }

      Send(self,@StartFortitude);

      return;
   }

   RestAddExertion(amount = 0)
   "Gives inns a bonus as resting places."
   {
      local iAmount;

      % If we cannot gain vigor (probably due to Second Wind), return
      % out if trying to take away exertion
      if ((ptSecondWind <> $) AND (amount < 0))
         OR Send(self,@IsInCannotInteractMode)
         OR NOT Send(self,@IsLoggedOn)
      {
         return;
      }

      if piVigor > piVigor_rest_threshold
      {
         return;
      }

      iAmount = Amount;
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY) AND amount < 0
      {
         iAmount = 2 * Amount;
      }

      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_TRIPLE_HEAL) AND amount < 0
      {
         iAmount = 3 * Amount;
      }
      
      if Send(self,@HasSkill,#num=SKID_SALABHASANA)
      {
         iAmount = Send(Send(SYS,@FindSkillByNum,#num=SKID_SALABHASANA),@ModifyRestAddExertion,#who=self,#iAmount=iAmount);
      }

      piExertion = piExertion + iAmount;
      if abs(piExertion) > MIN_VIGOR_CHANGE
      {    
         piVigor = piVigor - piExertion / 10000;
         if piVigor > piVigor_rest_threshold
         {
            piVigor = piVigor_rest_threshold;
         }

         piExertion = 0;
         Send(self,@NewVigor);
      }

      Send(self,@StartFortitude);

      return;
   }

   UpdateStomach()
   "Removes consumed food from stomach"
   {
      local now;

      now = GetTime();
      piStomach = piStomach-(now-piTimeLastStomachUpdate)*FOOD_USE_RATE/100;
      piStomach = bound(piStomach,1,piStomachMax);
      piTimeLastStomachUpdate = now;

      return;
   }

   HasVigor(amount = $)
   {
      if piVigor > amount
      {
         return TRUE;
      }

      return FALSE;
   }

   StartRescueTimer(time=5000)
   "Starts a timer which will rescue the player after time ms."
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      ptRescue = CreateTimer(self,@EndRescueTimer,time);

      return TRUE;
   }

   EndRescueTimer()
   {
      ptRescue = $;
      Send(self,@EndRescue);

      return;
   }

   EndRescue()
   "Deletes rescue timer if it exists and does the rescue operation."
   {
      Send(self,@CancelRescue);

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_RESCUE),@DoRescue,#who=self);
      }

      return;
   }

   CancelRescue()
   "Cancels the rescue timer if it exists and does not execute "
   "the rescue operation."
   {
      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      return;
   }

   CanRescue()
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   NewOwner(what = $)
   {
      local iBasePhaseTime, i;

      Send(self,@ResetGainFlags);

      % Are we moving somewhere "safe" or in a frenzy??
      if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         AND NOT Send(SYS,@GetChaosNight)
      {
         % Don't set the "haven't moved" flag if we're in a safe area.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

         % Don't create the revenant if we're in a safe location.
         if (piFlags & PFLAG_HAUNTED)
         {
            Create(&Revenant,#target=self,#location=poOwner,
                   #level=bound((((piBase_Max_health*150)/100)+
                        (5*piKill_Count_decay)),95,215),
                   #diff=bound(piBase_Max_health/10,4,9),
                   #karmic=-piKarma/100);
         }
      }

      Send(self,@BreakTrance,#event=EVENT_NEWOWNER);

      if (piFlags2 & PFLAG2_HUNTED)
      {
         Send(self,@InformHunters);
      }

      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
      {
         iBasePhaseTime = Send(self,@GetBasePhaseTime);
         if piRemainingPhaseTime <> iBasePhaseTime
         {
            Send(self,@MsgSendUser,#message_rsc=phase_fatigue_cleared);
            Send(self,@RefreshPhaseTimeToBase);
         }
      }
      
      foreach i in Send(self,@GetPassiveQuests)
      {
         Send(i,@EnteredRoom,#what=what);
      }

      % Stop any rescue attempts if the user changes rooms.
      if ptRescue <> $
      {
         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_newowner);
         }
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      
      if pbClearedStatsRecently
      {
         pbClearedStatsRecently = FALSE;
         if NOT Send(self,@GetBaseMaxHealth) <= Send(SETTINGS_OBJECT,@GetFreeStatsResetCap)
            AND Send(self,@HasReincarnationStatsReset)
         {
            Send(self,@SetReincarnationStatsReset,#value=FALSE);
            Send(self,@MsgSendUser,#message_rsc=consumed_free_stat_reset);
         }
         else if Send(self,@FindHolding,#class=&StatsResetToken) <> $
         {
            Send(Send(self,@FindHolding,#class=&StatsResetToken),@Delete);
            Send(self,@MsgSendUser,#message_rsc=consumed_ancient_token_reset);
         }
      }
      
      Send(self,@ClearBombs);
      
      if poStance <> $
         AND IsClass(poStance,&DefiantStandStance)
      {
         Send(self,@ClearStance);
      }

      return;
   }

   InformHunters()
   {
      local i, j, oSpell, state, oSpellCloak, rLocation, lRoomlist, oRoom;

      oSpell = Send(SYS,@FindSpellByNum,#Num=SID_HUNT);
      oSpellCloak = Send(SYS,@FindSpellByNum,#Num=SID_CLOAK);
      rLocation = Send(poOwner,@GetName);

      if Send(self,@IsEnchanted,#what=oSpellCloak)
         AND (Random(1,100) < Send(self,@GetEnchantedState,#what=oSpellCloak))
      {
         % Will mislead hunters with random room if Cloak is on
         % and passes state check.
         oRoom = Send(oSpellCloak,@GetWrongRoom);
         rLocation = Send(oRoom,@GetName);
      }

      foreach i in plEnchantments
      {
         if Nth(i,2) = oSpell
         {
            state = Nth(i,3);
            if NOT IsClass(First(state),&Prism)
            {
               foreach j in state
               {
                  Send(j,@MsgSendUser,#message_rsc=player_to_hunters,
                        #parm1=Send(self,@GetDef),
                        #parm2=Send(self,@GetTrueName),
                        #parm3=rLocation);
               }
            }
         }
      }

      return $;
   }

   ShowDesc()
   {
      local i,oEnchanter, rank, HitPoint_Percent;

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         % Since piHealth is internally inflated by a factor of 100, this 
         % returns the percentage correctly.
         HitPoint_Percent = piHealth / Send(self,@GetMaxHealth);
         Send(poIllusion_set,@IllusionShowDesc,#who=self,
               #iHitPoint_Percent=HitPoint_Percent);

         return;
      }

      if psPlayerDescription <> $
      {
         AddPacket(4,player_desc_enchanted_none);
         AddPacket(0,psPlayerDescription);

         return;
      }

      propagate;
   }

   GetAge()
   {
      local age;

      age = Send(SYS,@GetYear) - Send(self,@GetBirthYear);

      % No more tutorial messages and bonuses if you've been around
      % for about 2 months. Clear the newbie string, too. Do a bit flag
      % check instead of a function call since this is called EVERY time
      % someone gets looked at.
      if age >= 2
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
         Send(self,@RemoveHonorString,#string=player_newbie_honor_string);
      }

      return age;
   }

   SetAge(age = 0)
   "Admin supported."
   {
      age = bound(age, 0, Send(SYS,@GetYear));
      piBorn_year = Send(SYS,@GetYear) - age;

      return age;
   }

   GetHonorStringList()
   {
      return plHonor;
   }

   HasHonorString(string = $)
   "Checks the plHonor list for the given string."
   {
      local i;

      if plHonor = $
         or string = $
      {
         return FALSE;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   AppendHonorStrings()
   "Appends all the honor strings to the temp string. Adds newline "
   "between strings."
   {
      local i;

      if plHonor <> $
      {
         foreach i in plHonor
         {
            % Add newbie tag separately so it gets translated.
            if i <> player_newbie_honor_string
            {
               AppendTempString(i);
               AppendTempString("\n");
            }
         }
      }

      return;
   }

   AddHonorString(string=$,iPosition = 1)
   "Adds string to plHonor list. iPosition allows string position "
   "to be chosen."
   {
      if string = $
      {
         return;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      if plHonor = $
      {
         plHonor = [string];
      }
      else
      {
         plHonor = InsertListElem(plHonor,iPosition,string);
      }

      return;
   }

   RemoveHonorString(string=$)
   "Removes the given string from plHonor. Searches the entire list, "
   "so it will remove any duplicates."
   {
      local i;

      if plHonor = $
         OR string = $
      {
         return;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            plHonor = DelListElem(plHonor,i);
         }
      }

      return;
   }

   ClearHonorStrings()
   "Removes all the honor strings."
   {
      plHonor = $;

      return;
   }

   ShowExtraInfo()
   {
      local i, j, obj, year, rCargoNum;

      % Master fixed info resource.
      AddPacket(4,player_fixed_info);

      %
      % Add hometown and age, or DM rank.
      %
      if NOT IsClass(self,&DM)
      {
         switch(Send(self,@GetHomeRoom))
         {
            case RID_NEWB1:
               j = player_citizen_raza;
               break;
            case RID_GUEST1:
               j = player_citizen_hazar;
               break;
            case RID_BAR_INN:
               j = player_citizen_barloque;
               break;
            case RID_COR_INN:
               j = player_citizen_cornoth;
               break;
            case RID_MAR_INN:
               j = player_citizen_marion;
               break;
            case RID_JAS_INN:
               j = player_citizen_jasper;
               break;
            case RID_TOS_INN:
               j = player_citizen_tos;
               break;
            case RID_KOC_INN:
               j = player_citizen_kocatan;
               break;
            case RID_ADVENTURERS_GUILD:
               j = player_citizen_adventurers_league;
               break;
            default:
               j = player_citizen_unknown;
               break;
         }

         AddPacket(4,player_hometown_rsc,4,Send(self,@GetHeShe,#cap=TRUE),4,j);
         ClearTempString();
         i = Send(self,@GetAge);
         if (i < 1)
         {
            AddPacket(4,system_blank_resource,4,GetTempString(),
                      4,player_under_one_year);
         }
         else
         {
            AddPacket(4,player_for);

            Send(SYS,@AppendCardinalToTempString,#number=i);
            AddPacket(4,GetTempString());
            if i = 1
            {
               AddPacket(4,player_year);
            }
            else
            {
               AddPacket(4,player_years);
            }
         }
      }
      else
      {
         % For DMs
         i = Send(self,@GetRankRsc);
         if i <> $
         {
            AddPacket(4,i);
         }
         else
         {
            AddPacket(4,system_blank_resource);
         }
      }
      
      %
      % Add reincarnations.
      %
      i = Send(self,@GetNumReincarnations);
      if i = 0
      {
         AddPacket(4,system_blank_resource);
      }
      else if i = 1
      {
         AddPacket(4,reincarnated_once,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else
      {
         AddPacket(4,reincarnated_times,4,Send(self,@GetHeShe,#cap=TRUE),
                   4,piReincarnations);
      }

      %
      % Add ancestry.
      %

      i = piPlayerRace;
      if i = RACE_HALF_ORC
      {
         AddPacket(4,player_race_orc,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_HALF_DEMON
      {
         AddPacket(4,player_race_demon,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_HALF_ELF
      {
         AddPacket(4,player_race_elf,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_HALF_UNDINE
      {
         AddPacket(4,player_race_undine,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_DROW
      {
         AddPacket(4,player_race_drow,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_DRACONIAN
      {
         AddPacket(4,player_race_dragon,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_GNOME
      {
         AddPacket(4,player_race_gnome,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if i = RACE_AUTOMATON
      {
         AddPacket(4,player_race_automaton,4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      %
      % Add guild affiliation.
      %
      if poGuild <> $ AND NOT Send(poGuild,@IsSecret)
      {
         i = Send(poGuild,@GetRank,#who=self);
         % (example) Squire of the BootLickers.
         AddPacket(4,player_guild_rsc, 4,Send(poGuild,@GetRankName,#rank=i,#sex=piGender),
                   4,player_of, 4,Send(poGuild,@GetDef),4,Send(poGuild,@GetName));
      }
      else
      {
        AddPacket(4,system_blank_resource);
      }

      %
      % Add faction affiliation.
      %
      i = Send(self,@GetFaction);
      if (i = FACTION_DUKE)
      {
         AddPacket(4,player_faction_duke);
      }
      else if (i = FACTION_PRINCESS)
      {
         AddPacket(4,player_faction_princess);
      }
      else if (i = FACTION_REBEL)
      {
         AddPacket(4,player_faction_rebel);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }
      
      %
      % Add opt-out info and ladder info. (no opt outs in ladders)
      %
      if pbOptOutPvP
         AND Send(SETTINGS_OBJECT,@GetAllowOptOutPvP)
      {
         AddPacket(4,player_opt_out_pvp, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@GetLadderID) <> 0
      {
         AddPacket(4,player_is_in_ladder, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if piFinalLadderRank <> 0
      {
         if piParticipatedInLadderNumber = 1
         {
            AddPacket(4,player_ranked_in_ladder_one, 4,Send(self,@GetHeShe,#cap=TRUE), 4,piFinalLadderRank);
         }
         else
         {
            AddPacket(4,player_ranked_in_ladder_one, 4,Send(self,@GetHeShe,#cap=TRUE), 4,piFinalLadderRank, 4,piParticipatedInLadderNumber);
         }
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      %
      % Add visible cargo types. The number of these doesn't really change,
      % but this section has error checking anyway just in case we change it.
      %
      j = Send(SYS,@GetVisibleCargoTypes);
      if j = $
      {
         AddPacket(4,system_blank_resource);
      }
      else
      {
         switch(Length(j))
         {
            case 5:
               rCargoNum = system_rsc_template_5;
               break;
            case 1:
               rCargoNum = system_rsc_template_1;
               break;
            case 2:
               rCargoNum = system_rsc_template_2;
               break;
            case 3:
               rCargoNum = system_rsc_template_3;
               break;
            case 4:
               rCargoNum = system_rsc_template_4;
               break;
            case 6:
               rCargoNum = system_rsc_template_6;
               break;
            case 7:
               rCargoNum = system_rsc_template_7;
               break;
            default:
               rCargoNum = system_rsc_template_1;
               break;
         }

         AddPacket(4,rCargoNum);

         foreach i in j
         {
            % (example) He is holding a purple pickle princess figurine.
            obj = Send(self,@FindHolding,#class=i);
            if obj <> $
            {
               if IsClass(obj,&Ring)
               {
                  AddPacket(4,player_is_wearing, 4,Send(self,@GetHeShe,#cap=True),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
               else
               {
                  AddPacket(4,player_is_holding, 4,Send(self,@GetHeShe,#cap=True),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
            }
            else
            {
              AddPacket(4,system_blank_resource);
            }
         }
      }

%%% Option turned off for review.
% Works with %q placed in the master fixed description resource.
%      ClearTempString();
%      if NOT Send(self,@PlayerIsImmortal)
%      {
%         % (example) Known far and wide for mastery of Jala and Kraanan magics 
%         % and weaponcraft skills.
%
%         j = FALSE;
%
%         % magic school masteries first
%         obj = Send(SYS,@FindSpellByNum,#num=SID_BONK); % any real spell will do
%         foreach i in [SS_JALA,SS_RIIJA,SS_QOR,SS_SHALILLE,SS_KRAANAN,SS_FAREN]
%         {
%            if Send(self,@CountKnownAtLevel,#school=i,#level=6) >= 1
%            {
%               if NOT j
%               {
%                  AppendTempString(player_known_for_mastery);
%                  j = TRUE;
%               }
%               else
%               {
%                  AppendTempString(player_and);
%               }
%               AppendTempString(Send(obj,@GetSchoolStr,#ischool=i));
%            }
%         }
%         
%         if j
%         {
%            AppendTempString(player_magics);
%         }
%
%         % weaponcraft
%         if Send(self,@CountKnownAtLevel,#school=SKS_FENCING,#level=5) >= 1
%         {
%            if NOT j
%            {
%               AppendTempString(player_known_for_mastery);
%               j = TRUE;
%            }
%            else
%            {
%               AppendTempString(player_and);
%            }
%            AppendTempString(player_skills);
%         }
%
%         AppendTempString(player_dot);
%         AppendTempString(player_nl);
%      }
%      AddPacket(4,GetTempString());

      %
      % Add newbie tag resource ID, so client can translate it.
      %
      if Send(self,@HasHonorString,#string=player_newbie_honor_string)
      {
         AddPacket(4,player_newbie_honor_string);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      %
      % Append all honor strings (except newbie tag) to the temp string.
      %
      ClearTempString();
      Send(self,@AppendHonorStrings);
      AddPacket(4,GetTempString());

      %
      % Add donation years.
      %
      ClearTempString();
      if plDonationYears <> $
      {
         i = 0;
         foreach year in plDonationYears
         {
            if i <> 0
            {
               AppendTempString(player_donation_separator);
            }
            AppendTempString(year);
            ++i;
         }
         AddPacket(4,player_donation_title,4,GetTempString());
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }
      
      if piMasteredSkill > 0
      {
         AddPacket(4,player_mastered_skill_num, 4,Send(self,@GetHeShe,#cap=True),4,Send(Send(SYS,@FindSkillByNum,#num=piMasteredSkill),@GetName));
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }
      
      if piMasteredSpell > 0
      {
         AddPacket(4,player_mastered_spell_num, 4,Send(self,@GetHeShe,#cap=True),4,Send(Send(SYS,@FindSpellByNum,#num=piMasteredSpell),@GetName));
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }
      
      if Send(self,@FindHolding,#class=&ShalilleCrest) <> $
      {
         AddPacket(4,player_statue_master_shal, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&QorCrest) <> $
      {
         AddPacket(4,player_statue_master_qor, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&WeaponcraftCrest) <> $
      {
         AddPacket(4,player_statue_master_weaponcraft, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&KnightcraftCrest) <> $
      {
         AddPacket(4,player_statue_master_knightcraft, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&BanditryCrest) <> $
      {
         AddPacket(4,player_statue_master_banditry, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&SorceryCrest) <> $
      {
         AddPacket(4,player_statue_master_sorcery, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&WitcheryCrest) <> $
      {
         AddPacket(4,player_statue_master_witchery, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&JalaCrest) <> $
      {
         AddPacket(4,player_statue_master_jala, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&KraananCrest) <> $
      {
         AddPacket(4,player_statue_master_kraanan, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&FarenCrest) <> $
      {
         AddPacket(4,player_statue_master_faren, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&RiijaCrest) <> $
      {
         AddPacket(4,player_statue_master_riija, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&AlchemyCrest) <> $
      {
         AddPacket(4,player_statue_master_alchemy, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&AdventurerCrest) <> $
      {
         AddPacket(4,player_statue_greatest_adventurer, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&WizardCrest) <> $
      {
         AddPacket(4,player_statue_greatest_wizard, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else if Send(self,@FindHolding,#class=&WarriorCrest) <> $
      {
         AddPacket(4,player_statue_greatest_warrior, 4,Send(self,@GetHeShe,#cap=TRUE));
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   UserLogonHook()
   {
      local i, oGame, oParl, iBonus, iDefaultBonus, iTimespan;

      SendList(plPassive, 0, @UserLogon);
      SendList(plActive, 0, @UserLogon);

      % Restart Health and Mana timers
      Send(self,@NewHealth);
      Send(self,@NewMana);
      Send(self,@StartFortitude);

      Send(self,@SendUserAllWindowOverlays);

      oParl = Send(SYS,@GetParliament);
      if oParl <> $
      {
         if piFaction <> FACTION_NEUTRAL 
            AND (NOT Send(oParl,@IsShutdown))
         {
            piFactionTimeUpdated=GetTime();
            Send(self,@FactionServiceTimer);
         }

         if Send(self,@PlayerIsIntriguing)
         {
            Send(oParl,@UpdateEffects,#who=self); 
         }
      }

      oGame = Send(SYS,@GetAssassinGame);
      if oGame <> $
         AND Send(oGame,@InAcceptMode)
         AND (NOT Send(oGame,@IsCombatant,#who=self))
         AND Send(oGame,@IsAdvertised,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=player_assgame_soon);
      }

      if poGuild <> $
      {
         Send(poGuild,@SendUserMOTD,#who=self);
      }

      if ptTempSafe <> $
      {
         piFlags = piFlags | PFLAG_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe);
      }

      if piPoisonStrength > 0
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      % Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

      % If we log into the Raza/Hazar inn and aren't past the tutorial,
      %   then give us a commands list.
      if IsClass(poOwner,&Guest1)
         OR (IsClass(poOwner,&Newb1)
            AND NOT (piFlags & PFLAG_TUTORIAL))
      {
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Max mana could have changed while offline (e.g. mana node changes).
      % We used to do this when the mana nodes changed, but iterating
      % over all players became far too expensive.
      Send(self,@ComputeMaxMana);

      % Tell others that we're here
      if poOwner <> $ AND NOT IsClass(self, &DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_on_wav_rsc);
      }

      % Reward people for logging on by granting them some free training points!
      % We take the absolute value to automatically fix bugs with people
      % mysteriously ending up with a timestamp in the distant future.
      iTimespan = abs(GetTime() - piReward_timestamp);

      % We restrict the timespan to reasonable limits here since the bonus to
      % training points scales with the time since the last bonus has been
      % received. 36 hours means that players have a decent leeway to log on
      % again before missing out on training points, but are still encouraged
      % to log on daily to cash in maximum points.
      iTimespan = bound(iTimespan,0,36*60*60);

      if iTimespan > 16*60*60
      {
         if piTraining_points >= TRAINING_POINT_CAP
         {
            return;
         }

         % Retrieve the daily logon bonus from settings.
         iDefaultBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);
         
         % Scale the logon bonus with the time that has passed since it has last
         % been received for a total bonus of up to 150 percent.
         iBonus = iDefaultBonus * iTimespan / (24*60*60);
         
         Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
         Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

         piReward_timestamp = GetTime();
      }

      % For people who never log off, start the reward timer that will grant
      % them the daily training bonus every 24 hours, even if they don't log
      % off and back on.
      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);
      
      if poBondedItem <> $
      {
         if ptBondedItemReport = $
         {
            % Start up bond report on logon. But only if it doesn't already exist - so people can't spam checks by logging on/off.
            ptBondedItemReport = CreateTimer(self,@BondedItemReport,BOND_REPORT_INTERVAL);
            Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),@BondedItemReport,#BondedItem=poBondedItem,#BondedPlayer=self);
         }
      }
      
      if pbNotifyLadderEnded
      {
         Post(self,@MsgSendUser,#message_rsc=Ladder_ended_msg);
         pbNotifyLadderEnded = FALSE;
      }

      Post(self,@StartLoggedOnRefreshPhaseTime);
      return;
   }

   UserLogoffHook()
   {
      local i;

      SendList(plPassive,0,@UserLogoff);
      SendList(plActive,0,@UserLogoff);

      % If this player has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         foreach i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      Send(self,@CancelFortitude);

      Send(self,@ClearDelayedAdditionalAttacks);

      Send(self,@ClearStance);

      % client assumes not resting upon login
      Send(self,@StopResting);

      if piFaction <> FACTION_NEUTRAL
      {
         Send(self,@FactionServiceTimer,#renew=FALSE);
      }

      % Stop unbound energy, health and mana timers.
      if ptUnboundEnergy <> $
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }

      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth=$;
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      Send(self,@CancelRescue);
      
      Send(self,@EndBleedTimer);

      % Tell others that we're leaving
      if poOwner <> $ AND NOT IsClass(self,&DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_off_wav_rsc);
      }

      Post(self,@ResetMonsterChasers);

      Post(self,@CancelLoggedOnRefreshPhaseTime);
      return;
   }

   SendUserAllWindowOverlays()
   "Send the user any overlays that they might have.  Called when they logon "
   "or when garbage collected."
   {
      local i;

      foreach i in plWindow_overlays
      {
         Send(self,@SetWindowOverlay,#what=i);
      }
      
      if Send(poOwner,@GetVisualTimer) <> $
      {
         Send(Send(poOwner,@GetVisualTimer),@DisplayVisualTimerForOne,#oPlayer=self);
      }

      return;
   }

   RestrictToResourceList(res = $, res_list = $)
   "If res is in res_list, return it.  Otherwise return the first element "
   "of res_list."
   {
      if FindListElem(res_list, res)
      {
         return res;
      }

      return Nth(res_list, 1);
   }

   PlayerNewCharInfo(desc = $,charinfo = $,gender = $)
   "This message is received when the user (re)started a character.\n"
   "<desc> contains a string with the description, charinfo is a list "
   "of values selected.  See system.kod, SendCharInfo(), for what these "
   "values mean."
   {
      local i, lFaceparts, lStats, lSpells, lSkills, iPoints, iLevel, oSpell,
            iHair_translation, iSkin_translation, bQor, bShalille, oSkill;

      bQor = FALSE;
      bShalille = FALSE;

      psPlayerDescription = desc;

      if Length(charinfo) <> 6
      {
         Debug("Bad charinfo message, length ",Length(charinfo));

         return;
      }

      % charinfo is a list of 4 elements:
      % list of face part resources
      % list of stats (might, intellect, etc.)
      % list of initial spells
      % list of initial skills

      lFaceparts = Nth(charinfo,1);
      if (Length(lFaceparts) <> 5)
      {
         % Hacking the protocol -> default char
         gender = GENDER_MALE;
         lFaceparts = [charinfo_head_ax_icon,charinfo_hair_ac_icon,
                       charinfo_eyes_ax_icon,charinfo_nose_ax_icon,
                       charinfo_mouth_ax_icon];
      }

      % Validate that all face parts were in the list of choices
      prHead = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,1),
          #res_list = Send(SYS, @GetAllowedHeadIcons, #iGender = gender));

      prToupee = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,2), 
          #res_list = Send(SYS, @GetAllowedHairIcons, #iGender = gender));

      prEyes = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,3), 
          #res_list = Send(SYS, @GetAllowedEyeIcons, #iGender = gender));

      prNose = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,4), 
          #res_list = Send(SYS, @GetAllowedNoseIcons, #iGender = gender));

      prMouth = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,5), 
          #res_list = Send(SYS, @GetAllowedMouthIcons, #iGender = gender));

      iHair_translation = Nth(charinfo,2);
      iSkin_translation = Nth(charinfo,3);

      if iHair_translation <> 0
         AND iHair_translation <> PT_GRAY_TO_ORANGE
         AND iHair_translation <> PT_GRAY_TO_RED
         AND iHair_translation <> PT_GRAY_TO_SKIN1
         AND iHair_translation <> PT_GRAY_TO_SKIN2
         AND iHair_translation <> PT_GRAY_TO_SKIN3
         AND iHair_translation <> PT_GRAY_TO_SKIN4
         AND iHair_translation <> PT_GRAY_TO_SKIN5
         AND iHair_translation <> PT_GRAY_TO_PLATBLOND
         AND iHair_translation <> PT_GRAY_TO_KORANGE
         AND iHair_translation <> PT_GRAY_TO_KRED
         AND iHair_translation <> PT_GRAY_TO_KGRAY
         AND iHair_translation <> PT_GRAY_TO_BLACK
         AND iHair_translation <> PT_GRAY_TO_BLOND
         AND iHair_translation <> PT_GRAY_TO_LSKY
      {
         % if they hacked char.dll...
         iHair_translation = PT_GRAY_TO_BLOND;
      }
      
      Send(self,@SetHairTranslation,#translation=iHair_translation);

      if iSkin_translation <> PT_BLUE_TO_SKIN1
         AND iSkin_translation <> PT_BLUE_TO_SKIN2
         AND iSkin_translation <> PT_BLUE_TO_SKIN3
         AND iSkin_translation <> PT_BLUE_TO_SKIN4
      {
         % if they hacked char.dll...
         iSkin_translation = PT_BLUE_TO_SKIN3;
      }

      piOriginalSkinColor = iSkin_translation;

      Send(self,@SetSkinTranslation,#translation=iSkin_translation);
      Send(self,@SetDefaultClothes,#rand=TRUE);
      Send(self,@ResetPlayerIcon);
      Send(self,@ResetPlayerArms);
      Send(self,@ResetPlayerLegs);

      lStats = Nth(charinfo,4);
      if (Length(lStats) <> 6)
      {
         % Hacking the protocol -> junk char for you
         lStats = [1, 1, 1, 1, 1, 1];
      }

      iPoints = Nth(lStats,1) + Nth(lStats,2) + Nth(lStats,3);
      iPoints = iPoints + Nth(lStats,4) + Nth(lStats,5) + Nth(lStats,6);

      if Nth(lStats,1) < 1 OR Nth(lStats,1) > 50
         OR Nth(lStats,2) < 1 OR Nth(lStats,2) > 50
         OR Nth(lStats,3) < 1 OR Nth(lStats,3) > 50
         OR Nth(lStats,4) < 1 OR Nth(lStats,4) > 50
         OR Nth(lStats,5) < 1 OR Nth(lStats,5) > 50
         OR Nth(lStats,6) < 1 OR Nth(lStats,6) > 50
         OR iPoints > 200
      {
         % they hacked their char.dll
         piMight = 3;
         piIntellect = 1;
         piStamina = 4;
         piAgility = 1;
         piMysticism = 5;
         piAim = 9;
      }
      else
      {
         piMight = Nth(lStats,1);
         piIntellect = Nth(lStats,2);
         piStamina = Nth(lStats,3);
         piAgility = Nth(lStats,4);
         piMysticism = Nth(lStats,5);
         piAim = Nth(lStats,6);
      }

      % Set some other stats based on these

      piHealth = 2000;
      Send(self,@NewHealth);
      piBase_Max_Health = 20;
      piMax_health = piBase_max_health;
      Send(self,@GainBaseMaxHealth);
      
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," restarted character: ",piMax_health,
               pibase_max_health);
      }

      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;

      % need to determine male/female
      if gender = GENDER_MALE
      {
         piGender = GENDER_MALE;
         vrIcon = player_male_icon_rsc; 
         prLegs = player_legs_a_rsc;
         prRight_arm = player_rightarm_a_rsc;
         prLeft_arm = player_leftarm_a_rsc;
      }
      else
      {
         piGender = GENDER_FEMALE;
         vrIcon = player_female_icon_rsc; 
         prLegs = player_legs_b_rsc;
         prRight_arm = player_rightarm_b_rsc;
         prLeft_arm = player_leftarm_b_rsc;
      }

      Send(self,@ResetCharacter);

      % Setup default stuff

      Send(self,@AddDefaultSpells);
      Send(self,@AddDefaultSkills);

      lSpells = Nth(charinfo,5);
      lSkills = Nth(charinfo,6);

      iPoints = 0;
      foreach i in lSpells
      {
         iLevel = Send(Send(SYS,@FindSpellByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }

      foreach i in lSkills
      {
         iLevel = Send(Send(SYS,@FindSkillByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }

      if iPoints > 45
      {
         % they hacked their char.dll
      }
      else
      {
         if NOT IsClass(self,&Guest)
         {
            foreach i in lSpells
            {
               oSpell = Send(SYS, @FindSpellByNum, #num=i);
               % Not offered to new characters -> cheating, skip spell
               if (oSpell <> $ AND Send(oSpell,@OfferToNewCharacters))
               {
                  iLevel = Send(oSpell,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSpell,#num=i,#initial=TRUE);
                  }
                  if (Send(oSpell,@GetSchool) = SS_QOR)
                  {
                     bQor = TRUE;
                  }
                  if (Send(oSpell,@GetSchool) = SS_SHALILLE)
                  {
                     bShalille = TRUE;
                  }
               }
            }

            foreach i in lSkills
            {
               oSkill = Send(SYS,@FindSkillByNum,#num=i);
               if (oSkill <> $)
               {
                  iLevel = Send(oSkill,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSkill,#num=i,#initial=TRUE);
                  }
               }
            }
         }

         Send(self,@RefigureSchoolsLists);
      }
      
      if Send(Send(SYS,@GetLadderMaintenance),@GetLadderEnabled)
      {
         Send(self,@SetLadderID,#value=Send(Send(SYS,@GetLadderMaintenance),@GetLadderNum));
      }

      % Do this after we add spells so that we can give reagents if appropriate.
      Send(self,@AddDefaultObjects);

      % If the player chose either a Qor spell or a Shalille spell to start,
      % give him a favorable karma to start from. However, if he chose both,
      % or if he chose neither, do nothing.

      piKarma = 0;
      if bQor AND NOT bShalille
      {
         piKarma = -2000;
      }

      if bShalille AND NOT bQor
      {
         piKarma = 2000;
      }

      Send(self,@SetInitialHomeroom);
      Send(self,@TeleportToInitialLocation);

      piBorn_year = Send(SYS,@GetYear);

      % Send first mail the first time player plays.
      % Set their honor strong if this is a truly new character (max 1 reroll)
      if NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_first_mail]);
         Send(self,@AddHonorString,#string=player_newbie_honor_string);
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Update stomach so it starts ticking down properly
      Send(self,@UpdateStomach);
      
      % New character, no wisdom.
      piAccumulatedWisdom = 0;

      % Give them a new start on life, so that their newbie
      % friends can buff and heal them.
      piTimeAttackedPlayer = 0;

      return;
   }

   GetBirthYear()
   {
      return piBorn_year;
   }

   SetBirthYear(year=0)
   {
      piBorn_Year = year;

      return;
   }

   ReincarnateCharacter()
   "Conditionally altered reset"
   {
      local i;

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      Send(self,@ClearAllStatusEffects);
      Send(self,@ClearPrismsDefeated);

      Send(self,@ClearStance);
      Send(self,@ClearElementalImbalance);

      Send(self,@SetTattooed,#value=FALSE);
      
      Send(self,@RemoveAllMinions);
      Send(self,@RemoveAllDeadMinions);

      foreach i in plActive
      {
         Send(i,@Delete);
      }

      foreach i in plPassive
      {
         Send(i,@Delete);
      }

      % Remove Zealous Fervor first to account for health bonus.
      Send(self,@RemoveSkill,#num=SKID_ZEALOUS_FERVOR);

      plSpells = $;
      plSkills = $;

      if Send(self,@CheckLog)
      {
         Debug("LOG: ",vrName," reincarnated!");
      }
      
      % THIS IS NOW WHERE WE GIVE BONUS TP / AW BASED ON HP
      Send(self,@AddAccumulatedWisdom,#amount=((Send(self,@GetAccumulatedWisdom)/100) * Bound((piBase_Max_Health-75)/5,0,25)));

      % Setup some stats
      piBase_max_health = 20;
      piHealth = 2000;
      piMax_health = piBase_max_health;
      Post(self,@ComputeMaxMana);

      Send(self,@SetExperience,#iAmount=0);

      poKill_target = $;

      piVigor = 80;
      piExertion = 0;
      % percent stomach is full
      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();

      Send(self,@ZeroMods);

      Send(self,@PlayerIsIntriguing);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);
      
      if NOT pbOptOutPvP
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TEMPSAFE,#value=FALSE);
      }

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp=self);

      Send(Send(sys,@GetAssassinGame),@RemoveFromGame,#who=self);
      % Remove the guy from the Assassin's game.

      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);

      if Send(SYS,@GetLastMurderer) = self
      {
         Send(SYS,@ClearLastMurderer);
      }

      Send(Send(SYS,@FindRoomByNum,#num=RID_NEWB1),@Teleport,#what=self);

      Send(self,@AddDefaultSpells);
      Send(self,@AddDefaultSkills);
      
      %Post(self,@AddTrainingPoints,#points=(piReincarnations+1)*Send(SETTINGS_OBJECT,@GetTPperReinc),#report=TRUE,#bCap=FALSE);
      piTraining_points = Bound(piAccumulatedWisdom,0,ACCUMULATED_WISDOM_TO_TRAINING_POINTS_CAP);
      Post(self,@DrawTraining);

      return;
   }

   ResetCharacter()
   "Setup default stuff"
   {
      local i;

      % first, kill all their items

      foreach i in plActive
      {
         Send(i,@Delete);
      }

      foreach i in plPassive
      {
         Send(i,@Delete);
      }

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      % Remove Zealous Fervor first to account for health bonus.
      Send(self,@RemoveSkill,#num=SKID_ZEALOUS_FERVOR);

      plSpells = $;
      plSkills = $;

      if Send(self,@CheckLog)
      {
         Debug("LOG: ",vrName," restarted character, spells & skills are nil");
      }

      % Setup some stats
      piBase_max_health = 20;
      piMax_health = piBase_max_health;
      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;

      poKill_target = $;
      piKarma = 0;

      piVigor = 100;
      piVigor_rest_threshold = 80;
      piExertion = 0;
      % percent stomach is full
      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();

      piKill_count = 0;
      piKill_count_decay = 0;
      piJustified_kill_count = 0;

      Send(self,@ZeroMods);

      Send(self,@PlayerIsIntriguing);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);

      if NOT pbOptOutPvP
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TEMPSAFE,#value=FALSE);
      }

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp=self);

      % quit the guild, then be sure any guild commands are set to nil
      % important, keep this after the player flags part above.
      Send(self,@QuitGuild);
      piGuild_commands = 0;

      Send(Send(sys,@GetAssassinGame),@RemoveFromGame,#who=self);
      % Remove the guy from the Assassin's game.

      Send(self,@RemoveAllEnchantments,#report=FALSE);

      piLight = 5;

      % Be sure they aren't declared a 'former member' by any existing guilds.
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      piNodelist = 0;

      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);

      if Send(SYS,@GetLastMurderer) = self
      {
         Send(SYS,@ClearLastMurderer);
      }

      return;
   }

   AddDefaultSpells()
   "Add the spells a player is given when creating a character"
   {
      Send(self,@AddSpell,#num=SID_BLINK,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_CONVEYANCE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_PHASE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_MEDITATE,#initial=TRUE,#iability=1);
      Send(self,@AddSpell,#num=SID_RECALL,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_GUILD_HALL_RECALL,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_DONATE,#initial=TRUE);

      return;
   }

   AddDefaultSkills()
   "Add the skills that all players have."
   {
      Send(self,@AddSkill,#num=SKID_AWARENESS,#initial=TRUE);
      return;
   }

   AddDefaultObjects()
   "Add the objects a player is given when creating a character in newbie zone"
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      % Give the poor newbie an weapon and a bit of cash.
      Send(self,@NewHold,#what=Create(&Mace,#ladderID=Send(self,@GetLadderID)));
      Send(self,@NewHold,#what=Create(&Money,#number=500,#ladderID=Send(self,@GetLadderID)));
      Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
      Send(self,@AddReagentsForSpells,#iNumCasts=10);

      % If player hasn't suicided in last 5 hours, give them cash and prizes!
      if (GetTime() - piLast_restart_time) > (5*60*60)   
      {
         Send(self,@NewHold,#what=Create(&Money,#number=500,#ladderID=Send(self,@GetLadderID)));
         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
         Send(self,@AddReagentsForSpells,#iNumCasts=10);
      }

      return;
   }

   StripInventory()
   {
      local lItems,oItem;

      % Delete the old stuff.
      foreach lItems in [plActive,plPassive]
      {
         foreach oItem in lItems
         {
            Send(oItem,@Delete);
         }
      }

      return;
   }

   AddRealWorldObjects()
   "Add the objects a player is given when character leaves the newbie zone."
   {
      local lItems,oItem,iSchool;

      % If player hasn't suicided in last 5 hours,
      % give them cash and fancy clothes!
      if (GetTime() - piLast_restart_time) > (5*60*60)
      {
         Send(self,@NewHold,#what=Create(&Money,#number=1000,#ladderID=Send(self,@GetLadderID)));
         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=1000);
         Send(self,@NewHold,#what=create(&InkyCap,#number=5,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=Create(&PantsC,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=Create(&Shirt,#color=XLAT_TO_GRAY,#ladderID=Send(self,@GetLadderID)));
      }

      if Send(Send(SYS,@GetLore),@BetaPotionsEnabled) 
         AND Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
      {
         Send(self,@NewHold,#what=create(&MysticSword,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=create(&MysticSword,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=create(&InkyCap,#number=20,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=create(&SimpleHelm,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=create(&ScaleArmor,#ladderID=Send(self,@GetLadderID)));
         Send(self,@NewHold,#what=create(&Gauntlet,#ladderID=Send(self,@GetLadderID)));
         Send(self,@AddReagentsForSpells,#iNumCasts=20);
      }

      Send(self,@NewHold,#what=Create(&Mace,#ladderID=Send(self,@GetLadderID)));
      Send(self,@NewHold,#what=Create(&Apple,#number=5,#ladderID=Send(self,@GetLadderID)));

      return;
   }

   AddReagentsForSpells(iNumCasts=5)
   "Add reagents to the player for the spells they have. Enough "
   "reagents for iNumCasts casts."
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      foreach iInfo in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=iInfo));
         lReagents = Send(oSpell,@GetReagents);

         foreach lItems in lReagents
         {
            cReagent = first(lItems);
            iNumber = Nth(lItems,2);

            Send(self,@NewHold,
                  #what=Create(cReagent,#number=(iNumber*iNumCasts),#ladderID=Send(self,@GetLadderID)));
         }
      }

      return;
   }

   GetNumItemsInInventory()
   {
      return (length(plActive) + length(plPassive));
   }

   DropItem(droppedItem=$, targetGhost=$, dropRoom=$, dropRow=0, dropCol=0,
            dropFineRow=32,dropFineCol=32,index=$, merge=TRUE)
   {
      local oItem, oDropRoom, iDropRow, iDropCol, iDropFineRow, iDropFineCol,
            oItemAtt;

      if droppedItem <> $
      {
         oItem = droppedItem;
      }
      else if index = $
      {
         return FALSE;
      }

      oItem = Send(self,@FindItemByIndex,#index=index);

      % Can't drop nothing.
      if (oItem = $)
      {
         return FALSE;
      }

      if targetGhost = $
      {
         if dropRoom = $
         {
            oDropRoom = poOwner;
            iDropRow = piRow;
            iDropCol = piCol;
            iDropFineRow = piFine_row;
            iDropFineCol = piFine_col;
         }
         else
         {
            oDropRoom = dropRoom;
            iDropRow = dropRow;
            iDropCol = dropCol;
            iDropFineRow = dropFineRow;
            iDropFineCol = dropFineCol;
         }
      }
      else
      {
         % This is the result of a logoff ghost penalty.
         oDropRoom = Send(targetGhost,@GetOwner);
         iDropRow = Send(targetGhost,@GetRow);
         iDropCol = Send(targetGhost,@GetCol);
         iDropFineRow = Send(targetGhost,@GetFineRow);
         iDropFineCol = Send(targetGhost,@GetFineCol);
      }

      if Send(oItem,@ReqNewOwner,#what=oDropRoom)
         AND Send(oDropRoom,@ReqNewHold,#what=oItem,
                  #new_row=iDropRow,#new_col=iDropCol)
      {
         if Send(oItem,@DropOnDeath)
         {
            if targetGhost <> $
            {
               % Put the PK pointer attribute on the item to prevent
               % mules from grabbing penalty drops from ghosts.
               oItemAtt = Send(sys,@FindItemAttByNum,#num=IA_PKPOINTER);
               Send(oItemAtt,@AddToItem,#oItem=oItem,
                     #timer_duration=PKPOINTER_TIME,
                     #state1=self);
            }

            Send(oDropRoom,@NewHold,#what=oItem,#merge=merge,
                  #new_row=iDropRow,#new_col=iDropCol,
                  #fine_row=iDropFineRow,#fine_col=iDropFineCol);

            return TRUE;
         }
      }

      return FALSE;
   }

   FindItemByIndex(index = $)
   {
      local lInv;

      if index = $
      {
         return $;
      }

      if index <= length(plActive)
      {
         lInv = plActive;
      }
      else
      {
         lInv = plPassive;
         index = index - length(plActive);
      }

      if (lInv = $)
      {
         return $;
      }

      return Nth(lInv,index);
   }

   GetGuild()
   {
      return poGuild;
   }

   GetGuildHall()
   "Return this player's guild hall, or NIL if none"
   {
      local oGuild;
      oGuild = poGuild;

      if oGuild = $
      {
         return $;
      }

      return Send(oGuild, @GetGuildHall);
   }

   HasLeftAGuildTooRecently()
   {
      return (GetTime() < piGuildRejoinTimestamp);
   }

   SetGuildRejoinTime(delayMinutes=0)
   {
      piGuildRejoinTimestamp = GetTime() + (delayMinutes*60);

      return;
   }

   GetAnimation()
   {
      return piAnimation;
   }

   GetGender()
   {
      return piGender;
   }

   GetMaxHealth()
   {
      return Bound(piMax_health-Send(self,@GetStatusEffect,#type=STATUS_DRAINED),20,$);
   }

   GetBaseMaxHealth()
   {
      return piBase_max_health;
   }

   GetLevel()
   {
      return Send(self,@GetBaseMaxHealth);
   }

   GetKillTarget()
   {
      return poKill_target;
   }

   GetTarget()
   {
      return poKill_target;
   }

   SetKillTarget(target=$)
   {
      poKill_target = target;

      return;
   }

   UnboundEnergyTimer()
   {
      ptUnboundEnergy = $;

      Send(self,@LoseUnboundEnergy);

      return;
   }

   HealthTimer()
   {
      local iDifference, i;

      iDifference = bound(Send(self,@GetMaxHealth)*100 - piHealth,-100,100);
      ptHealth = $;
      
      if Send(self,@IsResting)
         AND Send(self,@HasSkill,#num=SKID_MAYURASANA)
      {
         iDifference = Send(Send(SYS,@FindSkillByNum,#num=SKID_MAYURASANA),@ModifyRegeneration,#who=self,#iAmount=iDifference);
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iDifference = Send(Nth(i,2),@ModifyHealthRegenAmount,
                                 #state=Nth(i,3),#regen=iDifference);
      }
      
      if Send(self,@IsUsingA,#class=&WeaponcraftCrest)
      {
         iDifference = iDifference*2;
      }

      % Don't regen below zero.
      if iDifference < 0
         AND piHealth <= 100
      {
         iDifference = 0;
      }

      if iDifference > 0
      {
         Send(self,@GainHealth,#amount=iDifference,#precision=TRUE);
      }
      else
      {
         Send(self,@LoseHealth,#amount=-iDifference,#decay=TRUE,#precision=TRUE);
      }

      return;
   }

   FinishTranceEarly(oTrance=$)
   {
      local i;
      
      foreach i in plEnchantments
      {
         if Nth(i,2) = oTrance
         {
            Post(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));

            if Nth(i,1) <> $
               AND IsTimer(Nth(i,1))
            {
               DeleteTimer(Nth(i,1));
               SetNth(i,1,$);
            }

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                 #type=ENCHANTMENT_PLAYER);
            plEnchantments = DelListElem(plEnchantments,i);
         }
      }

      return;
   }

   EnchantmentTimer(timer = $)
   {
      local i, j, oEnchanter;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) >= ENCHANTMENT_LIST_STATE
               OR IsClass(Nth(i,2),&Boon)
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                 #type=ENCHANTMENT_PLAYER);

            % TODO: i no longer exists at this point?
            % EndEnchantment removing it?
            plEnchantments = DelListElem(plEnchantments,i);
            
            % Also remove from passive improvement list.
            foreach j in plPassiveImprovement
            {
               if First(j) = Nth(i,2)
               {
                  plPassiveImprovement = DelListElem(plPassiveImprovement,j);
               }
            }

            if IsClass(Nth(i,2),&Mirth)
               OR IsClass(Nth(i,2),&Melancholy)
               OR IsClass(Nth(i,2),&Dispassion)
            {
               Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
            }
            else
            {
               Send(self,@ResetPlayerFlagList,#who=self);
            }

            if poOwner <> $
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   PeriodicEnchantmentTimer(timer = $)
   {
      local i ;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            plEnchantments = DelListElem(plEnchantments,i);

            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,
                     #who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=$);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what=$,who=$,time=$,state=$,lastcall=TRUE,
                     addicon=TRUE,ltype=$,bItemCast=FALSE,iSpellPower=0,bSustainedByItem=FALSE)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION OR bSustainedByItem 
      {
         oTimer = $;
      }
      else
      {
         if lastcall
         {
            oTimer = CreateTimer(self,@EnchantmentTimer,time);
         }
         else
         {
            oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
         }
      }

      if state = $
      {
         lNew_enchantment = [oTimer, what, iSpellPower];
      }
      else
      {
         lNew_enchantment = [oTimer, what, state, iSpellPower];
      }

      plEnchantments = Cons(lNew_enchantment,plEnchantments);

      % If we are also the source of the enchantment, add the enchantment
      % to our passive improvement list. ltype has the form:
      % [oSpell,Defensive,Offensive,Resistance]
      if who = self
         AND NOT bItemCast
      {
         plPassiveImprovement = Cons(ltype,plPassiveImprovement);
      }

      if IsClass(what,&Mirth)
         OR IsClass(what,&Melancholy)
         OR IsClass(what,&Dispassion)
      {
         Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
      }
      else
      {
         Send(self,@ResetPlayerFlagList,#who=self);
      }

      if addicon
      {
         Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
      }
      
      if IsClass(what,&Hold)
      {
         Send(self,@SetOverlay,#what=what);
      }
      
      if Send(what,@AltersLightLevel)
      {
         Post(self,@RecalcLight);
      }

      if IsClass(what,&TouchAttackSpell)
      {
         % Jewels of Froz have different light for each touch spell
         Post(self,@UpdateJewelsOfFroz);
      }

      Post(self,@DrawResistances);

      return;
   }

   RemoveAllEnchantments(report=TRUE)
   "Remove all current enchantments and reset the passive improvement list."
   {
      local i;

      foreach i in plEnchantments
      {
         if NOT IsClass(Nth(i,2),&RadiusEnchantment)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      Send(self,@UnReserveAllSpells);
      Send(self,@UnReserveAllSongs);

      plPassiveImprovement = $;

      return;
   }

   RemoveAllRadiusEnchantments(report=TRUE)
   "Remove all current radius enchantments."
   {
      local i;

      foreach i in plRadiusEnchantments
      {
         Send(self,@RemoveRadiusEnchantment,#what=Nth(i,1),
               #iPower=Nth(i,2),#caster=Nth(i,3),#report=report);
      }

      plRadiusEnchantments = $;

      return;
   }

   RemoveAllPersonalEnchantments(report=TRUE,override=FALSE)
   "Remove all current *personal* enchantments and reset "
   "the passive improvement list."
   {
      local i, oSpell, removedSomething;

      removedSomething = FALSE;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsPersonalEnchantment)
            AND ((NOT IsClass(oSpell,&DMSpell)) OR override)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
            removedSomething = TRUE;
         }
      }

      Send(self,@UnReserveAllSpells);

      % Just to be sure, reset the player's flag list.
      % this should remove any excess flags like invis or shadowform.
      Send(self,@ResetPlayerFlagList);
      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=TRUE);

      plPassiveImprovement = $;

      return removedSomething;
   }

   FreezeAllEnchantments()
   "Called when a player logs off."
   {
      local i, iTime;

      if (piFlags & PFLAG_PHASED)
      {
         % Rare case where a user can log off while phased, e.g. system restart
         % Phase already froze the enchantments, so we don't need to do it again

         return;
      }

      foreach i in plEnchantments
      {
         % If we have the spectate enchantment, remove it.
         if IsClass(Nth(i,2),&Spectate)
         {
            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#report=FALSE);
            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);
            plEnchantments = DelListElem(plEnchantments,i);
            Send(self,@ResetPlayerFlagList,#who=self);

            continue;
         }

         if First(i) <> $
         {
            if NOT IsClass(Nth(i,2),&Boon)
            {
               % Convert timer to integer if we have a timer,
               % otherwise log for debugging.
               if IsTimer(First(i))
               {
                  iTime = GetTimeRemaining(First(i));
                  DeleteTimer(First(i));

                  % If it's a negative enchantment, add a bit to the time in
                  % order to prevent people from just "flashing" on and off
                  % to wait out an enchantment and be relatively unhittable.
                  if Send(Nth(i,2),@IsHarmful)
                  {
                     % Time is measured in milliseconds, 3000 = 3 seconds.
                     iTime = iTime + 3000;
                  }
               }
               else
               {
                  % We probably have an integer when we shouldn't have this
                  % here, and we should log it for debugging.
                  % $ values handed when the player logs in.
                  iTime = First(i);
                  Debug(self, " player ",Send(self,@GetTrueName),
                     " called FreezeAllEnchantments with invalid timer for ",
                     Send(Nth(i,2),@GetName), " timer value ",iTime);
               }

               SetNth(i,1,iTime);
            }
         }
      }

      return;
   }

   ReactivateAllEnchantments()
   "Called when a player logs on."
   {
      local i, tTimer, iTime, state;

      foreach i in plEnchantments
      {
         % Phase reactivates enchantments while it is still in plEnchantments
         if IsClass(Nth(i,2),&Phase)
            OR IsClass(Nth(i,2),&Spectate)
         {
            continue;
         }

         if IsClass(Nth(i,2),&Boon) = FALSE
         {
            state = $;
            if length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               state = Nth(i,3);
            }

            iTime = First(i);

            if iTime = $
               OR IsTimer(iTime)
               OR iTime < 1
            {
               % Give them a short timer, and log this for debugging purposes.
               % We include timers since we're not supposed to have one here.
               Debug("Trying to make an invalid timer ",iTime," for ",
                     Send(Nth(i,2),@GetTrueName)," on player ",
                     self,Send(self,@GetTrueName));
               if Send(Nth(i,2),@IsHarmful)
               {
                  iTime = 5000;
               }
               else
               {
                  iTime = 20000;
               }
            }

            if Send(Nth(i,2),@IsPeriodic,#state=state,#who=self)
            {
               SetNth(i,1,CreateTimer(self,@PeriodicEnchantmentTimer,iTime));
            }
            else
            {
               SetNth(i,1,CreateTimer(self,@EnchantmentTimer,iTime));
            }

            Send(Nth(i,2),@RestartEnchantmentEffect,#who=self,#state=state);
         }
      }

      Send(self,@ResetPlayerFlagList,#who=self);

      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments 
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      foreach i in plReservedSpells
      {
         if Send(First(i),@IsIllusion)
         {
            Send(self,@UnReserveSpell,#oSpell=First(i));
         }
      }

      % Kludgy, but oh well.  Not like any other code from this era is
      % exactly well-engineered or even "good", really.
      foreach i in plActive
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&NecromancerAmulet)
         {
            Send(each_obj,@DispelIllusions);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $,report=TRUE)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      foreach i in plReservedSpells
      {
         if Send(First(i),@GetSchool) = school
         {
            Send(self,@UnReserveSpell,#oSpell=First(i));
         }
      }

      return;
   }

   RemoveEnchantment(what = $, report=TRUE, remain=FALSE)
   "If have a current enchantment set by <what>, end it."
   {
      local i,state;

      state = $ ;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if pbLogged_On
               OR IsClass(what,&Phase)
               OR IsClass(what,&Boon)
            {
               if First(i) <> $
               {
                  if IsTimer(First(i))
                  {
                     DeleteTimer(First(i));
                  }
                  SetNth(i,1,$);
               }
            }
            if Length(i) >= ENCHANTMENT_LIST_STATE
               OR IsClass(what,&Boon)
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                  #state=state,#report=report,#remain=remain);

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i);

            if IsClass(what,&Mirth)
               OR IsClass(what,&Melancholy)
               OR IsClass(what,&Dispassion)
            {
               Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
            }
            else
            {
               Send(self,@ResetPlayerFlagList,#who=self);
            }
         }
      }

      % Also remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if First(i) = what
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

%      % Checking reserved spells for skills somehow causes an infinite loop?
%      if IsClass(what,&Spell)
%      {
%         foreach i in plReservedSpells
%         {
%            if First(i) = what
%            {
%               Send(self,@UnReserveSpell,#oSpell=First(i));
%            }
%         }
%      }

      return;
   }

   RemoveEnchantmentClass(class = &Object)
   "If have a current enchantment set by anything in class, end it."
   {
      local i;

      % Remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if IsClass(First(i),class)
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      foreach i in plReservedSpells
      {
         if IsClass(First(i),class)
         {
            Send(self,@UnReserveSpell,#oSpell=First(i));
         }
      }

      % Rest of this now done in Battler.
      propagate;
   }

   GetPassiveImprovementList()
   "Returns the list of currently active, self-cast buffs, that "
   "the player is eligible to improve in passively."
   {
      return plPassiveImprovement;
   }

   SendEnchantmentIcons()
   "Users do this after GC to redisplay their enchantments"
   {
      local i,each_obj;

      foreach i in plEnchantments
      {
         each_obj = Nth(i,2);
         if NOT (IsClass(each_obj,&Seance)
            OR IsClass(each_obj,&IllusionaryWounds))
         {
            Send(self,@ShowAddEnchantment,#what=each_obj,
                  #type=ENCHANTMENT_PLAYER);
         }
      }

      foreach i in plReservedSpells
      {
         Send(self,@ShowAddEnchantment,#what=Nth(i,1),
                                       #type=ENCHANTMENT_PLAYER);
      }

      if ptSecondWind <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSkillByNum,
            #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }
      if ptCrystalizeManaSurgeTimer <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      }

      if Send(Send(SYS,@FindSkillByNum,#num=SKID_SNEAK),@IsSneaking,#who=self)
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSkillByNum,#num=SKID_SNEAK),#type=ENCHANTMENT_PLAYER);
      }
      
      if Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@IsHiding,#who=self)
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSkillByNum,#num=SKID_HIDE),#type=ENCHANTMENT_PLAYER);
      }
      
      if Send(Send(SYS,@FindSkillByNum,#num=SKID_SPY),@IsSpying,#who=self)
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSkillByNum,#num=SKID_SPY),#type=ENCHANTMENT_PLAYER);
      }
      
      If Send(self,@GetStance) <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(self,@GetStance),#type=ENCHANTMENT_PLAYER);
      }

      return;
   }

   AddAttackModifier(what = $)
   "Adds <what> to plAttack_modifiers, which can modify attack "
   "strength and damage."
   {
      plAttack_modifiers = Cons(what,plAttack_modifiers);
      Post(self,@DrawOffense);

      return;
   }

   RemoveAttackModifier(what = $)
   "Removes <what> from plAttack_modifiers."
   {
      local i;

      foreach i in plAttack_modifiers
      {
         if i = what
         {
            plAttack_modifiers = DelListElem(plAttack_modifiers,i);
            Post(self,@DrawOffense);

            return;
         }
      }

      % Karahol's Curse can get here, because it has to remove itself when
      % done, because it doesn't know if it was a normal ending or a
      % user-quit ending.

      return;
   }

   AddDefenseModifier(what = $)
   "Adds <what> to plDefense_modifiers, which can modify defense strength "
   "and damage."
   {
      plDefense_modifiers = Cons(what,plDefense_modifiers);
      Post(self,@DrawDefense);
      Post(self,@DrawArmor);

      return;
   }

   RemoveDefenseModifier(what = $)
   "Removes <what> from plDefense_modifiers."
   {
      local i, bFound;

      bFound = FALSE ;
      foreach i in plDefense_modifiers
      {
         if i = what
         {
            plDefense_modifiers = DelListElem(plDefense_modifiers,i);
            if pbLogged_on
            {
               Post(self,@DrawDefense);
               Post(self,@DrawArmor);
            }
            bFound = TRUE;

            return;
         }
      }

      if NOT bFound
      {
         Debug(self,"Tried to remove defense modifier",what,"but not in list",
               plDefense_modifiers);
      }

      return;
   }

   %
   % Squelch functions.
   %

   SquelchPlayer(value=$,type=PFLAG2_SQUELCHED_ALL)
   "Sets if a player can communicate or not.  Toggles condition by default."
   {
      local bSquelched;

      bSquelched = value;

      if bSquelched = $
      {
         % Toggle the current state.
         bSquelched = NOT Send(self,@CheckPlayerFlag,#flag=type,#flagset=2);
      }

      Send(self,@SetPlayerFlag,#flag=type,#value=bSquelched,#flagset=2);

      return bSquelched;
   }

   TrySay()
   "Called when user wants to say something. Return TRUE/FALSE.  "
   "If this returns FALSE, it will also block broadcasts and guild sends."
   {
      if piFlags2 & PFLAG2_SQUELCHED_SAYS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      return TRUE;
   }

   TryBroadcast()
   "Called when the user wants to broadcast a string.  Return True/False, "
   "and use some mana too."
   {
      local iCost;

      if piFlags2 & PFLAG2_SQUELCHED_BCAST
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      if NOT Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
         AND NOT IsClass(self,&DM)
      {
         iCost = piMana * Send(SETTINGS_OBJECT,@GetBroadcastManaCost) / 100;
         if piMana < iCost
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_broadcast);

            return FALSE;
         }
         Send(self,@LoseMana,#amount=iCost);
      }

      return TRUE;
   }

   TrySayGroup(users=$)
   "Called when the user wants to say a string to a list of people.  Return True/False, "
   "and use some mana too."
   {
      if piFlags2 & PFLAG2_SQUELCHED_TELLS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      if NOT IsClass(self,&DM)
      {
         Send(self,@LoseMana,#amount=1);
      }

      return TRUE;
   }

   %
   % End squelch functions.
   %

   CheckPosition(what=$,type=$,space=0)
   {
      local i, iSpace;

      if space = 0 OR type = $ OR what = $
      {
         return FALSE;
      }

      iSpace = space;
      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & type
         {
            iSpace = iSpace - Send(i,@GetItemUseAmount);
         }
      }

      if iSpace < Send(what,@GetItemUseAmount)
      {
         if IsClass(what,&Token) OR IsClass(what,&Totem)
         {
            return FALSE;
         }

         % These unequip amongst themselves automatically.
         if IsClass(what,&DefenseModifier)
            OR IsClass(what,&Gauntlet)
         {
            return TRUE;
         }

         if type = ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full_hands);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full);
         }

         return FALSE;
      }

      return TRUE;
   }

   TryUseItem(what = $)
   {
      local i,iSpace,iUse_type;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      if (piFlags & PFLAG_MORPHED)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return FALSE;
      }

      if IsClass(what,&ReagentBag)
      {
         if Send(what,@GetReagentBagContents) = $
         {
            Send(self,@MsgSendUser,#message_rsc=player_regbag_empty);

            return FALSE;
         }

         Send(self,@UserObjectContents,#what=what);

         return TRUE;
      }

      iUse_type = Send(what,@GetItemUseType);

      if iUse_type & ITEM_SINGLE_USE
      {
         return Send(self,@TryApplyItem,#what=what,#apply_on=self);
      }

      if iUse_type & ITEM_BROKEN
      {
         Send(self,@MsgSendUser,#message_rsc=player_use_broken,
               #parm1=Send(what,@GetDef),
               #parm2=Send(what,@GetName));

         return FALSE;
      }

      if iUse_type & ITEM_CANT_USE
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(what,@ReqUse,#what=self)
      {
         return FALSE;
      }

      % make sure nothing in room disallows
      if poOwner <> $
         AND NOT Send(poOwner,@ReqSomethingUse,#what=self,#use_item=what)
      {
         return FALSE;
      }

      % make sure not already using or something using disallows
      foreach i in plUsing
      {
         if i = what
         {
            Send(self,@MsgSendUser,#message_rsc=player_using_already);

            return FALSE;
         }

         if NOT Send(i,@ReqUseSomething,#what=what)
         {
            return FALSE;
         }
      }

      if (iUse_type & ITEM_USE_HAND)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HAND,#space=viHand_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_BODY)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_BODY,#space=viBody_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_NECK)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_NECK,#space=viNeck_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_AMULET)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_AMULET,#space=viAmulet_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_THROAT)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_THROAT,#space=viThroat_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_QUIVER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_QUIVER,#space=viQuiver_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_FINGER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_FINGER,#space=viFinger_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_GAUNTLET)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_GAUNTLET,#space=viGauntlet_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_HEAD)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HEAD,#space=viHead_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_LEGS)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_LEGS,#space=viLeg_space)
      {
         return FALSE;
      }
      
      if NOT Send(self,@RaceCanUseItemType,#type=iUse_type)
      {
         return FALSE;
      }

      plUsing = Cons(what,plUsing);
      Send(self,@NewUsing,#what=what);
      Send(what,@NewUsed,#what=self);

      if poOwner
      {
         Send(poOwner,@SomethingUsed,#what=self,#use_item=what);
      }

      Send(self,@ResetPlayerFlagList);
      Post(self,@DrawResistances);

      return TRUE;
   }

   TryUnuseItem(what = $)
   {
      local bFound, i;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      bFound = FALSE;

      %check and see if item disallows
      foreach i in plUsing
      {
         if i = what
         {
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         % This can happen if TryUnuseItem is called in, for example,
         % a ring of invisibility when you log off.
         return FALSE;
      }

      if Send(what,@ReqUnuse)
      {
         Post(self,@ResetPlayerFlagList);

         return Send(self,@UnuseItem,#what=what);
      }

      return FALSE;
   }

   UnuseItem(what = $, Recalibrate = FALSE)
   {
      local i;

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            Send(self,@NewUnusing,#what=what);
            
            if Recalibrate
            {
               Send(what,@NewUnused,#what=self,#Recalibrate=TRUE);
            }
            else
            {
               Send(what,@NewUnused,#what=self);
            }

            if pbLogged_on
            {
               Post(self,@DrawResistances);
            }

            return TRUE;
         }
      }

      Send(self,@MsgSendUser,#message_rsc=player_not_using);

      return FALSE;
   }

   TryApplyItem(what = $,apply_on = $)
   {
      local i,iUse_type;

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
               #parm1=Send(what,@GetName));

         return FALSE;
      }

      iUse_type = Send(what,@GetItemUseType);
      if iUse_type <> ITEM_SINGLE_USE
      {
         if iUse_type = ITEM_BROKEN
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_broken,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_apply,
                  #parm1=Send(what,@GetIndef),#parm2=Send(what,@GetName));
         }

         % Error
         return FALSE;
      }

      % make sure nothing in room disallows
      if NOT Send(poOwner,@ReqSomethingApply,#what=self,#use_item=what,#apply_on=apply_on)
      {
         return FALSE;
      }

      if Send(what,@ReqNewApply,#what=self,#apply_on=apply_on)
      {
         Send(what,@NewApplied,#what=self,#apply_on=apply_on);
         Send(poOwner,@SomethingApplied,#what=self,#use_item=what,#apply_on=apply_on);
      }

      Send(self,@ResetPlayerFlagList);

      return TRUE;
   }

   CanAdvance()
   {
      return TRUE;
   }

   AllowPlayerAttack(victim=$,stroke_obj=$,use_weapon=$,report=TRUE,
                     actual=TRUE,minion=FALSE,oMinionRoom=$)
   "Will not let a person attack someone who isn't pkill_enabled."
   "Will not let a person who isn't pkill_enabled attack another person."
   {
      local oRoom, oGuild, oVictimGuild;

      % Default location to check is where we are.
      oRoom = poOwner;

      % If the victim is in a room, then check that location instead.  This
      % allows distance attacks (like wall spells) to work properly.
      if victim <> $
         AND Send(victim,@GetOwner) <> poOwner
      {
         if (minion
            AND oMinionRoom <> $)
         {
            oRoom = oMinionRoom;
         }
         else
         {
            oRoom = Send(victim,@GetOwner);
         }
      }

      % No attacking logged out players under any circumstances
      if Send(victim,@GetOwner) = $
      {
         return FALSE;
      }

      % Can always attack Escaped Convict regardless of room
      if IsClass(victim,&EscapedConvict)
      {
         return TRUE;
      }

      % But Escaped Convict can also fight back!
      if IsClass(self,&EscapedConvict)
      {
         return TRUE;
      }
      
      % No cross ladder fighting.
      if IsClass(victim,&Player)
         AND Send(victim,@GetLadderID) <> Send(self,@GetLadderID)
      {
         return FALSE;
      }

      % Make sure room allows the attack. Check if room has
      % special combat affects.
      if actual
         AND NOT Send(oRoom,@ReqSomethingAttack,#what=self,#victim=victim,
                     #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                     #report=report,#actual=actual)
      {
         return FALSE;
      }

      % Don't halo non-attackables in guild_pk_only zones (typically an
      % unguilded outlaw). Necessary because it just looks confusing
      if NOT actual
         AND NOT Send(oRoom,@AllowGuildAttack,#what=self,#victim=victim)
      {
         return FALSE;
      }

      % If we're in an arena and it let us attack, then it's a legal attack.
      if Send(oRoom,@IsArena)
      {
         return TRUE;
      }

      if Send(victim,@GetMaster) = self
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=player_own_minion);
         }

         return FALSE;
      }
      
      if Send(oRoom,@GetChaosZone)
      {
         return TRUE;
      }

      % Frenzies!  Anything goes if allowed by the room!
      if Send(SYS,@GetChaosNight)
      {
         if Send(Send(SYS,@GetWarEvent),@IsActive)
         {
            % If there's a war event going, disallow attacks between teammates.
            if Send(Send(SYS,@GetWarEvent),@IsSameSide,#player1=self,#player2=victim)
               AND NOT Send(Send(SYS,@GetWarEvent),@CanAttackAllies)
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }

               return FALSE;
            }
         }

         return TRUE;
      }

      % Check for guildmates and allies
      if IsClass(victim,&User)
         AND victim <> self
      {
         oVictimGuild = Send(victim,@GetGuild);
         oGuild = poGuild;
         if oVictimGuild <> $
            AND oGuild <> $
            AND NOT IsClass(oGuild,&NecromancerGuild)
            AND (oGuild = oVictimGuild
               OR Send(oGuild,@IsAlly,#otherguild=oVictimGuild))
         {
            if report
            {
               if oGuild = oVictimGuild
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_guildmate,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
               if Send(oGuild,@IsAlly,#otherguild=oVictimGuild)
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
            }

            return FALSE;
         }
      }

      % Check for temporary safety flag.
      if IsClass(victim,&User)
         AND ((piFlags & PFLAG_TEMPSAFE)
            OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_TEMPSAFE))
         AND victim <> self
      {
         if NOT IsClass(oRoom,&GuildHall)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                     #parm1=Send(victim,@GetDef),
                     #parm2=Send(victim,@GetName));
            }
            return FALSE;
         }
      }
      
      if IsClass(victim,&Player)
         AND ((Send(self,@HasSwordOfTheHunt)
         AND Send(victim,@IsUsingA,#class=&NecromancerAmulet))
         OR (Send(self,@IsUsingA,#class=&NecromancerAmulet)
            AND Send(victim,@HasSwordOfTheHunt)))
      {
         % Can hunters and necromancers fight each other?
         if Send(SETTINGS_OBJECT,@GetNecroAndHunterPvPOn)
         {
            return TRUE;
         }
      }

      % Can always attack mortal event characters.
      if IsClass(victim,&DM)
         AND Send(victim,@IsEventCharacter)
         AND NOT Send(victim,@PlayerIsImmortal)
      {
         return TRUE;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=cannot_attack_phased_self_rsc);
         }
         return FALSE;
      }

      if IsClass(victim,&User)
         AND Send(victim,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      if IsClass(victim,&Monster)
      {
         if IsClass(victim,&Reflection)
            OR IsClass(victim,&EvilTwin)
            OR Send(victim,@GetMaster) <> $
         {
            if NOT (piFlags & PFLAG_PKILL_ENABLE)
            {
               if report
               {
                  Send(self,@MsgSendUser,
                        #message_rsc=player_cant_hit_newbie_minion);
               }

               return FALSE;
            }

            % Check status and safety against the owner of the minion.
            if NOT IsClass(oRoom,&GuildHall)
            {
               if NOT Send(self,@AllowPlayerAttack,
                           #victim=Send(victim,@GetMaster),
                           #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                           #report=report,#actual=actual,#minion=TRUE,
                           #oMinionRoom=oRoom)
               {
                  return FALSE;
               }
            }
         }

         if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                     #parm1=Send(victim,@GetName));
            }

            return FALSE;
         }

         % No attacking pets on Sacred Haven
         if NOT Send(SYS,@IsPKAllowed)
            AND Send(victim,@GetMaster) <> $
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                    #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
            }

            return FALSE;
         }
      }
      else
      {
         % Not a monster; is a player.

         % No player attacks on Sacred Haven, but allow DM attacks for events.
         if NOT Send(SYS,@IsPKAllowed)
            AND NOT IsClass(victim,&DM)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safe_server);
            }

            return FALSE;
         }

         % This prevents attacks on immortal DMs.
         if NOT Send(victim,@IsLikelyVictim)
         {
            return FALSE;
         }

         if NOT Send(oRoom,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
         {
            if NOT (piFlags & PFLAG_PKILL_ENABLE)
            {
               % A newbie (someone below GetPKillEnableHP) tried to attack
               % another player! note that this does not affect murderers
               % who have been knocked below this level by angry retributers.

               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_cant_hit_newbie);
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }
            
               return FALSE;
            }

            if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
            {
               % The target is a newbie. Murderers are perfectly attackable
               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                           #parm1=Send(victim,@GetDef),
                           #parm2=Send(victim,@GetName));
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }

               return FALSE;
            }
         }
      }

      % Truce itself returns TRUE, not counting as an attack. 
      % Truce will only block actual attacks between two players who 
      % are both Truced.
      if stroke_obj <> $
         AND IsClass(stroke_obj,&Truce)
      {
         return TRUE;
      }
      else
      {
         if (Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Truce))
         {
            if (IsClass(victim,&Monster)
               OR (IsClass(victim,&User)
                  AND Send(victim,@IsAffectedByRadiusEnchantment,
                           #byClass=&Truce)))
               AND actual
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=player_truced);
               }

               return FALSE;
            }
         }
      }

      if IsClass(oRoom,&GuildHall)
      {
         return TRUE;
      }

      % Finally, check status and safety.
      if NOT Send(self,@CheckStatusAndSafety,#victim=victim,
                  #report=report,#actual=actual,#minion=minion)
      {
         return FALSE;
      }

      % Stop any rescue attempts if the user makes an attack.
      if ptRescue <> $
         AND actual
      {
         Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue);
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return TRUE;
   }

   CheckStatusAndSafety(victim=$,report=TRUE,actual=TRUE,minion=FALSE)
   "CF_SAFETY_OFF prevents accidental attacks. You can always successfully "
   "hit a murderer or outlaw, though."
   {
      local oEnemyGuild, oSoldierShield;

      % Don't care about monsters.
      % And, free attacks on token holders.
      if IsClass(victim,&Monster)
         OR (Send(victim,@FindUsing,#class=&Token) <> $)
      {
         % Unless they're factioned.
         if NOT ISClass(victim,&Monster)
            AND NOT Send(self,@CheckFactionAttack,#what=victim,#report=report)
         {
            return FALSE;
         }

         return TRUE;
      }

      % We don't penalize you for trying to hurt yourself.
      % Also don't care about Morphed or Anonymous players.
      if (victim = self)
         OR (IsClass(victim,&Player)
            AND (Send(victim,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_MORPHED)))
      {
         return TRUE;
      }
      
      % No penalties for chaos zone battles
      if poOwner <> $
         AND Send(victim,@GetOwner) <> $
         AND IsClass(poOwner,&Room)
         AND IsClass(Send(victim,@GetOwner),&Room)
         AND Send(poOwner,@GetChaosZone)
         AND Send(Send(victim,@GetOwner),@GetChaosZone)
      {
         return TRUE;
      }

      oEnemyGuild = Send(victim,@GetGuild);
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      % Check for enemy guild or faction soldier fighting - If attacking a (mutual)
      %  enemy, then they can whack on each other freely, without outlaw penalty
      %  or faction loss.
      if (poGuild <> $
            AND oEnemyGuild <> $
            AND Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
         OR (oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#who=victim,#what=self,
                      #damage=FALSE))
      {
         % Okay, attack is against a player, so record the time
         if actual = TRUE
         {
            piTimeAttackedPlayer = GetTime();
         }

         return TRUE;
      }

      % Check to see if we deserve to be an outlaw.
      if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         AND NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
      {
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
         {
            % If your opponent is not a murderer or outlaw, you must
            % have your 'safety' off to attack anyone.
            if report
            {
               if IsClass(self,&Guest)
               {
                  Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                       #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  if minion
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safety_caught_minion,
                           #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                           #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
                  }
               }
            }

            return FALSE;
         }
         else
         {
            if NOT (piFlags & PFLAG_MURDERER)
               AND NOT (piFlags & PFLAG_OUTLAW)
               AND actual = TRUE
            {
               % attacking someone who is without fault is cause to
               % gain the outlaw flag.
               if minion
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor_minion,
                        #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor);
               }
               Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=TRUE);
               Send(self,@EvaluatePKStatus,#dbug=TRUE);
            }
         }
      }

      % Check for faction loss.  Handles appropriate conditions.
      if actual = TRUE
         AND NOT Send(self,@CheckFactionAttack,#what=victim,#report=report)
      {
         return FALSE;
      }

      % Okay, attack is against a player, so record the time
      if actual = TRUE
      {
         piTimeAttackedPlayer = GetTime();
      }

      return TRUE;
   }

   CheckFactionAttack(what=$,report=TRUE)
   "Checks if you are attacking something in the same faction as you are. "
   "Boots you out of your faction if you attack an innocent or a monster. "
   "Safety will catch a bad attack, however."
   {
      local bBooted, rMessage;

      % If attacking nothing, or faction is neutral, or attacking self
      %   or in the Arena, or during a Frenzy, don't go any further.
      if what = $
         OR piFaction = FACTION_NEUTRAL
         OR what = self
         OR (poOwner <> $ AND Send(poOwner,@IsArena))
         OR Send(SYS,@GetChaosNight)
      {
         return TRUE;
      }

      bBooted = FALSE;

      % If faction loss is disabled, then attacking a user never boots you
      if Send(SYS, @GetServerFlag, #flag = SERVER_FLAG_DISABLE_FACTION_LOSS)
         AND IsClass(what, &User) 
      {
         return TRUE;
      }

      % Checking for faction alignment. If you attack something of your
      % own faction, you get busted!
      if (Send(what,@GetFaction) = piFaction)
      {
         % Attacks vs. Outlaws, Murderers are not punishable by booting,
         % so just return. Also, attacks vs. anonymous or morphed people
         % are not punishable.
         if (IsClass(what,&User))
            AND (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
         {
            return TRUE;
         }

         bBooted = TRUE;
         rMessage = player_faction_attacked;
      }

      % Preying on non-intriguing, white-named newbies boots ya, too.
      if IsClass(what,&User)
         AND NOT Send(what,@PlayerIsIntriguing)
         AND NOT (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW))
      {
         bBooted = TRUE;
         rMessage = player_non_intriguing_attacked;
      }

      if bBooted
      {
         % Check for safety before booting.
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }

            return FALSE;
         }
      }

      return TRUE;
   }

   GetLastPlayerAttackTime()
   "Returns the last time the player attacked another player."
   {
      return piTimeAttackedPlayer;
   }

   CanHelpPlayer()
   "Checks to see if can be affected by spells cast by angeled characters."
   {
      if (piTimeAttackedPlayer + ATTACKED_PLAYER_WAIT) > GetTime()
         AND NOT Send(SYS,@GetChaosNight)
      {
         return FALSE;
      }

      return TRUE;
   }

   TryCleaveAttack(what = $,use_weapon = $,stroke_obj = $)
   {
      local i, each_target, bSwungAtLeastOnce, iSwingCount;
      
      bSwungAtLeastOnce = FALSE;
      iSwingCount = 0;

      Send(self,@MsgSendUser,#message_rsc=attempting_cleave_msg);

      if poOwner <> $
         AND IsClass(poOwner,&Room)
         AND Send(self,@IsOkayAttackTime,#stroke_obj=stroke_obj)
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_target = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_target,&Battler)
               AND each_target <> self
            {
               if Send(self,@SquaredFineDistanceTo3D,#what=each_target) <= Send(use_weapon,@GetRange) * Send(use_weapon,@GetRange)
               {
                  Send(self,@ClearAttackTimer);
                  if Send(self,@TryAttack,#what=each_target,#use_weapon=use_weapon,#stroke_obj=stroke_obj,#bCleaving=TRUE)
                  {
                     bSwungAtLeastOnce = TRUE;
                     ++iSwingCount;
                  }
               }
            }
            
            if iSwingCount >= Send(SETTINGS_OBJECT,@GetMaxCleaveAttacks)
            {
               return bSwungAtLeastOnce;
            }
         }
      }

      if NOT bSwungAtLeastOnce
      {
         Send(self,@MsgSendUser,#message_rsc=no_enemies_in_range_msg);
      }

      return bSwungAtLeastOnce;
   }

   TryAttack(what = $,use_weapon = $,stroke_obj=$,bCleaving = FALSE,bAdditionalAttack = FALSE)
   {
      local i, iRange, lWindsState, lSandstormState;

      % Can't target self.
      if what = self
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_target_self);
         
         return FALSE;
      }

      % Check attack time.
      if NOT Send(self,@IsOkayAttackTime,#stroke_obj=stroke_obj,#bAdditionalAttack=bAdditionalAttack)
         AND NOT IsClass(stroke_obj,&Throw)
      {
         return FALSE;
      }

      % Is it in the same room?
      if poOwner <> Send(what,@GetOwner) 
      {
         return FALSE;
      }

      % Holding a token?  Then don't let them attack
      if send(self,@FindHolding,#class=&Token) <> $
      {
         return FALSE;
      }
      
      if IsClass(what,&Monster)
         AND Send(what,@GetMaster) <> $
         AND IsClass(Send(what,@GetMaster),&Player)
         AND Send(Send(what,@GetMaster),@IsInCannotInteractMode)
      {
         % Monsters whose masters are phased out cannot be attacked
         Send(self,@MsgSendUser,#message_rsc=master_is_phased_out_cannot_attack);
         return FALSE;
      }
      
      if IsClass(what,&Player)
         AND Send(what,@GetLadderID) <> Send(self,@GetLadderID)
      {
         Send(self,@MsgSendUser,#message_rsc=player_out_of_ladder,#parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName));
         return FALSE;
      }

      % If we have minions, see if they can attack too
      Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);

      % Can pay costs?  Only check for skills, spells have already been cast.
      if IsClass(stroke_obj,&Skill)
         AND NOT Send(stroke_obj,@CanPayCosts,#who=self,#oTarget=what)
      {
         return FALSE;
      }

      % Deny attack if no line of sight
      if NOT bCleaving
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);
         return FALSE;
      }

      % Send to the STROKE to get the range; unarmed attacks have ranges too
      iRange = Send(stroke_obj,@GetRange,#weapon_used=use_weapon);

      % How big are enemies?
      if IsClass(what,&Battler)
      {
         iRange = iRange + Send(what,@GetEnemyRangeBonus);
      }

      % A little fudge factor to account for lag drift, etc.
      %  Don't fudge for ranged weapons.
      if IsClass(what,&User) AND Send(what,@HasMovedRecently)
         AND (use_weapon <> $ AND NOT IsClass(use_weapon,&RangedWeapon))
      {
         iRange = iRange + RANGE_MOVEMENT_BONUS;
      }

      if NOT bCleaving
         AND NOT Send(self,@TargetWithinSightAndRange,#oTarget=what,#iRange=iRange,
                  #use_weapon=use_weapon,#stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      % Special case assassin's daggers
      if use_weapon <> $
         AND IsClass(use_weapon,&BlackDagger)
         AND IsClass(stroke_obj,&Stroke)
      {
         % Let the assassin's game handle it
         return Send(Send(SYS,@GetAssassinGame),@TryAssassinAttack,
                     #attacker=self,#target=what,#dagger_obj=use_weapon);
      }

      if IsClass(what,&Monster)
      {
         % Check if its a non hittable monster
         if NOT Send(what,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                     #use_weapon=use_weapon)
         {
            return FALSE;
         }
         else
         {
            if NOT Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
            {
               % Tell the monster this is a valid attack.
               Send(what,@ValidAttack,#who=self);
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                     #parm1=Send(what,@GetName));

               return FALSE;
            }
         }
      }

      % Checking for legal PK attack here.
      if NOT Send(self,@AllowPlayerAttack,#victim=what,#stroke_obj=stroke_obj,
                  #use_weapon=use_weapon)
      {
         return FALSE;
      }

      % If this attack initiates pvp, notify victim (combatants maybe?) 
      % initially, but then not again until PVP_NOTIFY_DECAY has passed
      
      if IsClass(what,&User) 
         AND Send(what, @GetLastPvpWarned) < GetTime() - PVP_NOTIFY_DECAY
      {
         Send(what,@DoPvpNotify);
      }
      
      % Special stroke stuff 
      if NOT Send(stroke_obj,@CheckSpecial,#who=self,#victim=what)
      {
         return FALSE;
      }

      % Okay, checking is done, attack is okay.  Do the animation thing.
      if NOT Send(stroke_obj,@CheckWeaponAndDoAnimation,#who=self,
                  #weapon_used=use_weapon,#victim=what)
      {
         return FALSE;
      }

      % Switching targets?
      % Do this before paying skill costs, otherwise projectiles
      % will try to find our "kill target" and fail.
      if poKill_target <> what
      {
         Send(self,@ResetGainFlags);
         poKill_target = what;
      }

      % Pay costs here. Only check skills, because spells are already cast.
      if IsClass(stroke_obj,&Skill)
      {
         Send(stroke_obj,@PayCosts,#who=self);
      }

      % Special case:  Ranged weapons in windy room.
      %  Do this after paying the costs so that the arrow is used.
      if use_weapon <> $
         AND (IsClass(use_weapon,&RangedWeapon)
              OR IsClass(stroke_obj,&Throw))
      {
         lWindsState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Winds);
         lSandStormState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                                 #byClass=&SandStorm);

         if lWindsState <> $
            AND Send(Nth(lWindsState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lWindsState,2))
         {
            return FALSE;
         }

         if lSandStormState <> $
            AND Send(Nth(lSandStormState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lSandStormState,2))
         {
            return FALSE;
         }
      }

      Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
            #use_weapon=use_weapon,#stroke_obj=stroke_obj);

      % Record the swing for potential advancement.
      if Send(what,@CanPlayerAdvanceOnMe)         
      {
         % We got another swing in, so increment that.
         Send(self,@SwingWeapon,#times=1,#stroke_obj=stroke_obj);
      }

      % Give offensive buffs a small chance to improve each swing!
      foreach i in plPassiveImprovement
      {
         if Nth(i,3) AND random(1,50) = 50
         {
            Send(First(i),@ImproveAbility,#who=self,#target=what);
         }
      }
      foreach i in plReservedSpells
      {
         if Send(Nth(i,1),@IsOffensive)
            AND Random(1,100) = 100
         {
            Send(First(i),@ImproveAbility,#who=self,#target=what);
         }
      }
         
      if poStance <> $
         AND IsClass(poStance,&LightAttackStance)
         AND NOT bAdditionalAttack
         AND stroke_obj <> $
         AND (IsClass(stroke_obj,&Stab)
            OR IsClass(stroke_obj,&Slash))
      {
         plDelayedAdditionalAttacks = Cons([CreateTimer(self,@CheckDelayedAdditionalAttacks,450),what,use_weapon,stroke_obj],plDelayedAdditionalAttacks);
      }
      
      if NOT bAdditionalAttack
         AND Send(self,@HasSkill,#num=SKID_FLICKER_STRIKE)
         AND Send(self,@GetWeapon) = $
      {
         if poStance <> $
            AND IsClass(poStance,&ShadowstepStance)
         {
            plDelayedAdditionalAttacks = Cons([CreateTimer(self,@CheckDelayedAdditionalAttacks,450),what,use_weapon,stroke_obj],plDelayedAdditionalAttacks);
         }
         else
         {
            plDelayedAdditionalAttacks = Cons([CreateTimer(self,@CheckDelayedAdditionalAttacks,450),what,use_weapon,stroke_obj],plDelayedAdditionalAttacks);
         }
      }

      if poStance <> $
         AND IsClass(poStance,&ShadowstepStance)
         AND NOT bAdditionalAttack
         AND Send(self,@GetWeapon) = $
      {
         if Send(self,@HasSkill,#num=SKID_FLICKER_STRIKE)
         {
            plDelayedAdditionalAttacks = Cons([CreateTimer(self,@CheckDelayedAdditionalAttacks,450),what,use_weapon,stroke_obj],plDelayedAdditionalAttacks);
         }
         else
         {
            plDelayedAdditionalAttacks = Cons([CreateTimer(self,@CheckDelayedAdditionalAttacks,450),what,use_weapon,stroke_obj],plDelayedAdditionalAttacks);
         }
      }

      propagate;
   }

   CheckDelayedAdditionalAttacks(timer=$)
   {
      local i;
      
      foreach i in plDelayedAdditionalAttacks
      {
         if timer=First(i)
         {
            SetNth(i,1,$);
            Post(self,@ClearAttackTimer);
            Post(self,@TryAttack,#what=Nth(i,2),#use_weapon=Nth(i,3),#stroke_obj=Nth(i,4),#bAdditionalAttack=TRUE);
            SetNth(i,2,$);
            SetNth(i,3,$);
            SetNth(i,4,$);
            plDelayedAdditionalAttacks = DelListElem(plDelayedAdditionalAttacks,i);
         }
      }
      return;
   }

   ClearDelayedAdditionalAttacks()
   {
      local i;
      
      foreach i in plDelayedAdditionalAttacks
      {
         DeleteTimer(Nth(i,1));
         SetNth(i,1,$);
         SetNth(i,2,$);
         SetNth(i,3,$);
         SetNth(i,4,$);
      }

      plDelayedAdditionalAttacks = $;

      return;
   }

   % Determines if target is within attacking range, and within sight.
   % iRange=$ means there's no range check.
   TargetWithinSightAndRange(oTarget=$,iRange=$,use_weapon=$,stroke_obj=$)
   {
      local iSquareRange, iDist, oTargetOwner, oFinalTarget, iAngle,
            iRow, iCol, iTargetRow, iTargetCol, oHammerWielding, iEnemyRangeBonus;

      oTargetOwner = Send(oTarget,@GetOwner);

      % We are always in range of ourselves or anything we carry.
      if oTarget = self
         OR oTargetOwner = self
      {
         return TRUE;
      }

      oFinalTarget = oTarget;
      iEnemyRangeBonus = 0;
      if IsClass(oFinalTarget,&Battler)
      {
         iEnemyRangeBonus = Send(oFinalTarget,@GetEnemyRangeBonus);
      }

      % Strange case of us targeting something that someone else is holding.
      % This cannot be owned by us, since we already checked that.
      if oTargetOwner <> $
         AND IsClass(oTargetOwner,&Battler)
      {
         oFinalTarget = oTargetOwner;
         oTargetOwner = Send(oFinalTarget,@GetOwner);
      }

      % If we don't share the same owner, then we're not in range.
      if poOwner <> oTargetOwner
      {
         return FALSE;
      }
      
      if poStance <> $
         AND IsClass(poStance,&ShadowstepStance)
      {
         if Send(Send(SYS,@FindSkillByNum,#num=SKID_SHADOWSTEP),@DoTeleport,#who=self,#lTargets=[oFinalTarget])
         {
            return TRUE;
         }
      }

      iDist = Send(self,@SquaredFineDistanceTo3D,#what=oFinalTarget);

      % See if target is within range, if we provided a range.
      if iRange <> $
      {
         iSquareRange = iRange;
         iSquareRange = iSquareRange * iSquareRange;

         if iDist > iSquareRange
         {
            % Check whether we can leap attack with a hammer between range 2 and 4
            if iDist <= ((4 * FINENESS)+iEnemyRangeBonus) * ((4 * FINENESS)+iEnemyRangeBonus)
               AND IsClass(stroke_obj,&Slash)
               AND (Send(self,@IsUsingA,#class=&Hammer)
                  OR Send(self,@IsUsingA,#class=&SpiritualHammer))
               AND Send(self,@GetSkillAbility,#skill_num=SKID_PROFICIENCY_HAMMER) > 0
               AND Send(self,@HasMasteredThisSkill,#num=SKID_PROFICIENCY_HAMMER)
            {
               oHammerWielding = Send(SYS,@FindSkillByNum,#num=SKID_PROFICIENCY_HAMMER);
               
               if Send(oHammerWielding,@CanPayLeapCost,#who=self,#oTarget=oFinalTarget)
               {
                  if Send(oHammerWielding,@DoLeap,#who=self,#oTarget=oFinalTarget)
                  {
                     return TRUE;
                  }
               }
            }
            if NOT IsClass(stroke_obj,&Throw)
               AND Send(self,@GetSkillAbility,#skill_num=SKID_THROW) > 0
            {
               Post(Send(SYS,@FindSkillByNum,#num=SKID_THROW),@TryThrow,
                     #who=self,#what=oTarget,#use_weapon=use_weapon);
               return FALSE;
            }

            Send(self,@SendAttackOutOfRangeMessage,#what=oFinalTarget,
                 #use_weapon=use_weapon,#stroke_obj=stroke_obj);

            return FALSE;
         }
      }

      % See if target is in a reasonable viewing area.
      % Only applies to weapon strokes and single-target spells.
      if IsClass(oFinalTarget,&Battler)
         AND stroke_obj <> $
         AND (IsClass(stroke_obj,&Stroke)
            OR (IsClass(stroke_obj,&Spell)
               AND Send(stroke_obj,@GetNumSpellTargets) = 1))
      {
         if iDist > 1
            AND NOT LineOfSightView(Send(self,@GetAngle), piRow, piCol, piFine_row,
                        piFine_col, Send(oTarget,@GetRow), Send(oTarget,@GetCol),
                        Send(oTarget,@GetFineRow), Send(oTarget,@GetFineCol))
         {
            if iDist > 2
               AND IsClass(oFinalTarget,&Player)
               AND Send(self,@CheckLog)
            {
               Debug("ALERT! ",Send(self,@GetTrueName),self," at "
                     "[",piRow,piCol,"] and angle ",Send(self,@GetAngle),
                     " tried to hit ", Send(oFinalTarget,@GetTrueName),
                     oFinalTarget," at [",Send(oTarget,@GetRow),
                     Send(oTarget,@GetCol),"] that was behind them.");
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);

            return FALSE;
         }
      }

      return TRUE;
   }

   % This returns the battler's ability to-hit.  Ranges from 1 to 1000
   GetOffense(what = $, stroke_obj=$)
   {
      local i, oWeapon, iStroke, iProficiency, iOffense,
            oMonster, lRadiusState, oAmmo, iChilled;

      oWeapon = $;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iOffense = Send(oMonster,@GetOffense,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         % A player's offense is based on his stroke (basic),
         % proficiency (advanced) skills, aim and max hps.
         oWeapon = Send(self,@GetWeapon);

         if stroke_obj <> $
            AND IsClass(stroke_obj,&Throw)
         {
            oAmmo = Send(stroke_obj,@FindLikelyAmmo,#who=self);

            if oAmmo <> $
            {
               iStroke = Send(oAmmo,@GetStroke,#who=self);
               iProficiency = Send(oAmmo,@GetProf,#who=self);
            }
            else
            {
               % We already know we have ammo, but let's be careful and cover this case.
               iStroke = 0;
               iProficiency = 0;
            }            
         }
         else
         {
            if oWeapon <> $
            {
               % Get weapon's numbers.
               iStroke = Send(oWeapon,@GetStroke,#who=self);
               iProficiency = Send(oWeapon,@GetProf,#who=self);
            }
            else
            {
               % Unarmed
               iStroke = Send(self,@GetSkillAbility,#skill_num=SKID_PUNCH) + Send(self,@GetSkillAbility,#skill_num=SKID_WAY_OF_THE_SERPENT);
               iProficiency = Send(self,@GetSkillAbility,#skill_num=SKID_BRAWLING);
               if what <> $
               {
                  Send(Send(SYS,@FindSkillByNum,#num=SKID_WAY_OF_THE_SERPENT),@ImproveAbility,#who=self);
               }
            }
         }

         iOffense = (iStroke*2) + (iProficiency*2) + 
               (200 * piBase_Max_Health)/(100 + Send(self,@GetStamina));

         if oWeapon <> $
         {
            iOffense = Send(oWeapon,@ModifyHitRoll,#target=what,
                  #hit_roll=iOffense);
         }
      }

      % List of items and spells that affect chance-to-hit
      foreach i in plAttack_modifiers
      {
         iOffense = Send(i,@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#stroke_obj=stroke_obj);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Dispassion)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Dispassion);
         iOffense = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#lRadiusState=lRadiusState);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Mirth);
         iOffense = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#lRadiusState=lRadiusState);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Melancholy);
         iOffense = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#lRadiusState=lRadiusState);
      }
      
      % Check for relics
      if Send(self,@GetLadderID) = 0
         AND poGuild <> $
         AND Send(poGuild,@GetGuildHall) <> $
      {
         foreach i in Send(Send(poGuild,@GetGuildHall),@GetRelicList)
         {
            iOffense = Send(i,@ModifyHitRoll,#who=self,#what=what,#hit_roll=iOffense);
         }
      }

      iOffense = iOffense + Send(Send(SYS,@GetParliament),
                                 @GetFactionHitrollBonus,#who=self);

      % If we're using a ranged weapon and don't have a clear line of sight,
      %  then half our offense.
      if what <> $
         AND oWeapon <> $
         AND IsClass(oWeapon,&RangedWeapon)
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         AND NOT (IsClass(self,&DM) AND Send(self,@PlayerIsImmortal))
      {
         Send(self,@MsgSendUser,#message_rsc=bad_line_of_sight);
         iOffense = iOffense / 2;
      }

      % Check for Chilled status effect, which lowers offense.
      iChilled = Send(self,@GetStatusEffect,#type=STATUS_CHILLED);
      if iChilled > 0
      {
         iOffense = iOffense - (iChilled * Send(SETTINGS_OBJECT,
                                                @GetElementalMultiple,
                                                #type=STATUS_CHILLED));
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iOffense = Send(Nth(i,2),@ModifyHitRoll,
                                  #who=self,#what=what,#hit_roll=iOffense,
                                  #state=Nth(i,3));
      }

      if Send(self,@GetStance) <> $
      {
         iOffense = Send(Send(self,@GetStance),@LastPriorityModifyHitRoll,
                          #who=self,#what=what,#hit_roll=iOffense);
      }

      return Bound(iOffense,1,$);
   }

   GetDefense(what = $, stroke_obj=$)
   "This returns the battler's ability to avoid being hit. "
   "Ranges from 1 to 2000."
   {
      local i, iParry, iDodge, iBlock, iWayOfTheBird,
            iDefense, oMonster, iShocked;
            
      if Send(self,@IsResting)
      {
         return 1;
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDefense = Send(oMonster,@GetDefense,#what=what,
                        #stroke_obj=stroke_obj);
      }
      else
      {
         % A player's defense is based on his dodge, parry,
         % block skills, agility, and max hps.
         iParry = 0;
         iDodge = 0;
         iBlock = 0;

         % Ask the weapon, it might give a bonus to parrying.
         iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);

         % Ask the shield, it might give a bonus to block.
         iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);

         iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);
         
         iWayOfTheBird = 0;
         if Send(self,@HasSkill,#num=SKID_WAY_OF_THE_BIRD)
         {
            iWayOfTheBird = Send(Send(SYS,@FindSkillByNum,#num=SKID_WAY_OF_THE_BIRD),@GetDefense,#who=self);
         }

         iDefense = iParry + iBlock + (iDodge*2) + (iWayOfTheBird*2)
                     + (200 * piBase_Max_Health)/(100 + Send(self,@GetStamina));
      }

      foreach i in plDefense_modifiers
      {
         iDefense = Send(i,@ModifyDefensePower,#who=self,
                           #what=what,#defense_power=iDefense);
      }

      foreach i in plRadiusEnchantments
      {
         iDefense = Send(Nth(i,1),@ModifyDefensePower,#attacker=what,
                     #iPower=Nth(i,2),#caster=Nth(i,3),#defense_power=iDefense);
      }
      
      % Check for relics
      if Send(self,@GetLadderID) = 0
         AND poGuild <> $
         AND Send(poGuild,@GetGuildHall) <> $
      {
         foreach i in Send(Send(poGuild,@GetGuildHall),@GetRelicList)
         {
            iDefense = Send(i,@ModifyDefensePower,#attacker=what,#defense_power=iDefense);
         }
      }

      iDefense = iDefense + Send(Send(SYS,@GetParliament),
                                 @GetFactionDefenseBonus,#who=self);

      % Check for Shocked status effect, which lowers defense.
      iShocked = Send(self,@GetStatusEffect,#type=STATUS_SHOCKED);
      if iShocked > 0
      {
         iDefense = iDefense - (iShocked * Send(SETTINGS_OBJECT,
                                                @GetElementalMultiple,
                                                #type=STATUS_SHOCKED));
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iDefense = Send(Nth(i,2),@ModifyDefensePower,
                                 #who=self,#what=what,#defense_power=iDefense,
                                 #state=Nth(i,3));
      }

      if Send(self,@GetStance) <> $
      {
         iDefense = Send(Send(self,@GetStance),@LastPriorityModifyDefensePower,
                         #who=self,#what=what,#defense_power=iDefense);
      }

      return Bound(iDefense,1,$);
   }

   % The next three messages deal with the three defense skills.  These
   % messages return the relative values of the three skills.  Used in
   % player for defense, used in battler for defense messages.
   GetParryAbility(stroke_obj=$)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetParryAbility,#stroke_obj=stroke_obj);
      }

      oWeapon = Send(self,@GetWeapon);
      if oWeapon = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_PARRY),
                     @CanPayCosts,#who=self)
         OR (stroke_obj <> $ AND NOT Send(stroke_obj,@CanParry))
      {
         return 0;
      }

      return Send(oWeapon,@GetParryAbility,#who=self);
   }

   GetBlockAbility(stroke_obj=$)
   {
      local oShield, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         % Should only be one morph enchantment on the player.
         return Send(oMonster,@GetBlockAbility,#stroke_obj=stroke_obj);
      }

      oShield = Send(self,@LookupPlayerShield);
      if oShield = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_BLOCK),
                     @CanPayCosts,#who=self)
         OR ((stroke_obj <> $) AND NOT Send(stroke_obj,@CanBlock))
      {
         return 0;
      }

      return Send(oShield,@GetBlockAbility,#who=self);
   }

   GetDodgeAbility(stroke_obj=$)
   {
      local oMonster;

      if stroke_obj <> $ AND NOT Send(stroke_obj,@CanDodge)
      {
         return 0;
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
         AND NOT (piFlags & PFLAG_NO_MOVE)
      {
         return Send(oMonster,@GetDodgeAbility,#stroke_obj=stroke_obj);
      }

      if Send(Send(sys,@FindSkillByNum,#num=SKID_DODGE),@CanPayCosts,#who=self)
      {
         return Send(self,@GetSkillAbility,#skill_num=SKID_DODGE);
      }

      return 0;
   }

   % This returns the damage done to target "what" before resistances.
   GetDamage(what = $, stroke_obj=$, bDoingBackstab=FALSE)
   {
      local i, iDamage, oStroke, oWeapon, iStrokeNum, iModBonus, iDamageBonus,
            oSpell, oMonster, lRadiusState;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDamage = Send(oMonster,@GetDamage,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         oStroke = stroke_obj;
         if stroke_obj = $
         {
            oWeapon = Send(self,@GetWeapon);
            if oWeapon = $
            {
               oStroke=Send(SYS,@FindSkillByNum,#num=SKID_PUNCH);
            }
            else if IsClass(oWeapon,&Weapon)
            {
               oStroke=Send(SYS,@FindSkillByNum,
                     #num=Send(oWeapon,@GetDefaultStrokeNumber));
            }
            else
            {
               % It's a spell, use it as the stroke object.
               oStroke = oWeapon;
            }
         }
         
         if oStroke <> $
            AND IsClass(oStroke,&Punch)
         {
            if Send(self,@HasSkill,#num=SKID_PRESSURE_POINTS)
            {
               Post(Send(SYS,@FindSkillByNum,#num=SKID_PRESSURE_POINTS),@AttemptCriticalHit,#who=self,#target=what);
            }
         }

         % Currently considers the damage of the weapon and player's might.
         % Stroke sets damage
         iDamage = Send(oStroke,@FindDamage,#weapon_used=Send(self,@GetWeapon),
                        #who=self,#victim=what); 
      }

      % Spells and attmods that modify damage
      iDamageBonus = 0;
      foreach i in plAttack_modifiers
      {
         % Attack modifiers return the total damage, subtract out the original
         %  damage to get the damage bonus.
         iModBonus = Send(i,@ModifyDamage,#who=self,#what=what,#damage=iDamage,
                          #stroke_obj=oStroke);
         iDamageBonus = iDamageBonus + (iModBonus - iDamage);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Melancholy);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Mirth);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Dispassion)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Dispassion);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus,#lRadiusState=lRadiusState);
      }

      iDamageBonus = iDamageBonus + Send(Send(SYS,@GetParliament),
                                          @GetFactionDamageBonus,#who=self);

      % Convert to high precision. Super dirty, will be cleaned up shortly.
      iDamageBonus = iDamageBonus*100;
      
      % Check for relics - this is high precision so * 100
      if Send(self,@GetLadderID) = 0
         AND poGuild <> $
         AND Send(poGuild,@GetGuildHall) <> $
      {
         foreach i in Send(Send(poGuild,@GetGuildHall),@GetRelicList)
         {
            iDamageBonus = Send(i,@ModifyDamage,#who=self,#what=what,#damage=iDamageBonus,#stroke_obj=oStroke);
         }
      }

      if poStance <> $
         AND IsClass(poStance,&Cleave)
         AND Send(self,@GetWeapon) <> $
         AND Send(Send(self,@GetWeapon),@CanCleave)
      {
         iDamage = Send(poStance,@GetCleaveDamage,#who=self,#damage=iDamage);
      }

      if poStance <> $
         AND (IsClass(poStance,&HeavyAttackStance)
            OR IsClass(poStance,&LightAttackStance))
      {
         iDamage = Send(poStance,@ModifyAttackDamage,#who=self,#damage=iDamage,#stroke_obj=stroke_obj,#bDoingBackstab=bDoingBackstab);
      }
      
      if Send(self,@GetWeapon) = $
         AND (Send(self,@HasSkill,#num=SKID_FLICKER_STRIKE)
            OR (poStance <> $ AND IsClass(poStance,&ShadowstepStance)))
      {
         if poStance <> $ AND IsClass(poStance,&ShadowstepStance)
         {
            iDamage = Send(poStance,@ModifyAttackDamage,#who=self,#damage=iDamage,#stroke_obj=stroke_obj);
         }
         else
         {
            iDamage = Send(Send(SYS,@FindSkillByNum,#num=SKID_FLICKER_STRIKE),@ModifyAttackDamage,#who=self,#damage=iDamage,#stroke_obj=stroke_obj);
         }
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iDamage = Send(Nth(i,2),@ModifyDamage,
                                 #who=self,#what=what,#damage=iDamage,
                                 #state=Nth(i,3));
      }

      iDamage = iDamage + iDamageBonus;
      
      % Check for Charmed status.
      iDamage = iDamage - ((iDamage * Send(self,@GetStatusEffect,#type=STATUS_CHARMED))/Bound(Send(self,@GetHealth),1,$));

      return iDamage;
   }

   % This is the type of damage done.
   GetDamageType(what = $, use_weapon = $, stroke_obj = $)
   {
      local oWeapon, oMonster;

      if stroke_obj <> $
         AND IsClass(stroke_obj,&Throw)
      {
         return Send(stroke_obj,@GetDamageType,#who=self);
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetDamageType,#what=what);
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         % No weapon means we are punching
         return ATCK_WEAP_UNARMED+ATCK_WEAP_PUNCH;
      }

      if poStance <> $
         AND IsClass(poStance,&Cleave)
         AND Send(oWeapon,@CanCleave)
      {
         % Cleave changes all attacks to ATCK_WEAP_SLASH, but still must check
         % to retain MAGIC, NONMAGIC, and NERUDITE.
         return Send(poStance,@GetCleaveAttackType,#weapon_used=oWeapon);
      }

      return Send(oWeapon,@GetAttackType);
   }

   GetSpellType(what = $, use_weapon = $, stroke_obj = $, damaging_now = FALSE)
   {
      local oWeapon, oMonster, oTouchSpell;
      
      if stroke_obj <> $
         AND IsClass(stroke_obj,&Throw)
      {
         return Send(stroke_obj,@GetSpellType,#who=self);
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return ATCK_SPELL_ILLUSION;
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if Send(self,@GetSkillAbility,#Skill_num=SKID_CHARGED_CLUTCH) > 0
         AND oWeapon <> $
         AND IsClass(oWeapon,&Weapon)
         AND NOT IsClass(oWeapon,&TouchAttackSpell)
         AND NOT IsClass(oWeapon,&RangedWeapon)
         AND NOT IsClass(oWeapon,&NeruditeSword)
      {
         oTouchSpell = Send(self,@GetActiveTouchSpell);
         
         if oTouchSpell <> $
         {
            return Send(Send(SYS,@FindSkillByNum,#num=SKID_CHARGED_CLUTCH),
                        @ModifyWeaponSpellType,
                        #who=self,
                        #oWeapon=oWeapon,
                        #oTouchSpell=oTouchSpell,
                        #damaging_now=damaging_now);
         }
      }

      if oWeapon = $
      {
         % No weapon means we are punching, no magical damage
         return 0;
      }

      if Send(self,@GetStance) <> $
         AND IsClass(Send(self,@GetStance),&ChargedClutchStance)
      {
         return Send(Send(self,@GetStance),@GetSpellType,#who=self,#oWeapon=oWeapon,#damaging_now=damaging_now);
      }

      return Send(oWeapon,@GetAttackSpell);
   }

   AssessHit(what = $, stroke_obj = $, damage = $)
   {
      local oMonster, oMorph, oWeapon;

      if stroke_obj <> $
      {
         if IsClass(stroke_obj,&Throw)
         {
            oWeapon = Send(stroke_obj,@FindLikelyAmmo,#who=self);
         }
         else
         {
            oWeapon = Send(self,@GetWeapon);
         }
         
         if Send(self,@GetWeaponSwingBonus) > 0
         {
            Send(stroke_obj,@ImproveStroke,#who=self,#target=what,
                  #use_weapon=oWeapon);
         }
         
         if Send(self,@HasSkill,#num=SKID_VILE_TOUCH)
            AND Send(Send(SYS,@FindSkillByNum,#num=SKID_VILE_TOUCH),@DoSkill,#who=self)
         {
            Post(Send(SYS,@FindSkillByNum,#num=SKID_VILE_TOUCH),@HexOpponentOnStrike,#oAttacker=self,#oDefender=what,#damage=damage,#stroke_obj=stroke_obj,#oWeapon=oWeapon);
         }
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
      {
         oMorph = Send(SYS,@FindSpellByNum,#Num=SID_MORPH);
         if Send(self,@IsEnchanted,#what=oMorph)
         {
            Send(oMonster,@HitSideEffect,#what=what,#who=self);
         }
      }
      
      if pbLeapKnockback
      {
         % Knock back our victim!
         Send(what,@ApplyKnockback,#what=self,#knockback_power=Send(self,@GetKnockbackPower));
         pbLeapKnockback = FALSE;
      }

      Send(self,@DoHitMessageSound,#what=what,#damage=damage,#stroke_obj=stroke_obj);

      propagate;
   }

   % Handles damage done to player
   % IMPORTANT NOTE: AssessDamage handles both legacy damage calculations and 
   % high precision damage calculation which avoid truncation. If you feed 
   % AssessDamage with a high precision damage number such as 941 for 9.41 
   % points of damage, you need to notify AssessDamage by passing it a 
   % #precision=TRUE. If you don't, AssessDamage will assume that you are 
   % passing a legacy damage value and multiply it by 100 for further 
   % calculations. Most notably, damage from attackspells and melee is now 
   % handled with high precision. Eventually, all damage calculations should 
   % be handled in high precision mode.
   AssessDamage(what=$,damage=0,atype=0,aspell=0,stroke_obj=$,bonus=0,
      scalefactor=1000,report=TRUE,report_resistance=TRUE,absolute=FALSE,
      precision=FALSE,bDoingBackstab=FALSE,bSecondary=FALSE)
   {
      local i, iResistance, oSoldierShield, color_rsc,
            iDuration, oSpell, oGort, origdamage, oWeapon,
            iEmpowermentPercentage, bShielded, iCorrode, iCorrodeMultiple,
            iCorrodeReduction, iDamagePreArmor;

      % flip flag for possible HP gain.
      if poKill_target = $
      {
         poKill_target = what;
      }

      % We place this here so players aren't penalized by armor and other protections while building
      % As long as the attack starts with positive damage, we count it
      if what = poKill_target AND damage > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE,#value=TRUE);
      }

      piTimeLastHitByBattler = GetTime();
      
      if what <> $
         AND IsClass(what,&Player)
         AND Send(what,@HasSkill,#num=SKID_DESECRATION)
      {
         aspell = Send(Send(SYS,@FindSkillByNum,#num=SKID_DESECRATION),@ConvertDamageTypes,#who=what,#aspell=aspell);
      }
      
      if Send(self,@HasSkill,#num=SKID_SANCTIFICATION)
      {
         aspell = Send(Send(SYS,@FindSkillByNum,#num=SKID_SANCTIFICATION),@ConvertDamageTypes,#who=self,#aspell=aspell);
      }

      % bSecondary flags this as secondary damage such as burning,
      %    which skips quite a few damage adds. I.e. the primary damage
      %    already got those bonuses.

      % Check for stat steals
      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&DrainHex)
      {
         if what <> self
            AND IsClass(what,&Battler)
         {
            Send(Nth(i,2),@StealStat,#who=what,#what=self,#state=Nth(i,3));
         }
      }

      if NOT precision
      {
         damage = damage * 100;
      }

      origdamage = damage/100;
      color_rsc = player_hit_color_none;

      % Attacks against a minion master will cause minions to defend the master.
      Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);
      
      if what <> $ AND IsClass(what,&monster)
      {
         color_rsc = player_hit_color_blue;
      }
      
      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetObjectAttributes)
         {
            if IsClass(i,&RoomThreat)
            {
               damage = Send(i,@ThreatModifyDamage,#damage=damage,#atype=atype,#aspell=aspell);
            }
         }
      }

      if NOT bSecondary
      {
         if (IsClass(what,&Battler)
            OR IsClass(what,&AlchemyBomb))
            AND Send(SETTINGS_OBJECT,@GetEmpowermentsEnabled)
         {
            % Empowerments e.g. 6% increased acid dam
            iEmpowermentPercentage = 0;
            foreach i in Send(what,@GetCurrentEmpowerments)
            {
               if Nth(i,1) > 0
               {
                  % Weapon empowerment.
                  if atype & Nth(i,1)
                  {
                     iEmpowermentPercentage = iEmpowermentPercentage + Nth(i,2);
                  }
               }
               else
               {
                  % Spell empowerment.
                  if aspell & -Nth(i,1)
                  {
                     iEmpowermentPercentage = iEmpowermentPercentage + Nth(i,2);
                  }
               }
            }

            % Slayers e.g. 6% increased damage to insects
            foreach i in Send(what,@GetCurrentSlayers)
            {
               if Send(self,@HasCreatureType,#type=Nth(i,1))
               {
                  iEmpowermentPercentage = iEmpowermentPercentage + Nth(i,2);
               }
            }
            
            damage = (damage * (100+iEmpowermentPercentage))/100;
         }
         
         % Check for Loyal Guard
         if poStance <> $
            AND IsClass(poStance,&LoyalGuardStance)
         {
            damage = Send(Send(SYS,@FindSkillByNum,#num=SKID_LOYAL_GUARD_STANCE),@AttemptGuardsTakeDamage,#who=self,#damage=damage);
         }
      
         % Check for Heavy Arms mastery.
         if Send(self,@HasMasteredThisSkill,#num=SKID_HEAVY_ARMS)
            AND poStance <> $
            AND IsClass(poStance,&HeavyArms)
         {
            damage = Send(Send(SYS,@FindSkillByNum,#num=SKID_HEAVY_ARMS),@MasteryModifyDamage,#who=self,#damage=damage);
         }

         % Check for Draconian hide
         if piPlayerRace = RACE_DRACONIAN
         {
            damage = (damage * 90)/100;
         }

         % Check for Damage to Mana from Spirit Shackles Hex.
         if what <> $
            AND IsClass(what,&Battler)
         {
            foreach i in Send(what,@GetEnchantmentsByClass,#enchClass=&Hex)
            {
               damage = Send(Nth(i,2),@AttackerDealsDamageToMana,#who=self,#what=what,#state=Nth(i,3),#damage=damage);
            }
         }
         % Check for Damage to Mana from Mana Shield skill.
         if Send(self,@HasSkill,#num=SKID_MANA_SHIELD)
         {
            if Send(Send(SYS,@FindSkillByNum,#num=SKID_MANA_SHIELD),@DoSkill,#who=self)
            {
               damage = Send(Send(SYS,@FindSkillByNum,#num=SKID_MANA_SHIELD),@AttackerDealsDamageToMana,#oAttacker=what,#oDefender=self,#damage=damage);
            }
         }
         if damage = 0
         {
            % Spirit Shackles and Mana Shield took all the damage.
            return 0;
         }
      }
      
      if IsClass(what,&Player)
         AND Send(what,@HasMasteredThisSkill,#num=SKID_PROFICIENCY_SCIMITAR)
         AND Send(what,@GetWeapon) <> $
         AND IsClass(Send(what,@GetWeapon),&Scimitar)
         AND (atype & ATCK_WEAP_SLASH) <> 0
      {
         Send(self,@AddExertion,#amount=10000);
      }

      % Check for Aversion.
      if Send(SYS,@FindSkillByNum,#num=SKID_AVERSION) <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_AVERSION) > 0
         AND Send(Send(SYS,@FindSkillByNum,#num=SKID_AVERSION),@DoSkill,#who=self,#oAttacker=what)
      {
         damage = Send(Send(SYS,@FindSkillByNum,#num=SKID_AVERSION),@AvertDamage,#who=self,#oAttacker=what,#damage=damage);
      }

      if NOT absolute
         AND NOT bDoingBackstab
      {
         % Armor of Gort has a special effect that must go first
         oGort = Send(SYS,@FindSpellByNum,#Num=SID_ARMOR_OF_GORT);
         if Send(self,@IsEnchanted,#what=oGort)
         {
            damage = Send(oGort,@PriorityModifyDefenseDamage,#who=self,
                           #what=what,#damage=damage,
                           #atype=atype,#aspell=aspell);
         }

         iDamagePreArmor = damage;
         foreach i in plDefense_modifiers
         {
            damage = Send(i,@ModifyDefenseDamage,#who=self,#what=what,
                           #damage=damage,#atype=atype,#aspell=aspell,
                           #report_resistance=report_resistance);
            Send(i,@DefendingHit,#who=self,#what=what);
         }

         iCorrode = Send(self,@GetStatusEffect,#type=STATUS_CORRODE);
         if iCorrode > 0
         {
            iCorrodeMultiple = Send(SETTINGS_OBJECT,
                               @GetElementalMultiple,#type=STATUS_CORRODE);
         
            iCorrodeReduction = (iCorrode/iCorrodeMultiple);
            damage = bound(damage + iCorrodeReduction*100,1,iDamagePreArmor);
         }

         iResistance = Send(self,@ResistanceCheck,#atype=atype,#aspell=aspell,#what=what);

         foreach i in plRadiusEnchantments
         {
            iResistance = Send(First(i),@ModifyResistance,#attacker=what,
                  #atype=atype,#iPower=Nth(i,2),
                  #caster=Nth(i,3),#resistance=iResistance);
         }

         damage = Send(self,@GetDamageFromResistance,#what=damage,
                        #value=iResistance);

         % Allow protective spells a chance to improve when they take effect!
         foreach i in plPassiveImprovement
         {
            if (aspell & -Nth(i,4)) AND random(1,10) = 10
            {
               Send(First(i),@ImproveAbility,#who=self,#target=what);
            }
         }
         foreach i in plReservedSpells
         {
            if (aspell & (Send(Nth(i,1),@IsResistance)*-1)) AND Random(1,20) = 20
            {
               Send(First(i),@ImproveAbility,#who=self,#target=what);
            }
         }
      
         damage = damage * scalefactor / 1000;
      }

      if IsClass(what,&Player)
         AND NOT bSecondary
      {
         if (aspell & ATCK_SPELL_HOLY
            OR aspell & ATCK_SPELL_UNHOLY)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_DEVOTION) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_DEVOTION),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_COLD
            OR aspell & ATCK_SPELL_ACID)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_ENTROPY) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_ENTROPY),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_FIRE
            OR aspell & ATCK_SPELL_SHOCK)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_ENERGY) > 0
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_ENERGY),
                                  @AddDamage,
                                  #who=what,
                                  #damage=bonus,
                                  #aspell=aspell);
         }
         if (aspell & ATCK_SPELL_ILLUSION)
            AND Send(what,@GetSkillAbility,#Skill_num=SKID_HONESTY) > 0
         {
            % Players with Honesty do significantly less damage with illusions
            bonus = bonus - (Send(what,@GetSkillAbility,#Skill_num=SKID_HONESTY)*100)/9;
            Send(Send(SYS,@FindSkillByNum,#num=SKID_HONESTY),@DoSkill,#who=what);
         }
      }

      if (aspell & ATCK_SPELL_ILLUSION)
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_HONESTY) > 0
      {
         % Put an imp check for Honesty here so it doesn't get spammed by resistance calculations
         Send(Send(SYS,@FindSkillByNum,#num=SKID_HONESTY),@DoSkill,#who=self);
      }

      if NOT bSecondary
      {
         if Send(self,@HasSkill,#num=SKID_DETERMINATION)
         {
            bonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_DETERMINATION),@ModifyDamageTaken,#who=self,#bonus=bonus);
         }

         foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Bleed)
         {
            bonus = Send(Nth(i,2),@ModifyDamageTaken,#who=self,#bonus=bonus,#power=Nth(i,3));
         }
         
         if Send(self,@HasSkill,#num=SKID_HARMONICS)
         {
            bonus = bonus + Send(Send(SYS,@FindSkillByNum,#num=SKID_HARMONICS),@GetIncreasedDamageTaken,#who=self);
         }
      }

      % Add attmods AFTER resistance/suscep mods.
      damage = damage + bonus;

      % Floor to zero, now check for bleed and last priority mods.
      % Add bleed after a bound so that it guarantees players take damage even through Determination
      damage = Bound(damage,0,$);
      bonus = 0;
      if NOT bSecondary
      {
         foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Bleed)
         {
            bonus = Send(Nth(i,2),@ModifyDamageTaken,#who=self,#bonus=bonus,#power=Nth(i,3));
         }
      }
      damage = damage + bonus;

      if IsClass(what,&Player)
         AND Send(what,@GetStance) <> $
         AND NOT bSecondary
      {
         damage = Send(Send(what,@GetStance),@LastPriorityModifyDamage,#who=what,#what=self,#damage=damage,#stroke_obj=stroke_obj);
      }
      
      if Send(self,@GetStance) <> $
      {
         damage = Send(Send(self,@GetStance),@LastPriorityModifyDefenseDamage,#who=self,#what=what,#damage=damage);
      }

      % Make sure we don't deal negative damage.
      damage = Bound(damage,0,$);

      iDuration = 800;
      if damage <= 600
      {
         iDuration = 600;
      }

      if damage <= 300
      {
         iDuration = 400;
      }

      % Spell damage types do different flashes to inform the victim.
      % If it's just physical damage, do pain instead. Notably: spell
      % damage type flashes cannot be turned off by unchecking the
      % Show Pain option in client config.
      if aspell <> 0
      {
         iDuration = iDuration / 2;
         Send(self,@DamageTypeFlashEffect,#aspell=aspell,#duration=iDuration);
      }
      else
      {
         Send(self,@EffectSendUserDuration,#what=self,
               #effect=EFFECT_PAIN,#duration=iDuration);
      }

      if damage > 0
      {
         if (piFlags2 & PFLAG2_PARALYZED)
         {
            Send(self,@RemoveEnchantment,
                  #what=Send(SYS,@FindSpellByNum,#num=SID_PARALYZE));
         }
      }

      if NOT absolute
         AND NOT bDoingBackstab
         AND what <> $
         AND IsClass(what,&Player)
      {
         % If we have more health than twice our max, no percent limit on damage.
         % If we are outlaw or murderer, no percent limit on damage.
         if piHealth < (Send(self,@GetMaxHealth) * 200)
            AND ((NOT (piFlags & PFLAG_OUTLAW)
               AND NOT (piFlags & PFLAG_MURDERER))
               OR Send(SETTINGS_OBJECT,@DamageCapProtectionMurderersEnabled))
         {
            % Cap damage to 1/3 of max health (+2 so we "round up")
            damage = Bound(damage,$,((Send(self,@GetMaxHealth)*100) + (MAX_HEALTH_DAMAGE_FRACTION-1)) / MAX_HEALTH_DAMAGE_FRACTION);
         }

         % maximum of 30 damage per hit
         damage = bound(damage,$,MAX_DAMAGE_PER_HIT*100);
      }

      % Faction enemies an extra 15% damage to each other, above caps.
      if what <> $ AND IsClass(what,&Player)
         AND NOT bSecondary
      {
         oSoldierShield = Send(what,@FindUsing,#class=&SoldierShield);
         if oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#who=self,#what=what,
                      #damage=TRUE)
         {
            damage = (damage * 115)/100;
         }
      }

      if IsClass(what,&Monster)
      {
         RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
            Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
            player_monster_attack_string);
      }

      if IsClass(what,&Player)
      {
         oWeapon = Send(what,@GetWeapon);
         if oWeapon <> $
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
               Send(Send(what,@GetWeapon),@GetTrueName));
         }
         else
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
               player_no_weapon_string);
         }
      }

      % Set final damage by PvP modifier
      if what <> $
         AND IsClass(what,&Player)
         AND NOT bSecondary
      {
         damage = (damage * Send(SETTINGS_OBJECT,@GetPvPDamagePercentage)) / 100;
      }

      Send(self,@LoseHealth,#amount=damage,#precision=TRUE);

      if piHealth <= 0
      {
         if stroke_obj = $
            OR NOT Send(stroke_obj,@PlayerWasKilledMsg,#who=self,
                        #attacker=what,#damage=$)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Send(self,@PlayerWasHit,
                     #atype=atype,#aspell=aspell),#parm1=color_rsc,
                     #parm2=Send(what,@GetCapDef),#parm3=Send(what,@GetName));
            }
         }

         return $;
      }

      % Should we print resistance message?
      if report_resistance
      {
         if IsClass(what,&User)
         {
            Post(what,@MsgPlayerHitResisted,#what=what,
                  #resistance=iResistance,#target=self);
         }

         Post(self,@MsgPlayerResistsHit,#what=what,#resistance=iResistance,
               #target=self,#color_rsc=color_rsc);
      }

      if damage > 0 AND Send(self,@FindHolding,#class=&ShrunkenHead) <> $
      {
         Send(Send(self,@FindHolding,#class=&ShrunkenHead),@DamageTaken,#what=what,#amount=damage/100);
      }
      
      Send(self,@AddHurtMeRecently,#who=what,#amount=damage);

      if what = self
         AND NOT bSecondary
      {
         % Don't apply status effects or reflect damage on ourselves
         %    unless this is secondary damage, such as burning.
         return damage;
      }

      % Apply possible elemental status effects
      if atype = 0
      {
         if aspell <> 0
         {
            Send(self,@ApplyElementalStatusEffects,#damage=damage/100,
                      #aspell=aspell,#what=what,#absolute=absolute,#bSecondary=bSecondary);
         }
      }
      else
      {
         % Apply only half the effects from partially magical attacks
         if aspell <> 0
         {
            Send(self,@ApplyElementalStatusEffects,#damage=(damage/100/2),
                      #aspell=aspell,#what=what,#absolute=absolute,#bSecondary=bSecondary);
         }
      }

      if what <> $
         AND (IsClass(what,&Player)
             OR IsClass(what,&Monster))
      {
         foreach i in Send(what,@GetEnchantmentsByClass,#enchClass=&Hex)
         {
            Send(Nth(i,2),@ReflectPhysicalDamage,#who=self,#what=what,#state=Nth(i,3),#damage=damage,#atype=atype,#aspell=aspell,#stroke_obj=stroke_obj);
            Send(Nth(i,2),@ReflectElementalDamage,#who=self,#what=what,#state=Nth(i,3),#damage=damage,#atype=atype,#aspell=aspell,#stroke_obj=stroke_obj);
         }
      }

      if NOT bSecondary
      {
         Send(self,@ApplyElementalImbalance,#aspell=aspell,#power=Send(what,@GetElementalImbalancePower,#aspell=aspell));
      }

      return damage;
   }

   % This message kicks in when damage is done to the opponent.
   DidDamage(what = $, amount = 0, stroke_obj = $)
   {
      local oWeapon, i, shrunken;

      if stroke_obj <> $
         AND IsClass(stroke_obj,&Throw)
      {
         oWeapon = $;
      }
      else
      {
         oWeapon = Send(self,@GetWeapon);

         if oWeapon <> $
         {
            Send(oWeapon,@WeaponHitTarget);
         }
      }

      foreach i in plAttack_modifiers
      {
         Send(i,@WeaponHitTarget);
      }

      if Send(self,@GetSkillAbility,#Skill_num=SKID_DISARM) > 0
      {
         if oWeapon <> $ AND IsClass(oWeapon,&Spell)
         {
            oWeapon = $;
         }

         Send(Send(SYS,@FindSkillByNum,#num=SKID_DISARM),@DoSkill,#who=self,
               #oTarget=what,#oWeapon=oWeapon);
      }

      if amount > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         % Report to shrunken head
         shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
         if shrunken <> $
         {
            Send(shrunken,@DamageDealt,#what=what,#amount=amount/100);
         }
      }

      return;
   }

   % Returns weapon used.
   GetWeapon()
   {
      local oWeapon;

      oWeapon = Send(self,@LookupPlayerWeapon);
      % If there is no wielded melee weapon, then see if we
      % have a touch attack active.
      if oWeapon = $
      {
         % This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetActiveTouchSpell);
      }

      return oWeapon;
   }

   % The next three functions deal with weapon improvement.

   % This keeps track of the weapon swings.
   SwingWeapon(times=1,stroke_obj=$)
   {
      local oWeapon, iProfNum;

      if stroke_obj <> $
         AND IsClass(stroke_obj,&Throw)
      {
         iProfNum = SKID_PROFICIENCY_THROW;
      }
      else
      {
         oWeapon = Send(self,@LookupPlayerWeapon);

         if oWeapon <> $
         {
            % Get weapon's numbers.
            iProfNum = Send(oWeapon,@GetProfNumber,#who=self);
         }
         else
         {
            % Unarmed or touch attacks.
            iProfNum = SKID_BRAWLING;
         }
      }

      if iProfNum <> (piWeaponInfo MOD 1000)
      {
         Send(self,@ResetWeaponSwings,#prof=iProfNum);
      }

      piWeaponSwings = piWeaponSwings + times;
      if (piWeaponSwings MOD Send(SETTINGS_OBJECT,
                                 @GetSwingsPerImproveCheck)) = 0
      {
         % Increase this number. Allows us to advance, and
         % get bonuses for advancement.
         piWeaponInfo = piWeaponInfo + 1000;
      }

      return;
   }

   % This resets the weapon swings, for example, after an improvement or a
   % weapon type change.
   ResetWeaponSwings(prof=$)
   {
      local iProf;

      if prof <> $
      {
         iProf = prof;
      }
      else
      {
         iProf = piWeaponInfo mod 1000;
      }

      piWeaponSwings = 0;
      piWeaponInfo = iProf;

      return;
   }

   GetWeaponSwingBonus()
   {
      % Separate out the number of groups of swings (the bonus) fromt he proficiency number.
      return piWeaponInfo/1000;
   }

   KilledSomething(what = $,use_weapon = $,stroke_obj = $,bDoingBackstab = FALSE, oMinionKiller=$)
   "Called when the player killed something."
   {
      local bReflection, i, oSoldierShield, monstkarma, iChance, oEnemyGuild,
      shrunken, oVictimRoom, oObject, iWisdomSteal;

      % If we killed someone or something, we did damage.
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         % Stop minions ruining our karma, they are kind of bloodthirsty
         % and tend to kill indiscriminately (especially mobs)
         bReflection = FALSE;
         if use_weapon <> $
            AND IsClass(use_weapon,&Monster)
         {
            bReflection = TRUE;
         }

      % Send text message - a stroke may want to provide it's own.
      if NOT Send(what,@SayDyingWords,#what=self)
      {
         if stroke_obj
         {
            if NOT Send(stroke_obj,@PlayerKilledSomethingMsg,#who=self,#victim=what)
               AND self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
         else
         {
            if self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
      }

      if pbLogged_on
      {
         if (IsClass(what,&Monster)
               AND NOT (IsClass(what,&Brambles)
                  OR Send(what,@IsIllusion)))
            AND (use_weapon = $
               OR NOT IsClass(use_weapon,&ActiveWallElement))
            AND (piPreferences & CF_GROUPING)
         {
            Send(self,@JoinBuilderGroup);
         }
  

         foreach i in Send(self,@GetPassiveQuests)
         {
            Send(i,@KilledSomething,#what=what);
         }

         Send(poOwner,@SomethingKilled,#what=self,#victim=what);
      }

      % Let our shield know we killed something.
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         Send(oSoldierShield,@KilledSomething,#what=what);
      }

      % Let JOF know we killed something.
      oObject = Send(self,@FindUsing,#class=&JewelOfFroz);
      if oObject <> $
      {
         Send(oObject,@KilledSomething,#what=what);
      }

      if IsClass(what,&User)
         AND what <> self
      {
         % Use the room the victim died in to determine if there are penalties
         % for this kill. Otherwise we can get away with it in rare instances.
         % Victim's room is still the one they died in.
         oVictimRoom = Send(what,@GetOwner);

         if (oVictimRoom = $
            OR NOT Send(oVictimRoom,@SafePlayerAttack))
            AND NOT Send(oVictimRoom,@GetChaosZone)
         {
            Send(Send(SYS,@GetStatistics),@PlayerKillsCounter);

            if Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            {
               piJustified_kill_count = piJustified_kill_count + 1;
            }
            else
            {
               piKill_count = piKill_count + 1;
               piKill_count_decay = piKill_count_decay + 1;
            }

            if NOT bReflection
               AND NOT Send(what,@IsIllusion)
               AND oMinionKiller = $
               AND NOT IsClass(what,&Marauder)
            {
               Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
                     #karma_killer=Send(self,@GetKarma),
                     #karma_victim=Send(what,@GetKarma)));
            }

            if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
               AND NOT IsClass(oVictimRoom,&GuildHall)
            {
               % Attacked an innocent!

               % Check for enemy guild - If both guilds are enemies, then
               % they can whack on each other freely, without murderer or
               % faction penalty.
               oEnemyGuild = Send(what,@GetGuild);

               % Check for various murderer things if any are true:
               % We're not in a guild, opponent wasn't in a guild, we're
               % not in a mutual war
               % AND if we're not a faction soldier, the opponent isn't an
               % opposing faction soldier
               % AND necro vs hunter
               if (poGuild = $
                   OR oEnemyGuild = $
                   OR NOT Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
                  AND (oSoldierShield = $
                       OR NOT Send(oSoldierShield,@IsEnemyAttack,#who=what,
                                    #what=self,#damage=TRUE))
                  AND NOT (Send(self,@HasSwordOfTheHunt) AND Send(what,@IsUsingA,#class=&NecromancerAmulet) AND Send(SETTINGS_OBJECT,@GetNecroAndHunterPvPOn))
                  AND NOT (Send(self,@IsUsingA,#class=&NecromancerAmulet) AND Send(what,@HasSwordOfTheHunt) AND Send(SETTINGS_OBJECT,@GetNecroAndHunterPvPOn))
               {
                  % SUBTLE BUG: Somehow, the faction check is missed when you
                  % kill something. We check it here, but only for players.
                  % This means that if you score just the killing blow on a
                  % factioned monster, you won't get checked for faction loss.
                  % It's a bug, but currently not that vital.
                  
                  % Check to see if the attack was faction-based.
                  Send(self,@CheckFactionAttack,#what=what);

                  % Apply penalties for someone NOT holding a token
                  if Send(what,@FindUsing,#class=&Token) = $
                  {
                     if (piFlags & PFLAG_MURDERER)
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_killed_player);
                     }
                     else
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_wanted_now,
                              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
                        Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=TRUE);
                        Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
                        Send(self,@EvaluatePKStatus,#dbug=TRUE);
                     }

                     % Does the lucky murderer win a Revenant?
                     % If it was an easy fight, lets haunt em more often than if
                     % it was competitive (or the victim at least had a shot)
                     % If were twice as strong as them, we get haunted.
                     % If the victim was good, we get haunted.
                     iChance = Send(self,@RevenantChance,#target=what);
                     if (random(1,100) < iChance) AND NOT Send(SYS,@GetChaosNight)
                     {
                        Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=TRUE);
                        if poOwner <> $
                        {
                           Send(self,@MsgSendUser,#message_rsc=player_haunted_on,
                                 #parm1=Send(what,@GetCapDef),
                                 #parm2=Send(what,@GetName,#Cap=TRUE));
                           Create(&Revenant,#target=self,#location=poOwner,
                                 #level=Bound((((piBase_Max_health*110)/100)+
                                    (7*piKill_Count_decay)),95,180),
                                 #diff=bound(piBase_Max_health/12,4,9),
                                 #karmic=-piKarma/100);
                        }
                     }
                  }
               }
            }
         }
      }

      if IsClass(what,&Monster)
         AND NOT bReflection
         AND NOT Send(what,@IsIllusion)
         AND oMinionKiller = $
         AND NOT IsClass(what,&Marauder)
      {
         Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
               #karma_victim=Send(what,@GetKarma),
               #karma_killer=Send(self,@GetKarma)),
               #bIsMob=TRUE);
      }

      Send(what,@Killed,#what=self,#stroke_obj=stroke_obj,#bDoingBackstab=bDoingBackstab);
      %Send(self,@DrawHPChance);

      % Report to shrunken head
      shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
      if shrunken <> $
      {
         Send(shrunken,@OpponentKilled,#what=what,#stroke_obj=stroke_obj);
      }

      if IsClass(what,&User)
         AND what <> self
         AND Send(self,@GetLadderID) <> 0
         AND Send(what,@GetLadderID) = Send(self,@GetLadderID)
      {
         iWisdomSteal = Send(what,@GetAccumulatedWisdom)/10;
         Send(self,@AddAccumulatedWisdom,#amount=iWisdomSteal);
         Send(what,@SubtractAccumulatedWisdom,#amount=iWisdomSteal);
         Send(self,@MsgSendUser,#message_rsc=kill_wisdom_steal,#parm1=iWisdomSteal,#parm2=Send(what,@GetTrueName));
         Send(what,@MsgSendUser,#message_rsc=kill_wisdom_lose,#parm1=iWisdomSteal,#parm2=Send(self,@GetTrueName));
      }

      return;
   }

   GetSomethingMissedYouSound(what = $,weapon_used = $)
   {
      local i,iRoll;

      if Send(self,@LookupPlayerWeapon)
      {
         iRoll = Random(1,3);
         if iRoll = 1
         {
            return player_sound_sword1;
         }

         if iRoll = 2
         {
            return player_sound_sword2;
         }

         if iRoll = 3
         {
            return player_sound_sword3;
         }
      }

      iRoll = Random(1,3);

      if iRoll = 1
      {
         return player_sound_metal1;
      }

      if iRoll = 2
      {
         return player_sound_metal2;
      }

      if iRoll = 3
      {
         return player_sound_metal3;
      }

      Debug("Can't get here");

      return $;
   }

   GetOuchSound()
   {
      local iHealthFraction;

      % Since piHealth is inflated by a factor of 100, 
      % this returns the correct fraction.
      if Send(self,@GetMaxHealth) > 0
      {
         iHealthFraction = piHealth / Send(self,@GetMaxHealth);
      }
      else
      {
         iHealthFraction = 0;
      }

      if piGender = GENDER_MALE
      {
         if iHealthFraction > 75
            OR (Send(self,@HasSkill,#num=SKID_WOUND_MASK)
               AND Send(Send(SYS,@FindSkillByNum,#num=SKID_WOUND_MASK),@OverrideScream,#who=self))
         {
            return player_sound_male_ouch1;
         }

         if iHealthFraction > 50
         {
            return player_sound_male_ouch2;
         }

         if iHealthFraction > 25
         {
            return player_sound_male_ouch3;
         }

         return player_sound_male_ouch4;
      }

      if iHealthFraction > 75
         OR (Send(self,@HasSkill,#num=SKID_WOUND_MASK)
            AND Send(Send(SYS,@FindSkillByNum,#num=SKID_WOUND_MASK),@OverrideScream,#who=self))
      {
         return player_sound_female_ouch1;
      }

      if iHealthFraction > 50
      {
         return player_sound_female_ouch2;
      }

      if iHealthFraction > 25
      {
         return player_sound_female_ouch3;
      }

      return player_sound_female_ouch4;
   }

   RevenantChance(who=$,target=$)
   {
      local oChance, oGuild, iFaction, oSpell, oVictimRoom;

      oVictimRoom = Send(target,@GetOwner);

      if oVictimRoom = $
         OR IsClass(oVictimRoom,&Guildhall)
      {
         return 0;
      }

      % PFLAG2_NOHAUNT is only settable by a guide or guardian. The last
      % two checks prevent outlaw/murderer players from creating revenants.
      if (piFlags2 & PFLAG2_NOHAUNT)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         return 0;
      }

      oChance = 30;
      oGuild = Send(target,@GetGuild);

      if poGuild <> $ AND oGuild <> $
      {
         if poGuild = oGuild
         {
            oChance = oChance + 20;
         }
         else
         {
            if Send(poGuild,@IsMutualEnemy,#otherguild=oGuild)
            {
               return 0;
            }
            if Send(poGuild,@IsAlly,#otherguild=oGuild)
            {
               oChance = oChance + 10;
            }
            if Send(oGuild,@IsAlly,#otherguild=poGuild)
            {
               oChance = oChance + 10;
            }
            if Send(poGuild,@IsEnemy,#otherguild=oGuild)
            {
               oChance = oChance - 10;
            }
            if Send(oGuild,@IsEnemy,#otherguild=poGuild)
            {
               oChance = oChance - 10;
            }
         }
      }

      iFaction = Send(target,@GetFaction);
      if piFaction <> FACTION_NEUTRAL AND iFaction <> FACTION_NEUTRAL
      {
         if piFaction <> iFaction
         {
            oChance = oChance - 5;
         }
         else
         {
            oChance = oChance + 15;
         }
      }

      % Punish them more if they beat up someone weaker than they are.
      oChance = oChance + ((10*piBase_Max_Health)/Send(target,@GetBaseMaxHealth));

      % People with greater absolute Karma have a greater chance to produce
      % a revenant.  Being a good person, in general, decreases your chance.
      % Even if you are murderous scum.
      oChance = oChance + (abs(Send(target,@GetKarma)-piKarma/100))/20;

      % Punish them more if they walked away with more health.
      oChance = oChance + bound(piHealth/(5*piBase_Max_health),0,20);

      % Bind the number to a reasonable amount, then add in the penalty
      % for being a repeat killer.
      oChance = (bound(oChance,20,80) + (5*piKill_count_decay));

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_MARTYRS_BATTLEGROUND);
      if Send(oVictimRoom,@IsEnchanted,#what=oSpell)
      {
         oChance = oChance +
               (oChance * Send(oVictimRoom,@GetEnchantmentState,#what=oSpell) / 100);
      }
      oChance = Bound(oChance,40,95);

      return oChance;
   }

   DoHitMessageSound(what = $,damage = 0,stroke_obj = $)
   {
      local iRoll,rSound;

      if (stroke_obj = $)
      {
         return;
      }

      if IsClass(stroke_obj,&Spell)
      {
         rSound = Send(stroke_obj,@GetHitSound);
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
         if IsClass(what,&Player)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound));
         }

         return;
      }

      if IsClass(what,&Monster)
         AND NOT IsClass(what,&Marauder)
      {
         if damage <> $
         {
            if damage <= 300
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_flesh1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_flesh2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_flesh3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }

            if damage <= 600
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_leather1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_leather2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_leather3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }
         }

         iRoll = Random(1,3);
         if iRoll = 1
         {
            rSound = player_sound_hit_monster_metal1;
         }
         else
         {
            if iRoll = 2
            {
               rSound = player_sound_hit_monster_metal2;
            }
            else
            {
               rSound = player_sound_hit_monster_metal3;
            }
         }

         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

         return;
      }

      if damage <> $
      {
         if damage <= 300
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_flesh1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_flesh2;
               }
               else
               {
                  rSound = player_sound_hit_monster_flesh3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
               OR IsClass(what,&Marauder)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }

         if damage <= 600
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_leather1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_leather2;
               }
               else
               {
                  rSound = player_sound_hit_monster_leather3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
               OR IsClass(what,&Marauder)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }
      }

      iRoll = Random(1,3);
      if iRoll = 1
      {
         rSound = player_sound_hit_monster_metal1;
      }
      else
      {
         if iRoll = 2
         {
            rSound = player_sound_hit_monster_metal2;
         }
         else
         {
            rSound = player_sound_hit_monster_metal3;
         }
      }

      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

      if IsClass(what,&Player)
         OR IsClass(what,&Marauder)
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
      }

      return;
   }

   CheckAttackTimer()
   {
      if ptAttackTimer <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   IsOkayAttackTime(time = 1000, seconds = $,stroke_obj = $, bAdditionalAttack = FALSE)
   "Have we waited long enough since the last attack/spell? Sets new "
   "valid attack time (time in msec, default 1 second)."
   {
      local i, n;

      if ptAttackTimer <> $
      {
         return FALSE;
      }

      if bAdditionalAttack
      {
         % These will always be 500 ms.
         ptAttackTimer = CreateTimer(self,@AttackTimer,500);
         return TRUE;
      }

      if seconds <> $
      {
         i = seconds*1000;
      }
      else
      {
         i = time;
      }

      if poStance <> $
      {
         i = Send(poStance,@ModifyAttackTime,#iAttackTime=i,#stroke_obj=stroke_obj);
      }

      foreach n in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         i = Send(Nth(n,2),@ModifyDelay,
                           #state=Nth(n,3),#iDelay=i);
      }

      if i > 0
      {
         ptAttackTimer = CreateTimer(self,@AttackTimer,i);
      }

      return TRUE;
   }

   AttackTimer()
   "Sets the attack timer variable to NIL so we know it's OK to attack again."
   {
      ptAttackTimer = $;

      return;
   }

   SendAttackOutOfRangeMessage(what = $, use_weapon = $, stroke_obj = $)
   {
      if use_weapon = $
         AND stroke_obj = $
      {
         return;
      }

      if use_weapon <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_range,
               #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
               #parm3=Send(use_weapon,@GetIndef),
               #parm4=Send(use_weapon,@GetName));
      }
      else
      {
         if IsClass(stroke_obj,&spell)
         {
            if IsClass(stroke_obj,&RadiusEnchantment)
            {
               return;
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_SPELL_range,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                  #parm3=Send(stroke_obj,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_PUNCH_range,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                  #parm3=Send(stroke_obj,@GetName));
         }
      }

      return;
   }

   SendNoLineOfSightMessage()
   {
      Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);
      return;
   }

   GetMoneyObject()
   {
      local i;

      foreach i in plPassive
      {
         if IsClass(i,&Money)
         {
            return i;
         }
      }

      return $;
   }

   % Returns wielded Melee/Ranged weapon.
   LookupPlayerWeapon()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Weapon)
         {
            return i;
         }
      }

      return $;
   }

   LookupPlayerShield()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Shield)
            AND Send(i,@GetBlockAbility,#who=self) > 0
         {
            return i;
         }
      }

      return $;
   }

   LeaveHold(what = $)
   {
      local i;

      % in case it's on the list of window overlays 
      Send(self,@RemoveWindowOverlayObject,#what=what);

      % in case it set our icon
      if poIcon_set = what
      {
         Send(self,@ResetPlayerIcon);
      }

      % in case it removed our hair
      if poHair_remove = what
      {
         Send(self,@ResetHair);
      }

      % in case it set our legs
      if poLegs_set = what
      {
         Send(self,@ResetPlayerLegs);
      }

      if poArms_set = what
      {
         Send(self,@ResetPlayerArms);
      }

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            % implied by drop: Send(self,@NewUnusing,#what=what)
            Send(what,@NewUnused,#what=self);

            break;
         }
      }

      propagate;
   }

   GetPlayerUsing()
   {
      return plUsing;
   }

   GetEquippedItems()
   {
      return Send(self,@GetPlayerUsing);
   }

   IsUsingA(class=$)
   {
      local i;

      if class = $
      {
         return FALSE;
      }

      if GetListElemByClass(plUsing, class)
      {
         return TRUE;
      }

      return FALSE;
   }

   FindUsing(class=$)
   "Find the first instance of 'class' that player has equipped. "
   "Returns $ if nothing is found."
   {
      local i;

      if class = $
      {
         return $;
      }

      return GetListElemByClass(plUsing, class);
   }

   ChooseArmorPosition()
   "Defense now chooses a body place at random, and checks to see if the "
   "defender has any defense value there. Much better than random pattern "
   "of previous combat."
   {
      local rand, armor_pos;

      rand = random(1,12);
      armor_pos = 0;

      if rand < 6
      {
         return ITEM_USE_BODY;
      }

      if rand < 8
      {
         return ITEM_USE_LEGS;
      }

      if rand < 9
      {
         return ITEM_USE_HEAD;
      }

      if rand < 10
      {
         return ITEM_USE_GAUNTLET;
      }

      % Default position: shield
      return -1;
   }

   GetDefenseModifier()
   "Returns a number from 0-100."
   {
      local armor_mod, armor_pos, i, shirt;

      armor_mod = 0;
      armor_pos = Send(self,@ChooseArmorPosition);

      if armor_pos = -1
      {
         foreach i in plUsing
         {
            if IsClass(i,&Shield)
            {
               return i;
            }
         }

         return $;
      }
      else
      {
         if armor_pos & ITEM_USE_BODY
         {
            shirt = $;
            foreach i in plUsing
            {
               if Send(i,@GetItemUseType) & armor_pos
               {
                  return i;
               }
               if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
               {
                  shirt = i;
               }
            }

            return shirt;
         }
         else
         {
            foreach i in plUsing
            {
               if Send(i,@GetItemUseType) = armor_pos
               {
                  return i;
               }
            }
         }

         return $;
      }

      return $;
   }

   CalculateHealthTime()
   "Calculate # of milliseconds until user will gain a health point"
   {
      local iTime, iMaxHealth, lRadiusState;

      % Faster regen with higher vigor
      iTime = ((200-piVigor)*(200-piVigor))/6 + 1000;

      iTime = ((125-Send(self,@GetStamina)) * iTime)/100;
      iMaxHealth = bound(Send(self,@GetMaxHealth),40,100);
      iTime = (iTime *100)/iMaxHealth;

      iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                           #who=self,#hpregen=TRUE);

      iTime = bound(iTime,1000,60000);

      if Send(self,@GetStance) <> $
      {
         iTime = Send(Send(self,@GetStance),@ModifyRegenerationTime,#who=self,#iTime=iTime);
      }

      return iTime;
   }

   CalculateManaTime()
   "Calculate # of milliseconds until user will gain a mana point"
   {
      local iTime, oSpell, iSpellPower, i;

      if piMana > piBaseMax_mana
      {
         iTime = BOOST_DECAY_TIME;
      }
      else
      {
         iTime = BASE_REGEN_TIME + (25-Send(self,@GetMysticism))*1000;
         iTime = iTime * 200 / bound(piVigor,1,$);
         iTime = iTime/ bound(piBaseMax_mana,1,$);

         iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                              #who=self,#hpregen=FALSE);

         iTime = Bound(iTime,1000,60000);

         % Mana Focus will adjust mana regen time based on its spellpower.
         % Flag check for speed.
         if piFlags & PFLAG_MANA_FOCUS
         {
            oSpell = Send(SYS,@FindSpellByNum,#Num=SID_MANA_FOCUS);
            % Spellpower is returned directly from this.
            iSpellPower = Send(self,@GetEnchantedState,#what=oSpell);
            % Mana Focus bounds this to 500-60000 ms.
            iTime = Send(oSpell,@AdjustManaTime,#iSpellPower=iSpellPower,
                           #time=iTime);
         }
      }

      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Hex)
      {
         iTime = Send(Nth(i,2),@ModifyManaRegenTime,
                              #state=Nth(i,3),#regen=iTime);
      }

      if Send(self,@GetStance) <> $
      {
         iTime = Send(Send(self,@GetStance),@ModifyRejuvenationTime,#who=self,#iTime=iTime);
      }

      return iTime;
   }

   ReqEatSomething(filling = 0, what = $)
   {
      % This is the only place we need piStomach to be correct
      Send(self,@UpdateStomach);

      if (piStomach + filling) > piStomachMax
      {
         if what = $ OR NOT Send(what,@IsBeverage)
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full_drink);
         }

         return FALSE;
      }

      return TRUE;
   }

   EatSomething(nutrition = 0, filling = 0)
   {
      Send(self,@AddExertion,#amount=-10000*nutrition);
      piStomach = piStomach + filling;

      return;
   }

   LoseUnboundEnergy()
   {
      local iReduction;

      if NOT Send(self,@IsInCannotInteractMode)
      {
         iReduction = Bound(piUnbound_energy * Send(SETTINGS_OBJECT,@GetUnboundDecay)
                           / 1000,1,$);
         piUnbound_energy = piUnbound_energy - iReduction;
      }

      Send(self,@NewUnboundEnergy);

      return;
   }

   LoseHealth(amount = $, decay = FALSE, precision = FALSE)
   "decay = TRUE if you lose a HP over time because you are boosted over max "
   "by some sort of vamp effect. If this is true, you shouldn't break a trance."
   {
      if NOT precision
      {
         amount = amount*100;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if NOT decay
      {
         Post(self,@BreakTrance,#event=EVENT_DAMAGE);
      }

      piHealth = piHealth - amount;
      Send(self,@NewHealth);

      return;
   }

   GainHealth(amount = $, precision = FALSE)
   "Some attempt here to quell the vamp touch bugs"
   {
      if NOT precision
      {
         amount = amount*100;
      }

      if NOT Send(self,@IsInCannotInteractMode)
      {
         if (200*Send(self,@GetMaxHealth)) < (piHealth+amount)
         {
            Send(self,@MsgSendUser,#message_rsc=player_health_gain_maxed);
            piHealth = 200 * Send(self,@GetMaxHealth);
         }
         else
         {
            piHealth = piHealth + amount;
         }
      }

      Send(self,@NewHealth);

      return;
   }

   GainHealthNormal(amount = $, precision = FALSE)
   "Don't add beyond piMax_health"
   {
      local iOldhealth, iMantled, iMantledDivisor;

      if amount = $
      {
         Debug("Player ",Send(self,@GetTrueName)," had GainHealthNormal called",
               " with amount = $! Precision was ",precision);

         return;
      }

      if NOT precision
      {
         amount = amount*100;
      }

      iOldhealth = piHealth;

      iMantled = Send(self,@GetStatusEffect,#type=STATUS_MANTLED);
      if iMantled > 0
      {
         iMantledDivisor = Send(SETTINGS_OBJECT,
                            @GetElementalMultiple,#type=STATUS_MANTLED);
         amount = amount - (iMantled/iMantledDivisor)*100;
      }

      if amount < 1
      {
         return 0;
      }

      if piHealth > Send(self,@GetMaxHealth)*100
      {
         return 0;
      }

      if NOT Send(self,@IsInCannotInteractMode)
      {
         pihealth = piHealth + amount;
         if piHealth > Send(self,@GetMaxHealth)*100
         {
            piHealth = Send(self,@GetMaxHealth)*100;
         }
      }

      Send(self,@NewHealth);

      return (piHealth - iOldhealth);
   }

   NewUnboundEnergy(bDelay = FALSE)
   {
      if piUnbound_energy < 0
      {
         piUnbound_energy = 0;
      }

      if ptUnboundEnergy = $
      {
         if piUnbound_energy > 0
         {
            if bDelay
            {
               ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,
                                       Send(SETTINGS_OBJECT,@GetUnboundDelay));
            }
            else
            {
               ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,1000);
            }
         }
      }
      else if piUnbound_energy = 0
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = $;
      }
      else if bDelay
      {
         DeleteTimer(ptUnboundEnergy);
         ptUnboundEnergy = CreateTimer(self,@UnboundEnergyTimer,
                                 Send(SETTINGS_OBJECT,@GetUnboundDelay));
      }

      Send(self,@DrawUnboundEnergy);

      return;
   }

   NewHealth()
   {
      if piHealth > 0
         AND piHealth < (ZEALOUS_FERVOR_THRESHOLD * (Send(self,@GetMaxHealth)*100))/100
         AND ptZealousFervor = $
         AND pbLogged_on
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_ZEALOUS_FERVOR) > 0
         AND Send(Send(SYS,@FindSkillByNum,#num=SKID_ZEALOUS_FERVOR),@DoSkill,#who=self)
      {
         Send(self,@StartZealousFervor);
      }

      if piHealth < 0
      {
         piHealth = 0;
      }

      % Keep health from going above natural max if affected by Mark of Dishonor.
      if piHealth > piBase_Max_health*100
         AND Send(self,@IsEnchanted,#byClass=&MarkOfDishonor)
      {
         piHealth = piBase_Max_health*100;
      }

      if ptHealth = $
      {
         if piHealth <> Send(self,@GetMaxHealth)*100
            AND piHealth > 0
         {
            ptHealth = CreateTimer(self,@HealthTimer,Send(self,@CalculateHealthTime));
         }
      }
      else
      {
         if piHealth = Send(self,@GetMaxHealth)*100
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }
      }

      Send(self,@DrawHealth);

      return;
   }

   GainLight(amount = $)
   "Adds <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight + amount;
      Send(self,@RecalcLight);

      return amount;
   }

   LoseLight(amount = $)
   "Subtracts <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight - amount;
      Send(self,@RecalcLight);

      return amount;
   }

   NewLight()
   "Call this everytime player light is changed."
   {
      Send(self,@SourceLightChanged);

      return;
   }

   GainBaseMaxHealth(amount = 0)
   {
      local iPrev_max, iApparentStamina;

      iPrev_max = piBase_max_health;

      % To deal with potential valid HP being stripped if the player has
      % a temporary negative stamina modifier, we need to check if
      % piStaminaMod is negative and if so, use just the raw stamina itself.
      if piStaminaMod >= 0
      {
         iApparentStamina = Send(self,@GetStamina);
      }
      else
      {
         iApparentStamina = Send(self,@GetRawStamina);
      }

      piBase_max_health = Bound(piBase_max_health + amount, 20,(100 + iApparentStamina));
      amount = piBase_max_health - iPrev_max;

      if amount < 0
      {
         % We LOST health!
         Send(self,@MsgSendUser,#message_rsc=lost_base_max_health_msg,#parm1=amount*-1);
      }

      % Give them the "further info" gmail if they've advanced to 25.
      if piBase_Max_health = 25
         AND amount > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_tutorial_mail]);
      }

      Send(self,@PlayerIsIntriguing);
      Send(self,@GainMaxhealth,#amount=amount);
      
      Post(self,@ComputeMaxMana);
      
      Post(Send(SYS,@GetGameQuestMaintenance),@EvaluatePlayer,#who=self,#vbTriggered=TRUE);

      return;
   }

   GainMaxHealth(amount = 0)
   "Call this any time you modify piMax_health, to set stuff on the user's "
   "display, and make sure the value doesn't get too high.  Returns "
   "actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_health;
      piMax_health = bound(piMax_health + amount, 20, $);

      %  no longer reset health to max - will need to test for abusability
      %     the motivation for this originated in using a circlet with health > max_health,
      %     which would erase hp boons or vamptouch gains - kinda mean.
      %     thought about preserving (health - max_health):
      %           OOOOOOOOOOOOOOOOOOOOoooooo       (o is health above max)
      %     -->   OOOOOOOOOOOOOOOOoooooo
      %     but in parallel with this scheme, we should also do:
      %           OOOOOOOOOOOOOO......             (. is space to max)
      %     -->   OOOOOOOOOO......
      %     which could result in death!
      %     the behavior could be made assymetrical,
      %           OOOOOOOOOOOOOO......
      %     -->   OOOOOOOOOOOOOO..
      %     but what about this case?
      %           OOOOOOOOOOOOOOOOO...    or    OOOOOOOOOOOOOOOOO...
      %     -->   OOOOOOOOOOOOOOOOo             OOOOOOOOOOOOOOOO
      %     the left is obviously abusable - compound it with the first gain above,
      %     and by putting on and removing a circlet we gain health!
      %     the right might be ok, and is closest to the current scheme,
      %     but this introduces even more assymmetry and thus makes me nervous.
      %     so my first pass is to do nothing to health here:
      %
      %if piHealth > piMax_health { piHealth = piMax_health; }
      %
      %     if this becomes undesirable, use this new code:
      %if piHealth > iPrev_max { piHealth = piMax_health + (piHealth - iPrev_max); }
      %else { piHealth = bound(piHealth, $, piMax_health); }

      Send(self,@NewHealth); % in case need heal timer

      return piMax_health - iPrev_max;
   }

   GetInitialMaxMana()
   {
      return 68;
   }

   StripNodeList(number=$)
   {
      local nodelist, count;

      nodelist = Send(self,@GetNodelist);

      if number = $
      {
         number = length(nodelist);
      }

      count = 1;

      while nodelist >=1
      {
         if ((nodelist/2)*2) <> nodelist  %we do an "# was odd" operator
         {
            Send(Send(SYS,@FindNodeByNum,#num=count),@UnMeld,#who=self);
         }
         count = count*2;
         nodelist = nodelist/2;
      }

      Send(self,@ResetNodeList);
      Send(self,@NewMana);

      return;
   }

   StripOneNode(report=TRUE)
   {
      local lNodes, index, bFaerieNode, bQNode, oNode;

      if piNodeList = 0
      {
         return;
      }

      lNodes = $;
      index = 1;
      bFaerieNode = FALSE;
      bQNode = FALSE;

      while index <= NODE_MAX_VALUE
      {
         if piNodelist & index
         {
            if index = NODE_FAERIE
            {
               bFaerieNode = TRUE;
            }
            else
            {
               if index = NODE_Q
               {
                  bQNode = TRUE;
               }
               else
               {
                  lNodes = cons(index,lNodes);
               }
            }
         }

         index = index * 2;
      }

      if lNodes = $
      {
         % No nodes; let's rip out one of the special ones, then.
         if bFaerieNode
         {
            lNodes = Cons(NODE_FAERIE,lNodes);
         }
         if bQNode
         {
            lNodes = Cons(NODE_Q,lNodes);
         }
      }

      if lNodes
      {
         index = Nth(lNodes,random(1,length(lNodes)));
         oNode = Send(SYS,@FindNodeByNum,#num=index);
         Send(oNode,@UnMeld,#who=self);

         if report
         {
            Post(self,@MsgSendUser,#message_rsc=player_lose_node,
                 #parm1=Send(oNode,@GetLocationName));
         }
      }

      Send(self,@NewMana);

      return;
   }

   RemoveNodeFromList(node_num=0)
   {
      piNodelist=piNodelist & ~node_num ;

      return;
   }

   ResetNodeList()
   {
      piNodelist = 0;

      return;
   }

   NewMaxMana(amount=0,node_num=-1)
   "This is called from the mana node.  Unlike newMaxHealth, the amount is "
   "checked here.  Returns actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_mana;
      if amount > 0 AND node_num <> -1
      {
         piNodelist = piNodelist | node_num;
      }

      if amount < 0 AND node_num <> -1
      {
         if piNodelist & node_num
         {
            piNodelist = piNodelist & ~node_num;
         }
         else
         {
            Debug("BAD: missing node_num from nodelist in mana adjust.",self);
         }
      }

      piMax_Mana = piMax_mana+amount;
      Post(self,@ComputeMaxMana);

      return (piMax_mana - iPrev_max);
   }

   ComputeMaxMana()
   {
      local index, iNodeList, oNode, i, oCrystalizeMana, iCrystalizeManaAbility,
            iSumPercentReduction;

%      index = 1;
%      iNodelist = piNodelist;

%      while iNodeList > 0 AND index <= NODE_MAX_VALUE
%      {
%         if (iNodeList & index)
%         {
%            oNode = Send(SYS,@FindNodeByNum,#num=index);
%            piMax_mana = piMax_mana + Send(oNode,@GetManaAdjust,#who=self);
%            iNodelist = iNodelist & ~index;
%         }
%         index=index*2;
%      }
%
%      13 nodes technically
%      equation was: (((5 + Send(who,@GetMysticism)) / 10) + 3)

      % New equation simply adds your Mysticism, unlocked as you gain health
      piMax_mana = Send(self,@GetInitialMaxMana) + ((Send(self,@GetMysticism)*piBase_Max_Health)/(100+Send(self,@GetStamina)));

      % Account for any items that may affect max mana
      foreach i in plUsing
      {
         if Send(i,@AdjustsMaxMana)
         {
            piMax_mana = piMax_mana + Send(i,@GetManaChange);
         }
      }

      foreach i in plEnchantments
      {
         if Send(Nth(i,2),@AffectsMaxMana)
         {
            piMax_mana = piMax_mana + Send(Nth(i,2),@GetManaBonus,
                                          #state=Nth(i,3));
         }
      }

      oCrystalizeMana = Send(SYS,@FindSpellByNum,#num=SID_CRYSTALIZE_MANA);
      iCrystalizeManaAbility = Send(self,@GetSpellAbility,
                                    #spell_num=SID_CRYSTALIZE_MANA);

      if oCrystalizeMana <> $
         AND iCrystalizeManaAbility <> 0
      {
         piMax_mana = piMax_mana + Send(oCrystalizeMana,@GetManaBonus,
                                       #spell_ability=iCrystalizeManaAbility);
      }

      %if Send(self,@IsCrystalizeManaSurging)
      %{
      %   piMax_mana = Send(self, @GetInitialMaxMana);
      %}

      piBaseMax_mana = piMax_mana;
      
      iSumPercentReduction = 0;
      foreach i in plReservedSpells
      {
         iSumPercentReduction = iSumPercentReduction + Nth(i,2);
      }
      iSumPercentReduction = Bound(iSumPercentReduction,0,100);

      piMax_mana = piMax_mana - (piMax_mana * iSumPercentReduction)/100;

      % Here we iteratively check the player has enough max mana left after percentage reservations.
      % Cancel any reserved song that fails.
      foreach i in plReservedSongs
      {
         if Nth(i,2) > piMax_mana
         {
            Post(self,@MsgSendUser,#message_rsc=lose_song_due_to_mana_change_msg);
            Post(self,@UnReserveSong,#oSpell=Nth(i,1));
         }
         else
         {
            piMax_mana = piMax_mana - Nth(i,2);
         }
      }

      Send(self,@NewMana);

      return;
   }

   NumManaNodes()
   {
      local i, n;

      n = 0;
      i = 1;

      while i <= NODE_MAX_VALUE
      {
         if piNodelist & i
         {
            n = n + 1;
         }

         i = 2 * i;
      }

      return n;
   }

   GetNodeList()
   "Returns the list of nodes that a player has successfully melded with."
   {
      return piNodelist;
   }


   GetSpellList()
   {
      return plSpells;
   }

   % These next three functions handle school casts.

   % This message handles adding a weighted cast to the school casts list.
   AddSchoolCast(school=$, amount=$)
   {
      local iToAdd;

      if plSchoolCasts = $
      {
         % 18 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > Length(plSchoolCasts)
         OR amount = $
      {
         return;
      }

      iToAdd = amount;

      SetNth(plSchoolCasts,school,(Nth(plSchoolCasts,school)+iToAdd));

      return;
   }

   % This message returns the appropriate school cast amount from the list.
   GetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return 0;
      }

      return Nth(plSchoolCasts,school);
   }

   % This message resets the weighted cast count back to 0.
   ResetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return;
      }

      SetNth(plSchoolCasts,school,0);

      return;
   }

   GetNumAbilityPointsInSchool(school=0)
   {
      if school = 0
         OR plSchools = $
      {
         return 0;
      }

      return Nth(plSchools,school);
   }

   GetNumSpellsInSchool(school = 0)
   "Used by the advancement checker to see the odds of a player advancing."
   {
      local num, i, oSpell;

      num = 0;
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
               #num=Send(self,@DecodeSpellNum,#compound=i));
         if school = Send(oSpell,@GetSchool)
         {
            ++num;
         }
      }

      return num;
   }

   GetSkillList()
   {
      return plSkills;
   }

   GetHealth()
   {
      return piHealth/100;
   }

   GetExactHealth()
   {
      return piHealth;
   }

   SetHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount*100,0,$);
      }

      Send(self,@DrawHealth);

      return;
   }

   SetExactHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount,0,$);
      }
      
      return;
   }

   GetMight()
   {
      return bound((piMight + piMightMod),1,MAXIMUM_STAT);
   }

   GetIntellect()
   {
      return bound((piIntellect + piIntellectMod),1,MAXIMUM_STAT);
   }

   GetAgility()
   {
      return bound((piAgility + piAgilityMod),1,MAXIMUM_STAT);
   }

   GetAim()
   {
      return bound((piAim + piAimMod),1,MAXIMUM_STAT);
   }

   GetStamina()
   {
      return bound((piStamina + piStaminaMod),1,MAXIMUM_STAT);
   }

   GetMysticism()
   {
      return bound((piMysticism + piMysticismMod),1,MAXIMUM_STAT);
   }

   GetRawMight()
   {
      return bound(piMight,1,Send(self,@GetMaxMight));
   }

   GetRawIntellect()
   {
      return bound(piIntellect,1,Send(self,@GetMaxIntellect));
   }

   GetRawAgility()
   {
      return bound(piAgility,1,Send(self,@GetMaxAgility));
   }

   GetRawAim()
   {
      return bound(piAim,1,Send(self,@GetMaxAim));
   }

   GetRawStamina()
   {
      return bound(piStamina,1,Send(self,@GetMaxStamina));
   }

   GetRawMysticism()
   {
      return bound(piMysticism,1,Send(self,@GetMaxMysticism));
   }

   GetMaxMight()
   {
      return 50 + piRacialMightMod;
   }
   
   GetMaxIntellect()
   {
      return 50 + piRacialIntellectMod;
   }
   
   GetMaxStamina()
   {
      return 50 + piRacialStaminaMod;
   }
   
   GetMaxAgility()
   {
      return 50 + piRacialAgilityMod;
   }
   
   GetMaxMysticism()
   {
      return 50 + piRacialMysticismMod;
   }
   
   GetMaxAim()
   {
      return 50 + piRacialAimMod;
   }

   GetKarma()
   "Returns karma in natural units"
   {
      return piKarma/100;
   }

   GetVigor()
   {
      return piVigor;
   }

   AddKarma(amount = 0)
   "Adds argument (which must be in hundredths of karma units) to karma"
   {
      piKarma = piKarma + amount;
      Send(self,@NewKarma);

      return;
   }

   LoseKarma(amount = 0)
   {
      piKarma = piKarma - 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   GainKarma(amount = 0)
   {
      piKarma = piKarma + 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   NewKarma()
   {
      if piKarma < -10000
      {
         piKarma = -10000;
      }

      if piKarma > 10000
      {
         piKarma = 10000;
      }

      Send(self,@DrawKarma);

      return;
   }

   SetKarma(value = 0)
   "Changes karma to specified amount"
   {
     piKarma = value;
     Send(self,@NewKarma);

     return;
   }

   CalculateKarmaChangeFromAct( karma_doer=$, karma_act=$, Swing_factor = 1)
   {
      local iBase, iChange;

      if karma_doer = $ OR karma_act = $
      {
         return 0;
      }

      % Neutral mobs and event mobs do not change karma
      if karma_act = 0
      {
         return 0;
      }

      % Do not change karma if player is good, act is good, but not as
      % good as player. I.e. only change karma if good player does bad
      % stuff (or vice versa).
      if (karma_doer > 0 AND karma_act > 0 AND karma_doer > karma_act)
      OR (karma_doer < 0 AND karma_act < 0 AND karma_doer < karma_act)
      {
         return 0;
      }

      iBase = karma_doer  - karma_act;

      iChange = - ((iBase*iBase*ibase)/2500 + (5*iBase));

      % Swing factor must be a number from 1 to 10
      swing_factor = bound(swing_factor,1,10);

      return (iChange / (11 - swing_factor));
   }

   CalculateKarmaChangeFromKill(karma_killer=0,karma_victim=0,bIsMob=FALSE)
   {
      local iChange, iSwing, oSpellDeathLink;

      % No karma change in survival room. Mobs in this room *should*
      % return 0 karma, but there are cases where it doesn't happen.
      if poOwner <> $
         AND IsClass(poOwner,&SurvivalRoom)
      {
         return 0;
      }

      % No karma changes from killing players during Frenzies.
      % Also, no Karma change from event monsters: Xeos and admin-spawned.
      if (Send(SYS,@GetChaosNight) AND NOT bIsMob)
         OR karma_victim = $
      {
         return 0;
      }

      % No karma changes in the newbie area. Otherwise e.g. killing a negative
      % karma monster may make your spell inoperable.
      if poOwner <> $
         AND Send(poOwner,@GetRegion) = RID_NEWB_BASE
      {
         return 0;
      }

      % No karma changes from killing neutral monsters.
      if bIsMob AND karma_victim = NEUTRAL
      {
         return 0;
      }

      % Death link prevents karma changes
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#num=SID_DEATH_LINK);
      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         return 0;
      }

      % Execrate prevents karma changes
      if Send(self,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE))
      {
         return 0;
      }

      % A kill is merely an act, like all other acts, with the
      % strongest swing factor possible.  The karma of a kill
      % is equal to the negative karma of the person who died -
      % thus, killing someone with 100 karma is a -100 karma act.
      if bIsMob
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingMonster);
      }
      else
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingPlayer);
      }

      % Okay, let's give them a break if they are moving towards
      % neutrality, and they've just killed a monster.  This happens,
      % for example, if a player with 20 karma kills a monster with
      % -10.  It moves the player towards 10, but at a slower pace.

      if bIsMob
      {
         if (karma_killer > 0) <> (karma_victim > 0)
            AND (abs(karma_killer) > abs(karma_victim))
         {
            iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingNeutral);
         }
      }

      iChange = Send(self,@CalculateKarmaChangeFromAct,#karma_doer = karma_killer,
                     #karma_act = -(karma_victim),#swing_factor = iSwing);

      if bIsMob
      {
         iChange = Bound(iChange,-150,150);
      }

      return iChange;
   }

   %%% Guild Command Stuff

   RemoveAllGuildCommands()
   "Removes all of the player's guild commands from him."
   {
      piGuild_commands = 0;

      return;
   }

   HasGuildCommand(command_num=0)
   "This always checks to be sure that the flag exists."
   {
      return (piGuild_commands & command_num);
   }

   AddGuildCommand(command_num = 0)
   "Adds a guildcommand to player's arsenal.  Usually called by resetpowers"
   "in guild.kod."
   {
      local oCommand;

      if Send(self,@HasGuildCommand,#command_num=command_num)
      {
         return FALSE;
      }
      piGuild_Commands = piGuild_Commands | command_num;

      return TRUE;
   }

   RemoveGuildCommand(command_num=0)
   {
      piGuild_commands = piGuild_commands & ~command_num;

      return;
   }

   SetGuild(guild_obj=$)
   "Sets the player's poGuild to be equal to the guild object."
   {
      poGuild = guild_obj;
      Send(self,@EvaluatePKStatus,#dbug=TRUE);

      return;
   }

   QuitGuild()
   "Call this if you're an admin trying to kick someone out of a guild."
   "This will tell the guild to delete the user."
   {
      if poGuild <> $
      {
         Send(poGuild,@RemoveFromGuild,#who=self);
      }

      return;
   }

   ResetGuildStuff()
   "This should never be called directly, except from 'RemoveFromGuild' in"
   "guild.kod!  Otherwise, the guild lists may not match with player's poGuild!"
   {
      poGuild = $;
      piGuild_commands = 0;
      if poOwner <> $ AND Send(poOwner,@GetWatcher) <> $
      {
         Send(Send(poOwner,@GetWatcher),@PlayerQuitGuild,#who=self);
      }

      return;
   }

   %%%  Spells Stuff

   HasSpell(num = 0)
   "Returns TRUE if a spell is in a player's spell list,"
   "FALSE if it is not."
   {
      local i,oSpell;

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSpell(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used=TRUE
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSpellNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSpellAbility(compound = 0)
   {
      return Abs(compound) MOD 100;
   }

   GetSpellAbility(spell_num = 0)
   {
      local i;

      foreach i in plSpells
      {
         if Abs(i) / 100 = spell_num
         {
            return Abs(i) MOD 100;
         }
      }

      % This spell is not in the player's spell list. Return 0 ability.
      return 0;
   }

   ChangeSpellAbility(spell_num = 0, amount = 0, report = FALSE,
                      refigureschools = TRUE)
   {
      local i, bFound, elemNum, iAbility, bUsed, spellName, iChange,
            newAbility, oSpell, shrunken;

      oSpell = Send(SYS,@FindSpellByNum,#num=spell_num);
      if oSpell = $
      {
         return FALSE;
      }

      % Make sure user has this spell (should always have it if this is being called)
      bFound = FALSE;
      elemNum = 0;
      spellName = Send(oSpell,@GetName);
      iChange = 0;

      % Do _not_ replace with HasSpell.
      % This also finds the spell/ability pair and puts it in 'i' for later use.
      foreach i in plSpells
      {
         ++elemNum;
         if spell_num = Send(self,@DecodeSpellNum,#compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % Can't advance a spell you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if NOT bUsed
      {
         bUsed = -1;
      }

      iAbility = Send(self,@DecodeSpellAbility,#compound=i);
      newAbility = bound(iAbility+amount,1,99);
      iChange = newAbility-iAbility;

      SetNth(plSpells,elemNum,Send(self,@EncodeSpell,
            #num=spell_num,#iAbility=newAbility));
      Send(self,@DrawStatSpell,#index=elemNum);
      if report AND iChange > 0
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=spellName);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);

            % Report to shrunken head.
            shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
            if shrunken <> $
            {
               Send(shrunken,@Improvement,#spellName=spellName);
            }
         }
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),#change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed in spell ability of ",spellname,
               " by ",iChange," to ",abs(i));
      }

      return TRUE;
   }

   AddToSchools(school=0, change=0)
   {
      local iOldValue, oLore;

      if school = $
         OR school < 1
         OR change = $
         OR change = 0
      {
         return FALSE;
      }

      if plSchools = $
      {
         % 11 elements right now.
         plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      while length(plSchools) < school
      {
         plSchools = cons(0, plSchools);
      }

      iOldValue = Nth(plSchools,school);
      SetNth(plSchools,school,(iOldValue+change));

      oLore = Send(SYS,@GetLore);
      Send(oLore,@PlayerAdvanced,#who=self,#school = school);

      return TRUE;
   }

   RefigureSchoolsLists(informlore=FALSE)
   {
      local i, lOldList, oAbility, iSchool, iAbility, iValue, oLore, bChanged,
            index, iNum;

      lOldList = plSchools;

      % 18 elements right now.
      plSchools = [ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

      foreach i in plSpells
      {
         iAbility = Send(self,@DecodeSpellAbility,#compound=i);
         iNum = Send(self,@DecodeSpellNum,#compound=i);
         oAbility=Send(SYS,@FindSpellByNum,#num=iNum);
         if IsClass(oAbility,&spell)
         {
            iSchool = Send(oAbility,@GetSchool);
            if iSchool = $
            {
               debug(GetClass(oAbility));
               continue;
            }
            iValue = Nth(plSchools,iSchool);
            SetNth(plSchools,iSchool,(iValue+iAbility));
         }
      }

      foreach i in plSkills
      {
         oAbility=Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oAbility,@GetSchool);
         iAbility = Send(self,@DecodeSkillAbility,#compound=i);
         iValue = Nth(plSchools,iSchool);
         SetNth(plSchools,iSchool,(iValue+iAbility));
      }

      if informlore OR lOldList = $
      { 
         % Assume that something has changed
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school = iSchool);
         
         return;
      }

      % We want to know if something has changed.
      bChanged = FALSE;
      index = 0;
      foreach i in lOldList
      {
         index = index + 1;
         if Nth(lOldList,index) <> Nth(plSchools,index)
         {
            bChanged = TRUE;
         }
      }

      % If they changed, update them in the lore.
      if bChanged
      {
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school=-1);
      }

      return TRUE;
   }

   AdminSetSpell(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a spell by an additional or absolute value."
   {
      local oSpell, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSpellAbility,#spell_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSpell,#num=num,#iability=ability)
         {
            return player_admin_added_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 and add <= -oldAbility
      {
         if Send(self,@RemoveSpell,#num=num)
         {
            return player_admin_removed_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 and add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSpellAbility,#spell_num=num,#amount=add)
      {
         return player_admin_modified_spell;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSpell(num = 0, iability=0, bDM=FALSE, initial=FALSE, dontSend=FALSE)
   "Admin supported\n"
   "Adds a spell by spell ID to the user's castable list of spells"
   {
      local i, j, oSpell, lSpell_info, lPrereqs, bFound,
            iBoundAbility, lEncode, iPrevLearnPoints;

      if Send(self,@HasSpell,#num=num)
      {
         if Send(self,@GetSpellAbility,#spell_num=num) < iAbility
         {
            Send(self,@ChangeSpellAbility,#spell_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

%  When I re-enabled the shadow rift spell, it was only sold by the lich,
%  and the Ao3/SotH quest that was needed to get the spell was broken and unfixable,
%  so I made the spell sold by a different NPC.  I had to remove this check
%  (which clearly doesn't belong in player; should be in the spell itself) to
%  make it buyable.  - ARK 10/26/2010
%
%      if num = SID_DEATHS_DOOR
%          AND ((NOT Send(self, @IsUsingA,#class=&NecromancerAmulet))
%               AND (NOT IsClass(self,&Admin)))
%      {
%         return FALSE;
%      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return FALSE;
      }
      
      lPrereqs = Send(oSpell,@GetPrerequisites);

      foreach i in lPrereqs
      {
         if NOT Send(self,@HasSpell,#num=i)
         {
            %Player can't learn this spell without all the prerequisites.
            return FALSE;
         }
      }

      iPrevLearnPoints = Send(self,@GetTotalLearnPoints);

      % Spell format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSpell,@InitialAbility,#who=self);
      }

      lEncode = Send(self,@EncodeSpell,#num=num,#iability=iBoundAbility);
      plSpells = Cons(lEncode,plSpells);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added spell ",Send(oSpell,@GetName));
      }

      if dontSend = FALSE
      {
         Send(self,@ToCliAddSpell,#oSpell=oSpell);
      }

      if NOT bDM
         AND NOT initial
      {
          Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),
               #change=iBoundAbility);
      }

      if poOwner <> $
         AND NOT bDM
         AND NOT dontSend
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
              #wave_rsc=player_sound_learn_spell);
      }

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@PlayerIsIntriguing);
      
      if iPrevLearnPoints <> Send(self,@GetTotalLearnPoints)
      {
         % We've just learned a new level.
         Post(self,@ReportReincarnationProgress);
      }

      return TRUE;
   }

   RemoveAllSpells()
   {
      local i;
      
      plSpells=$;
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," lost all spells.");
      }

      Send(self,@PlayerIsIntriguing);

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@ToCliStats,#group=3);

      return TRUE;
   }

   RemoveSpellAndCompensate(num = 0, iAmount = 0)
   "Compensates Training Points for spell removed."
   {
      local oSpell, i, j, bFound;

      if IsClass(self,&DM)
      {
         return;
      }

      oSpell = Send(SYS,@FindSpellbyNum,#num=num);
      if oSpell = $
      {
         return;
      }

      bFound = FALSE;
      foreach i in plSpells
      {
         if num = Send(self,@DecodeSpellNum,#compound=i)
         {
            Send(self,@AddTrainingPoints,#points=Send(self,@GetSpellAbility,#spell_num=num)*iAmount,#report=FALSE,#bCap=FALSE);

            plSpells = DelListElem(plSpells,i);

            Send(self,@ToCliRemoveSpell,#oSpell=oSpell);
            Send(self,@PlayerIsIntriguing);

            bFound = TRUE;
            foreach j in plUsing
            {
               if IsClass(j,&DiscipleRobe)
               {
                  Send(j,@ResetColors);
               }
            }

            return;
         }
      }

      return;
   }

   RemoveSpell(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a spell by spell ID from the user's castable list of spells"
   {
      local oSpell, i, j, bFound;

      oSpell = Send(SYS,@FindSpellbyNum,#num=num);
      if oSpell = $
      {
         Debug("Trying to delete a spell that doesn't exist in system.");

         return FALSE;
      }

      bFound = FALSE;
      foreach i in plSpells
      {
         if num = Send(self,@DecodeSpellNum,#compound=i)
         {
            plSpells = DelListElem(plSpells,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," removed spell ",Send(oSpell,@GetName));
            }

            Send(self,@ToCliRemoveSpell,#oSpell=oSpell);
            Send(self,@PlayerIsIntriguing);

            bFound = TRUE;
            foreach j in plUsing
            {
               if IsClass(j,&DiscipleRobe)
               {
                  Send(j,@ResetColors);
               }
            }

            if NOT isDM
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

     Debug("Trying to delete a spell not on spell list",self,num);

     return FALSE;
   }

   WasSpellUsed(compound=0)
   {
      if compound > 0
      {
         return TRUE;
      }

      return FALSE;
   }


   FlipSpellAtrophyFlag(SID=0)
   "This spell was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, spellnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum + 1;
         if Send(self,@DecodeSpellNum,#compound=i) = SID
         {
            SetNth(plspells,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSpellAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSpell, bSpell,
            bFound, highmark, iAmount;

      % Must get below highmark for atrophy to activate
      iAmount = -2;

      foreach i in plSpells
      {
         if i < 0
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            if iAbility > 2
            {
               aSpell = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=i));
               bFound = FALSE;

               foreach j in plSpells
               {
                  bSpell = Send(SYS,@FindSpellByNum,
                        #num=Send(self,@DecodeSpellNum,#compound=j));
                  if j > 0 AND Send(aSpell,@GetSchool) = Send(bSpell,@GetSchool)
                  {
                     iAmount = -1;

                     break;
                  }
               }
               Send(self,@ChangeSpellAbility,#spell_num=Send(aSpell,@GetSpellNum),
                    #amount=iamount);
            }
         }
      }

      return;
   }

   %%%  Skills Stuff

   HasSkill(num = $)
   "Returns TRUE if a Skill is in a player's Skill list,"
   "FALSE if it is not."
   {
      local i,oSkill;

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSkill(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSkillNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSkillAbility(compound = 0)
   {
      return Abs(compound) MOD 100;
   }

   GetSkillAbility(Skill_num = 0, absolute=FALSE)
   {
      local i, iHighestSpiritLink, temp_num;

      % Special stance object that handles multiple spirit link skills
      if Skill_num = SKID_CASTING_STANCE
      {
         iHighestSpiritLink = 0;
         foreach i in plSkills
         {
            temp_num = Abs(i) / 100;
            
            if temp_num = SKID_LINK_ONE
               OR temp_num = SKID_LINK_TWO
               OR temp_num = SKID_LINK_THREE
               OR temp_num = SKID_LINK_FOUR
               OR temp_num = SKID_LINK_FIVE
            {
               if Abs(i) MOD 100 > iHighestSpiritLink
               {
                  iHighestSpiritLink = Abs(i) MOD 100;
               }
            }
         }
         return iHighestSpiritLink;
      }

      foreach i in plSkills
      {
         if Abs(i) / 100 = Skill_num
         {
            return Abs(i) MOD 100;
         }
      }

      % this Skill is not in the player's Skill list.  return 0 ability.
      return 0;
   }

   ChangeSkillAbility(Skill_num=0,amount=0,report=FALSE,refigureschools=TRUE,bDM=FALSE)
   {
      local i, bFound, elemnum, iability, bUsed, iChange, skillname, 
            newability, oSkill;

      oSkill = Send(SYS,@FindSkillByNum,#num=skill_num);
      if oSkill = $
      {
         return FALSE;
      }

      % Make sure user has this Skill (should always have it if this is being called)
      bFound = FALSE;
      elemnum = 0;
      skillname = Send(oSkill,@GetName);
      iChange = 0;

      % Do _not_ replace with HasSkill.
      % This also finds the Skill/ability pair and puts it in 'i' for later use.
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Skill_num = Send(self, @DecodeSkillNum, #compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % Can't advance in a skill you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if bUsed = 0
      {
         bUsed = -1;
      }

      iability = Send(self,@DecodeSkillAbility,#compound=i);
      newability = bound(iability+amount,1,99);
      iChange = newability - iability;

      if Skill_num = SKID_ZEALOUS_FERVOR
      {
         % Remove existing health bonus before we change the skill.
         Send(self,@GainMaxHealth,#amount=-((Send(self,@GetSkillAbility,#Skill_num=SKID_ZEALOUS_FERVOR)+1)/5));
      }

      % If we advance a stroke or a proficiency, then
      % reset our stroke count (and bonuses)
      if IsClass(oSkill,&Stroke) OR IsClass(oSkill,&Proficiency)
      {
         Send(self,@ResetWeaponSwings);
      }

      SetNth(plSkills,elemnum,Send(self,@EncodeSpell,#num=skill_num,
            #iability=newability));
      Send(self,@DrawStatSkill,#index=elemnum);
      if report AND (iChange > 0)
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=skillName);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);
         }
      }

      if Skill_num = SKID_ZEALOUS_FERVOR
      {
         % Add health bonus back with new amount.
         Send(self,@GainMaxHealth,#amount=(Send(self,@GetSkillAbility,#Skill_num=SKID_ZEALOUS_FERVOR)+1)/5);
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed skill ",skillname,"by ",iChange,
               " to ",abs(i)); 
      }

      return TRUE;
   }

   AdminSetSkill(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a skill by an additional or absolute value."
   {
      local oSkill, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if oSkill = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSkillAbility,#skill_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSkill,#num=num,#iability=ability)
         {
            return player_admin_added_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 AND add <= -oldAbility
      {
         if Send(self,@RemoveSkill,#num=num)
         {
            return player_admin_removed_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 AND add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSkillAbility,#skill_num=num,#amount=add)
      {
         return player_admin_modified_skill;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSkill(num=0,iability=0,bDM=FALSE,initial=FALSE,dontSend=FALSE)
   "Admin supported\n"
   "Adds a Skill by Skill ID to the user's castable list of Skills"
   {
      local i,j,oSkill, lSkill_info, lPrereqs, bFound, iBoundAbility, iPrevLearnPoints;

      if Send(self,@HasSkill,#num=num)
      {
         % Already has it.
         if Send(self,@GetSkillAbility,#skill_num=num) < iAbility
         {
            Send(self,@ChangeSkillAbility,#skill_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if (oSkill = $)
      {
         % System has no info on this skill.
         return False;
      }

      iPrevLearnPoints = Send(self,@GetTotalLearnPoints);

      % Skill format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSkill,@InitialAbility,#who=self);
      }

      if num = SKID_ZEALOUS_FERVOR
      {
         Send(self,@GainMaxHealth,#amount=(iBoundAbility+1)/5);
      }

      plSkills = Cons(Send(self,@EncodeSkill,#num=num,
                     #iability=iBoundAbility),plSkills);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added skill ",Send(oSkill,@GetName));
      }

      if NOT dontSend
      {
         Send(self,@ToCliAddSkill,#oSkill=oSkill);
      }

      if NOT bDM and NOT initial
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iBoundAbility);
      }
      
      if iPrevLearnPoints <> Send(self,@GetTotalLearnPoints)
      {
         % We've just learned a new level.
         Post(self,@ReportReincarnationProgress);
      }

      if Send(oSkill,@GetSchool) = SKS_SORCERY
      {
         Send(self,@SetTattooed,#value=TRUE);
      }

      return True;
   }

   RemoveAllSkills()
   {
      % Remove Zealous Fervor first to account for health bonus.
      Send(self,@RemoveSkill,#num=SKID_ZEALOUS_FERVOR);

      plSkills = $;

      if Send(self,@checklog)
      {
         Debug("LOG:  ",vrName," loses all skills.");
      }

      Send(self,@ToCliStats,#group=4);

      return TRUE;
   }

   RemoveSkill(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a Skill by Skill ID from the user's castable list of Skills"
   {
      local oSkill, i;

      oSkill = Send(SYS,@FindSkillbyNum,#num=num);
      if oSkill = $
      {
         Debug("Trying to delete a skill the system doesn't recognize.");

         return FALSE;
      }

      % If we remove Second Wind, we need to adjust the player's
      % resting vigor threshold.
      if num = SKID_SECOND_WIND
      {
         Post(self,@SetVigorRestThreshold);
      }

      foreach i in plSkills
      {
         if num = Send(self,@DecodeSkillNum,#compound=i)
         {
            % If we remove Zealous Fervor, remove the health bonus.
            if num = SKID_ZEALOUS_FERVOR
            {
               Send(self,@GainMaxHealth,#amount=-((Send(self,@GetSkillAbility,#Skill_num=SKID_ZEALOUS_FERVOR)+1)/5));
            }

            plSkills = DelListElem(plSkills,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," lost skill ",Send(oSkill,@GetName));
            }

            Send(self,@ToCliRemoveSkill,#oSkill=oSkill);

            if NOT isDM
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

      %Debug("Tried to delete skill not in skill list",self,num);

      return FALSE;
   }

   FlipSkillAtrophyFlag(SKID=0)
   "This Skill was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, Skillnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Send(self,@decodeSkillNum,#compound=i) = SKID
         {
            SetNth(plSkills,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSkillAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSkill, bSkill,
            bFound, highmark, iAmount;

      iAmount = -2;

      foreach i in plSkills
      {
         if i < 0
         {
            iAbility = Send(self,@decodeSkillability,#compound=i);
            if iAbility > 2
            {
               aSkill = Send(SYS,@FindSkillByNum,
                     #num=Send(self,@DecodeSkillNum,#compound=i));
               bFound = FALSE;
               foreach j in plSkills
               {
                  bSkill = Send(SYS,@FindSkillByNum,
                        #num=Send(self,@DecodeSkillNum,#compound=j));
                  if j > 0 AND Send(aSkill,@GetSchool) = Send(bSkill,@GetSchool)
                     AND aSkill <> bSkill
                  {
                     iAmount=-1;
                     break;
                  }
               }

               Send(self,@ChangeSkillAbility,#skill_num=Send(aSkill,@GetSkillNum),
                    #amount=iAmount);
            }
         }
      }

      return;
   }

   %%%  Advancement

   ResetAtrophyFlags()
   "This sets all of a player's spell values to negative."
   "This means that the player has not used these spells in a while."
   "Meaning they have a chance to atrophy when ptAdvancement goes off."
   {
      local i, elemnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum+1;
         SetNth(plSpells,elemnum,-(abs(i)));
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum+1;
         SetNth(plSkills,elemnum,-(abs(i)));
      }

      return;
   }

   AdvancementTimer()
   "This checks for spell or skill atrophy, "
   "and resets the atrophy flags."
   {
      ptAdvancement = $;

      if pbLogged_on
      {
         if Send(SETTINGS_OBJECT, @IsAtrophyOn)
         {
            Send(self,@ActivateSpellAtrophy);
            Send(self,@ActivateSkillAtrophy);
         }

         Send(self,@ResetAtrophyFlags);
      }

      return;
   }

   %%% Advancement in combat

   SomethingKilled(what=$,victim=$,use_weapon=$)
   {
      local i, bGainedCharge, oSpellDeathLink;

      if NOT IsClass(victim,&Battler)
      {
         propagate;
      }
      
      if what <> $
         AND IsClass(what,&Monster)
         AND Send(what,@GetMaster) <> $
         AND IsClass(Send(what,@GetMaster),&Player)
      {
         % For minions, put the master in place instead.
         what = Send(what,@GetMaster) ;
      }

      % If we have death link up, give a vigor boost
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#Num=SID_DEATH_LINK);

      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         Send(oSpellDeathLink,@GiveKilledBenefits,#Caster=self,#Victim=victim);
      }

      % Let our recharging rods know we killed something.
      if what = self
      {
         bGainedCharge = FALSE;

         foreach i in plPassive
         {
            if IsClass(i,&Rod)
               AND Send(i,@SomethingKilled,#what=what,#victim=victim)
            {
               bGainedCharge = TRUE;
            }
         }

         % Notify the player if he gained a charge on any recharging
         % wand (just one message for all of them)
         if bGainedCharge
         {
            Send(self,@MsgSendUser,#message_rsc=rod_gained_charge_msg);
         }
      }

      if victim = poKill_target
         OR (victim <> $
            AND IsClass(victim,&Monster)
            AND Send(victim,@GetDamageShare,#who=self) > 0)
      {
         if what = self
         {
            Send(self,@AdvancementCheck,#what=victim,#killing_blow=TRUE);
         }
         else
         {
            Send(self,@AdvancementCheck,#what=victim,
                  #killing_blow=FALSE,#group_member=what);
         }

         Send(self,@ResetGainFlags);
      }
      else
      {
         % Let players share XP and TP if they're grouped, even if
         % they're not fighting the same mob.
         if Send(poOwner,@AreGroupedHere,#who=self,#what=what)
         {
            Post(self,@AdvancementCheck,#what=victim,#killing_blow=FALSE,
                  #group_member_kill=TRUE,#group_member=what);
         }
      }

      propagate;
   }

   ResetGainFlags()
   {
      poKill_target = $;
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE, #value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_DODGED, #value=FALSE);

      return;
   }

   AdvancementCheck(what=$,killing_blow=TRUE,group_member_kill=FALSE,group_member=$)
   "A player will need, on average, to kill a number of monsters equal to"
   "their maxhealth to gain a HP.  This number is reduced by the player's"
   "stamina, all the way down to half for those with high staminas."
   {
      local i, dodgeskill, oSkill, monster_level, gain, gainmult, roll,
            oWeapon, lBuilderGroup, bGainedHP, iExperienceSystem, iUnbound,
            iDist, iDifference, bAtMaxHp, iEarnedTrainingPoints, iDamageShare;

      iExperienceSystem = Send(SETTINGS_OBJECT,@GetExperienceSystem);
      gain = 0;
      roll = FALSE;
      bGainedHP = FALSE;
      if Send(self,@GetExperienceNeeded) = 0
      {
         bAtMaxHp = 1;
      }
      else
      {
         bAtMaxHp = 0;
      }
      iDamageShare = Send(what,@GetDamageShare,#who=self);

      % Some things just never allow advancement.
      % Can advance in arena if realdeath is on in an arena.
      if NOT Send(what,@CanPlayerAdvanceOnMe)
         OR Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         OR (Send(poOwner,@IsArena) AND NOT Send(poOwner,@ArenaRealDeath))
      {
         return FALSE;
      }

      if IsClass(what,&User)
      {
         % Set a reasonable upper bound to handle event characters.
         monster_level = Bound(Send(what,@GetBaseMaxHealth),$,1000);
      }
      else
      {
         monster_level = Send(what,@GetLevel);
      }

      if ((piFlags & PFLAG_DID_DAMAGE)
         AND poKill_target = what)
         OR group_member_kill
      {
         % Allow players to improve defensive spells!
         if killing_blow 
            AND ((piFlags & PFLAG_TOOK_DAMAGE)
               OR (piFlags & PFLAG_DODGED))
         {
            foreach i in plPassiveImprovement
            {
               if Nth(i,2) and random(1,5) = 5
               {
                  Send(First(i),@ImproveAbility,#who=self,#target=what);
               }
            }
            foreach i in plReservedSpells
            {
               if Send(Nth(i,1),@IsDefensive) AND Random(1,10) = 10
               {
                  Send(First(i),@ImproveAbility,#who=self,#target=what);
               }
            }
         }

         if monster_level > piBase_Max_health
         {
            %if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
            %   AND Send(SETTINGS_OBJECT,@GetCapModernExperience)
            %{
            %   % Cap XP so player doesn't advance too quickly.
            %   monster_level = Send(self,@GetBaseMaxHealth);
            %}

            if killing_blow
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
            {
               if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
               {
                  % Player took damage and landed killing blow
                  gain = 2;
                  roll = TRUE;
               }
               else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
               {
                  % We killed and fought a stronger monster.
                  % Full XP.
                  gain = monster_level + Send(what,@GetBonusXPGain);
               }
            }
            else
            {
               if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
               {
                  % Player either did not take damage, but did killing blow,
                  %  or did take damage, did not land killing blow, or
                  %  it's a group member kill.
               
                  gain = 1;

                  % We still roll for a tougher if we killed the monster but
                  % didn't take damage or dodge, if we helped kill the monster,
                  % or if it was a group member kill and the setting for group
                  % member toughers is set to TRUE.
                  if NOT group_member_kill
                     OR Send(SETTINGS_OBJECT,@GetGroupTougherSetting)
                  {
                     roll = TRUE;
                  }
               
                  % Inform the player that a group kill successfully garnered XP.
                  if group_member_kill
                     AND group_member <> $
                     AND gain = 1
                  {
                     Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                           #parm1=Send(group_member,@GetName),
                           #parm2=Send(what,@GetName));
                  }
               
                  % Give an informative message about non-group
                  % kills that are still shared
                  if NOT killing_blow
                     AND NOT group_member_kill
                     AND group_member <> $
                  {
                     Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                           #parm1=Send(group_member,@GetName),
                           #parm2=Send(what,@GetName));
                  }
               }
               else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
               {
                  % Player either did not take damage, but did killing blow,
                  %  or did take damage, did not land killing blow, or
                  %  it's a group member kill.
                  %
                  % Half XP.
                  gain = (monster_level + Send(what,@GetBonusXPGain))/2;
               
                  % Inform the player that a group kill successfully garnered XP.
                  if group_member_kill
                     AND group_member <> $
                  {
                     Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                           #parm1=Send(group_member,@GetName),
                           #parm2=Send(what,@GetName));
                  }
               
                  % Give an informative message about non-group
                  % kills that are still shared
                  if NOT killing_blow
                     AND NOT group_member_kill
                     AND group_member <> $
                  {
                     Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                           #parm1=Send(group_member,@GetName),
                           #parm2=Send(what,@GetName));
                  }
               }
            }
         }
         else
         {
            if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
            {
               % Monster was equal or close to player level.  Small bonus,
               %  no roll chance.
               if (monster_level + 5) > piBase_Max_health
                  AND IsClass(what,&monster) AND killing_blow 
                  AND ((piFlags & PFLAG_TOOK_DAMAGE)
                     OR (piFlags & PFLAG_DODGED))
               {
                  gain = 1;
               }
               else
               {
                  % Monster was too easy for player to kill!
                  if random(1,100) < 30 AND killing_blow
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_spits);
                  }
               }
            }
            else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
            {
               % Monster was equal or close to player level. Small bonus.
               if (monster_level + 5) > piBase_Max_health
                  AND IsClass(what,&monster) AND killing_blow 
                  AND ((piFlags & PFLAG_TOOK_DAMAGE)
                     OR (piFlags & PFLAG_DODGED))
               {
                  gain = (monster_level + Send(what,@GetBonusXPGain))/4;
               }
               else
               {
                  % Monster was too easy for player to kill!
                  if random(1,100) < 30 AND killing_blow
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_spits);
                  }
               }
            }
         }

         if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
         {
            % Give newbies a little bonus.
            if piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            {
               gain = gain + 1;
            }
            else
            {
               % Give solo pkill-enabled builders a little bonus, for
               % appropriate monsters. This will roughly equal building 
               % with one other player in the room. Bonus requires that the 
               % player is fighting normally (no firewalls / distance killing)
               lBuilderGroup = Send(poOwner,@GetBuilderGroup);
               if (lBuilderGroup = $
                     OR Length(lBuilderGroup) = 1
                     OR (FindListElem(lBuilderGroup,self) = 0
                        AND (piPreferences & ~CF_GROUPING)))
                  AND NOT group_member_kill
                  AND killing_blow
                  AND (monster_level + 5) > piBase_Max_health
                  AND ((piFlags & PFLAG_TOOK_DAMAGE)
                     OR (piFlags & PFLAG_DODGED))
               {
                  gain = gain + 1;
               }
            }
         }
         else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
         {
            % Give newbies a little bonus.
            if piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            {
               gain = gain * 150 / 100;
            }
            else
            {
               % Give solo pkill-enabled builders a little bonus, for
               % appropriate monsters. This will roughly equal building 
               % with one other player in the room. Bonus requires that the 
               % player is fighting normally (no firewalls / distance killing)
               lBuilderGroup = Send(poOwner,@GetBuilderGroup);
               if (lBuilderGroup = $
                     OR Length(lBuilderGroup) = 1
                     OR (FindListElem(lBuilderGroup,self) = 0
                        AND (piPreferences & ~CF_GROUPING)))
                  AND NOT group_member_kill
                  AND killing_blow
                  AND (monster_level + 5) > piBase_Max_health
                  AND ((piFlags & PFLAG_TOOK_DAMAGE)
                     OR (piFlags & PFLAG_DODGED))
               {
                  gain = gain * 150 / 100;
               }
            }
         }

         if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
         {
            % Give a bonus for Survival Rooms
            if Send(what,@GetBoostedLevel) > 0
            {
               gain = gain + (Send(what,@GetBoostedLevel)
                    / Send(Send(SYS,@GetSurvivalRoomMaintenance),
                            @GetSurvivalXP));
            }
         }
         else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
         {
            % Give a bonus for Survival Rooms
            if Send(what,@GetBoostedLevel) > 0
            {
               gain = gain + (Send(what,@GetBoostedLevel) * 10
                    / Send(Send(SYS,@GetSurvivalRoomMaintenance),
                            @GetSurvivalXP));
            }
         }

         % If they're cheesing the situation by fighting wussy monsters
         % in an altered form, penalize the gain amount.
         if piMax_health > piBase_Max_health * 2
            AND monster_level < piMax_health
         {
            gain = gain / 2;
            roll = FALSE;
         }

         gain = gain * Send(what,@GetChampionRewardMultiplier);
         gainmult = Bound(Send(SETTINGS_OBJECT,@GetHPGainMultiplier),1,500);
         gain = gain * gainmult;

         if iExperienceSystem = EXPERIENCE_SYSTEM_CLASSIC
         {
            piGain_chance = piGain_chance + gain;
         }
         else if iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
         {
            bGainedHP = Send(self,@AddExperience,#iAmount=gain);
         }

         % Also grant unbound energy for your own kills.
         % Unbound energy allows free spell casts.
         if IsClass(what,&Monster) AND killing_blow
         {
            % Let's figure the amount, mostly based on monster level.
            iUnbound = monster_level * Send(SETTINGS_OBJECT,@GetUnboundAbsorption)
               * (Random(30,80) + (Send(self,@GetMysticism) * 2 / 5)) / 10000;

            % Scale with distance to victim.
            iDist = Bound(Send(self,@SquaredFineDistanceTo3D,#what=what),1,$);
            % 36864 is 3 range in fine units, cf. SquaredFineDistanceTo3D.
            iUnbound = Bound(iUnbound * 36864 / iDist,$,iUnbound);

            % Scale with player level.
            iDifference = piMax_health - monster_level;
            if iDifference > 10
            {
               iUnbound = Bound(iUnbound * 100 / (iDifference * iDifference),$,iUnbound);
            }

            % Not awarding any unbound energy to players who have recently been involved
            % in PvP.
            if Send(self,@GetLastPlayerAttackTime)
               + Send(SETTINGS_OBJECT,@UnboundEnergyAttackDelaySec)
               > GetTime()
            {
               if iUnbound > 0
               {
                  Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_wasted);
               }
            }
            else
            {
            
               % Grant only one fourth of the energy if the mob didn't attack the player.
               if ((piFlags & PFLAG_TOOK_DAMAGE) OR (piFlags & PFLAG_DODGED))
               {
                  Send(self,@AddUnboundEnergy,#iAmount=iUnbound);
               }
               else
               {
                  Send(self,@AddUnboundEnergy,#iAmount=iUnbound / 4);
               }
            }
         }

         % Here, we work out if the player deserves a training point.
         % They qualify if they got at least one gain point from the monster.
         % Triple training points if at Max HP.
         if gain > 0
         {
            iEarnedTrainingPoints = 1
                                    + monster_level/50
                                    + (Send(what,@GetBoostedLevel) / Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalTP))
                                    + Send(what,@GetBonusBaseTP,#who=self);

            if bAtMaxHp
            {
               iEarnedTrainingPoints = iEarnedTrainingPoints * 3;
            }

            iEarnedTrainingPoints = iEarnedTrainingPoints * Send(what,@GetChampionRewardMultiplier);

            % Now adjust by percent damage dealt by us to this monster.
            % New group TP feature: min bound Damage Share value to a third, such that nobody gets nothing.
            % This will also give bonus TP at a distance to group members.
            iEarnedTrainingPoints = Bound((iEarnedTrainingPoints * Bound(iDamageShare,34,$) / 100),1,$);

            Send(self,@AddTrainingPoints,#points=iEarnedTrainingPoints,#report=FALSE);
         }

         % Let the player know how many training points they have, if they
         % either reached the max, or a multiple of 100.
         if piTraining_points > TRAINING_POINT_CAP
         {
            if piInform
            {
               %Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
               %   #parm1=piTraining_points);
               piInform = FALSE;
            }
         }
         else
         {
            if piTraining_points MOD 100 = 0
               AND piTraining_points <> 0
               AND piInform
            {
               Send(self,@MsgSendUser,#message_rsc=player_training_inform,
                     #parm1=piTraining_points);
            }
         }

         % Draw the training points bar.
         Post(self,@DrawTraining);

         % RollForTougher handles the actual tougher check. Will return
         % TRUE if player gains a HP, FALSE if they don't.
         if roll
         {
            bGainedHP = Send(self,@RollForTougher,#iLevel=monster_level);
         }
      }

      % Draw the tougher chance bar. Send this here because RollForTougher
      % will also draw it, no need to do so twice.
      % The modern experience system also draws at AddExperience.
      if NOT roll
         AND NOT iExperienceSystem = EXPERIENCE_SYSTEM_MODERN
      {
         Post(self,@DrawHPChance);
      }

      if (piFlags & PFLAG_DODGED)
         AND NOT group_member_kill
      {
         oWeapon = Send(self,@LookupPlayerWeapon);
         if oWeapon <> $
            AND (not IsClass(oWeapon,&RangedWeapon))
            AND Send(self,@HasSkill,#num=SKID_PARRY)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_PARRY) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_PARRY);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }
         if Send(self,@HasSkill,#num=SKID_FLOWING_CLOTH)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_FLOWING_CLOTH) < 99
            AND Send(self,@IsUsingA,#class=&RobeBase)
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_FLOWING_CLOTH);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }
         if Send(self,@GetWeapon) = $
            AND Send(self,@HasSkill,#num=SKID_WAY_OF_THE_BIRD)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_WAY_OF_THE_BIRD) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_WAY_OF_THE_BIRD);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if (Send(self,@LookupPlayerShield) <> $)
            AND Send(self,@HasSkill,#num=SKID_BLOCK)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_BLOCK) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_BLOCK);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if Send(self,@HasSkill,#num=SKID_DODGE)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_DODGE) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_DODGE);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }
      }

      % If RollForTougher returned TRUE, we gained a hitpoint.
      return bGainedHP;
   }

   RollForTougher(iLevel=0)
   "Handles the roll for tougher based on the player's gain chance plus "
   "the iLevel parameter.  Returns TRUE if the player gaints a hit point, "
   "FALSE otherwise.  The iLevel parameter has the player's base max HP "
   "taken from it, then divided by 5 before being bound between 1 and 10."
   {
      local iRandom, iNumber, oShrunken;

      if iLevel = $
      {
         iLevel = 0;
      }

      iRandom = Random(1,Send(self,@GetHighMark));
      iNumber = piGain_chance + Bound((iLevel-piBase_Max_health)/5,0,10);

      % Draw tougher chance bar.
      Post(self,@DrawHPChance);

      if iRandom < iNumber
         AND piBase_Max_health < (101 + Send(self,@GetStamina))
      {
         Send(self,@GainBaseMaxHealth,#amount=1);
         if Send(self,@CheckLog)
         {
            Debug("LOG:  ",vrName," gained a health point: ",
                  piMax_health,pibase_max_health);
         }

         Send(self,@EvaluatePKStatus);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_improve_maxhealth);
            Send(self,@WaveSendUser,#what=self,#wave_rsc=player_tougher_wav_rsc);

            % Boost the player to max health, and give them 200 vigor.
            Send(self,@MsgSendUser,#message_rsc=player_improve_health_invigorate);
            piHealth = Send(self,@GetMaxHealth) * 100;
            Send(self,@DrawHealth);
            Send(self,@EatSomething,#nutrition=200);
            Post(self,@DrawOffense);
            Post(self,@DrawDefense);

            % Report to shrunken head, if they have one.
            oShrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
            if oShrunken <> $
            {
               Send(oShrunken,@Tougher,#hp=pibase_max_health);
            }
         }

         piGain_chance = -(piBase_Max_health / 2);

         if piBase_max_health > 30
         {
            %stam = 50
            %pigain = pigain - ((50-50)/2) =  pigain - 0
            %stam = 25 
            %pigain = pigain - ((50-25)/2) = pigain - 12.5
            % So, after 30 hps, any stamina less than 50
            % penalizes you by about 0.5 piGain points
            piGain_chance = piGain_chance - ((50-Send(self,@GetStamina))/2);
         }

         return TRUE;
      }

      return FALSE;
   }

   GetGainChance()
   {
      return piGain_chance;
   }

   SetExperience(iAmount=0)
   {
      piExperience = iAmount;
      Post(self,@DrawHPChance);
      return;
   }

   AddExperience(iAmount=$)
   {
      local oShrunken, iBonusPercentage, iBonusAmount, i;

      if iAmount <> $
         AND iAmount <> 0
      {
         % Can't gain XP if at max health
         if piBase_Max_health >= 100+Send(self,@GetStamina)
         {
            return FALSE;
         }
      
         iBonusPercentage = 0;
         % Check for relics
         if Send(self,@GetLadderID) = 0
            AND poGuild <> $
            AND Send(poGuild,@GetGuildHall) <> $
         {
            foreach i in Send(Send(poGuild,@GetGuildHall),@GetRelicList)
            {
               iBonusPercentage = iBonusPercentage + Send(i,@GetExperienceBonus);
            }
         }
         
         % Does this player get any bonus experience from guild hall reliquaries?
         iBonusAmount = Bound((iAmount * (100+iBonusPercentage))/100 - iAmount,0,$);
         
         piExperience = piExperience + iAmount + iBonusAmount;

         if pbLogged_on
         {
            if iAmount > 0
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_gained,
                  #parm1=iAmount);
                  
               if iBonusAmount > 0
               {
                  Send(self,@MsgSendUser,#message_rsc=player_experience_bonus,
                     #parm1=iBonusAmount);
               }
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_lost,
                  #parm1=iAmount);
            }

            Post(self,@DrawHPChance);
         }
         
         if piExperience >= Send(self,@GetExperienceNeeded)
         {
            % In case of overages, give them all deserved HP boosts.
            % But don't do all the other stuff multiple times.
            while piExperience >= Send(self,@GetExperienceNeeded)
            {
               piExperience = piExperience - Send(self,@GetExperienceNeeded);
               Send(self,@GainBaseMaxHealth,#amount=1);
               
               % Just reached max health!
               if Send(self,@GetExperienceNeeded) = 0
               {
                  piExperience = 0;
                  break;
               }                  
            }
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," gained a health point: ",
                     piMax_health,pibase_max_health);
            }

            Send(self,@EvaluatePKStatus);

            if pbLogged_on
            {
               Send(self,@MsgSendUser,#message_rsc=player_improve_maxhealth);
               Send(self,@WaveSendUser,#what=self,
                     #wave_rsc=player_tougher_wav_rsc);

               % Boost the player to max health, and give them 200 vigor.
               % Send(self,@MsgSendUser,
               %      #message_rsc=player_improve_health_invigorate);
               piHealth = Send(self,@GetMaxHealth) * 100;
               Send(self,@DrawHealth);
               Send(self,@EatSomething,#nutrition=200);
               Post(self,@DrawOffense);
               Post(self,@DrawDefense);

               % Report to shrunken head, if they have one.
               oShrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
               if oShrunken <> $
               {
                  Send(oShrunken,@Tougher,#hp=pibase_max_health);
               }
            }
            return TRUE;
         }
      }

      return FALSE;
   }
   
   GetExperience()
   {
      return piExperience;
   }

   GetExperienceNeeded()
   {
      local iExperienceNeeded, iStamina, iExtraStamina;
      
      if piBase_Max_health >= 100+Send(self,@GetStamina)
      {
         return 0;
      }

%     Classic system says:
%     "A player will need, on average, to kill a number of monsters equal to"
%     "their maxhealth to gain a HP.  This number is reduced by the player's"
%     "stamina, all the way down to half for those with high staminas."
      
      % +1 because it's for the next hit point.
      % Your base max health squared because you will have to kill,
      % for example, 150 150-hp monsters to get your 150th hit point.
      % Monsters give experience equal to their level.
      iExperienceNeeded = (piBase_Max_health+1) * (piBase_Max_health+1);

      % Asymptotic equations. Stamina at 100 was instant max, so rework.
      % Higher reincarnations get some slowdown as well.
      iStamina = Send(self,@GetStamina);
      iExtraStamina = 0;
      if iStamina > 50
      {
         iExtraStamina = iStamina - 50;
         iStamina = 50;
      }
      iExperienceNeeded = (iExperienceNeeded * (100-(iStamina+(iExtraStamina/2))))/100;

%      iExperienceNeeded = iExperienceNeeded * Bound(piReincarnations/4,1,20);

      iExperienceNeeded = bound(iExperienceNeeded,1,$);
      
      return iExperienceNeeded;
   }

   ConvertGainChanceToXP(iAmount=0)
   {
      local iExperience;
      
      % Two gain chance points is equivalent to one full kill of an equal
      % level monster.
      
      iExperience = Send(self,@GetBaseMaxHealth);
      iExperience = iExperience * iAmount / 2;
      
      return iExperience;
   }

   AddGainChance(iAmount=$)
   {
      if iAmount <> $
         AND iAmount <> 0
      {
         if Send(SETTINGS_OBJECT,@GetExperienceSystem) = EXPERIENCE_SYSTEM_MODERN
         {
            iAmount = Send(self,@ConvertGainChanceToXP,#iAmount=iAmount);
            Send(self,@AddExperience,#iAmount=iAmount);
            return;
         }

         piGain_chance = piGain_chance + iAmount;

         if pbLogged_on
         {
            if iAmount > 0
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_gained,
                  #parm1=iAmount);
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_lost,
                  #parm1=iAmount);
            }

            Post(self,@DrawHPChance);
         }
      }

      return;
   }

   RewardMoney(amount=0, report=TRUE)
   "This function is used by quests to avoid code duplication."
   {
      local oMoney, iPlayerAmt;
 
      oMoney = Send(self,@GetMoneyObject);
      if oMoney = $
      {
         oMoney = Create(&Money,#number=amount,#ladderID=Send(self,@GetLadderID));
         Send(self,@NewHold,#what=oMoney);
      }
      else if (Send(oMoney,@GetNumber) + amount) <= 0
      {
         iPlayerAmt = Send(oMoney,@GetNumber);
         if iPlayerAmt = MAX_KOD_INT
         {
            return;
         }
         else if (iPlayerAmt + amount) <= 0
         {
            amount = MAX_KOD_INT - iPlayerAmt;
            Send(oMoney,@AddNumber,#number=amount);
         }
      }
      else
      {
         Send(oMoney,@AddNumber,#number=amount);
      }
      
      if report
      {
         Send(self,@MsgSendUser,#message_rsc=rewarded_money_msg,#parm1=amount);
      }
      return;
   }

   AddUnboundEnergy(iAmount=0,report=TRUE)
   {
      % Add to total. Check reasonable limits first. You can't lose
      % more points than you have and you can't get more points than
      % you need to reach the cap.
      iAmount = Bound(iAmount,-piUnbound_energy,Send(SETTINGS_OBJECT,@GetUnboundMax) - piUnbound_energy);
      piUnbound_energy = iAmount + piUnbound_energy;

      if (pbLogged_on AND report)
      {
         if iAmount > 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_gained,
                  #parm1=iAmount);
         }
         else if iAmount < 0
         {
            Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_lost,
                  #parm1=-iAmount);
         }
      }

      % Only delay decay if we gain points.
      if iAmount > 0
      {
         Send(self,@NewUnboundEnergy,#bDelay=TRUE);
      }
      else
      {
         Send(self,@NewUnboundEnergy,#bDelay=FALSE);
      }

      return;
   }

   WipeUnboundEnergy(report=TRUE)
   {
      if (pbLogged_on AND report AND piUnbound_energy > 0)
      {
         Send(self,@MsgSendUser,#message_rsc=player_unbound_energy_wiped);
      }

      % Remove all unbound energy, for example after a teleport.
      send(self,@AddUnboundEnergy,#iAmount=-piUnbound_energy,#report=FALSE);

      return;
   }

   GetUnboundEnergy()
   {
      return piUnbound_energy;
   }

   % Returns true if the last spell cast was a free cast.
   GetFreeCast()
   {
      return pbFree_cast;
   }

   GetTrainingPoints()
   {
      return piTraining_points;
   }

   AddTrainingPoints(points=0,report=TRUE,bCap=TRUE,bEarned=TRUE)
   {
      if points = 0
      {
         return;
      }

      if bEarned
         AND points > 0
      {
         % Only add real generated training points to accumulated wisdom
         Send(self,@AddAccumulatedWisdom,#amount=points);
      }

      if bCap
      {
         if piTraining_points <= TRAINING_POINT_CAP
         {
            points = bound(points,-piTraining_points,TRAINING_POINT_CAP - piTraining_points);
         }
         else if points > 0
         {
               % We're respecting the point cap, have more than
               % points and are trying to add more. Don't add the points,
               % return out.
               return;
         }
      }

      if points > 100
      {
         % Players need to be informed of large point gains
         report = TRUE;
      }

      if report AND points > 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_gained_training,
               #parm1=points);
      }

      if report AND points < 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_spent_training,
               #parm1=-points);
      }

      piTraining_points = piTraining_points + points;

      if piTraining_points < TRAINING_POINT_CAP
         OR NOT bCap
      {
         piInform = TRUE;
      }
      else
      {
         %Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
         %      #parm1=piTraining_points);
         piInform = FALSE;
      }
      
      if piTraining_points < 0
      {
         piTraining_points = 0;
      }

      Post(self,@DrawTraining);

      return;
   }

   GetDailyTrainingReward()
   {
      local iBonus;

      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);

      if piTraining_points >= TRAINING_POINT_CAP
      {
         return;
      }

      % Retrieve the daily logon bonus from settings.
      iBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);

      Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
      Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

      piReward_timestamp = GetTime();

      return;
      
   }

   GetHighMark()
   {
      local index, highmark;

      index = (piBase_Max_health*(100-Send(self,@GetStamina)))/100;
      highmark = (index+1)*index;

      return highmark;
   }

   %%% Player Killed %

   Killed(what = $, stroke_obj = $,bDoingBackstab = FALSE)
   {
      local lItems,i, j, amount, oBody, oSoldierShield, bNo_drop_death, oItemAtt,
            oRoom, iRow, iCol, iFine_Row, iFine_Col, iAngle, oItem,
            iRoom, lInventoryContents, lReagentBagContents;

      Send(self,@ClearAllStatusEffects);
      
      Send(self,@ClearBombs);
      
      Send(self,@SetMarauderAntagonist,#value=FALSE);

      % If this player has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         foreach i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      % If we have Apparitions attacking us, delete them.
      if plApparitionList <> $
      {
         foreach j in plApparitionList
         {
            Send(j,@Delete);
         }
         plApparitionList = $;
      }

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
      {
         return;
      }

      if poOwner <> $
         AND IsClass(poOwner,&Room)
         AND Send(poOwner,@OverridesDeathFunction)
      {
         Send(poOwner,@OverrideDeathFunction,#who=self,#what=what,#stroke_obj=stroke_obj);

         return;
      }

      % Skill, spell and hp penalties are handled by ApplyDeathPenalties, which
      % is called from LeaveHold() in the Underworld.  This is to allow time
      % for Portal of Life to reduce penalties.  We get the default value of
      % piDeathCost from SYS, so that we can adjust global death penalties.
      % "Normal" value is 100.
      piDeathCost = Send(SETTINGS_OBJECT,@GetDefaultDeathCost);

      % A player (probably) cannot die twice in two seconds in any valid way.
      if GetTime() < (piLastDeathTime + 2)
      {
         Debug("Averted double-death of",vrName);

         return;
      }

      % Stop any rescue attempts that were going on.
      Send(self,@CancelRescue);
      
      piLastDeathTime = getTime();

      % Grab the location of the deceased.
      % Might need to grab the old location if logged off.

      if pbLogged_on
      {
         oRoom = poOwner;
         iRow = piRow;
         iCol = piCol;
         iFine_Row = piFine_Row;
         iFine_Col = piFine_Col;
         iAngle = Send(self,@GetAngle);
         iRoom = Send(poOwner,@GetRoomNum);
      }
      else
      {
         if NOT Send(self,@IsUsingA,#class=&NecromancerAmulet)
         {
            Debug("Player died while offline, but not a necromancer: ",
                  Send(self,@GetName));
         }

         iRoom = Send(self,@GetSaveRoom);
         oRoom = Send(SYS,@FindRoomByNum,#num=iRoom);
         iRow = Send(self,@GetSaveRow);
         iCol = Send(self,@GetSaveCol);
         iFine_Row = Send(self,@GetSaveFineRow);
         iFine_Col = Send(self,@GetSaveFineCol);
         iAngle = Send(self,@GetSaveAngle);
      }

      % Any other quick escapes from certain death?
      % Such as the Arena "loser", or while in the Out of Grace prison.
      % These aren't cheap deaths, these are ways to avoid actual death.
      if pbLogged_on
         AND ((Send(poOwner,@IsArena)
               AND Send(poOwner,@InPlay,#what=Self)
               AND NOT Send(poOwner,@ArenaRealDeath))
              OR IsClass(poOwner,&OutOfGrace)
              OR Send(poOwner,@SafePlayerAttack))
      {
         piHealth = 1;
         Send(self,@NewHealth);

         % Currently, the following block is only for
         % Necromancer Amulets and Hunter Swords.
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }

         return;
      }

      % Okay, we're really dying now.
      % Now we need to determine if it's a 'cheap'
      % death where we don't lose stuff.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      bNo_drop_death = FALSE;

      % Reign of Blood Frenzy death?  Newbie death?
      % Don't drop anything or take any penalties.
      if Send(SYS,@GetChaosNight)
        OR (iRoom >= RID_NEWB_BASE AND iRoom <= RID_NEWB_MAX)
        OR NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
      }

      % Currently, the following block is only for Necromancer Amulets
      % and Hunter Swords. This is placed before the token death check,
      % so that token deaths _will_ make you lose your artifact.
      if bNo_drop_death
      {
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }
      }

      % Record-keeping. Keep this before the token check,
      % so we can give proper message.
      Send(SYS,@UserKilled,#what=self,#killer=what,#oRoom=oRoom,#stroke_obj=stroke_obj,#bDoingBackstab=bDoingBackstab);
      Send(Send(SYS,@GetStatistics),@PlayerDiedCounter);

      % Token death?
      i = GetListElemByClass(plUsing,&Token);
      if i <> $
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
         Send(self,@MsgSendUser,#message_rsc=player_token_death);
         Send(i,@NewUnused,#what=self,#where=oRoom);
      }

      % Create the corpse.
      if what <> $
         AND IsClass(what,&User)
      {
         oBody = Send(self,@CreateCorpse,#oPlayerKiller=what);
      }
      else
      {
         oBody = Send(self,@CreateCorpse);
      }
      plCorpses = Cons(oBody,plCorpses);

      Send(oRoom,@NewHold,#what=oBody,#new_row=iRow,#new_col=iCol,
            #fine_row=iFine_Row,#fine_col=iFine_Col,#new_angle=iAngle);

      % Start losing stuff if applicable.
      if NOT bNo_drop_death
      {
         if ptHealth <> $
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }

         % Lose the inventory.  It falls onto the corpse.
         if (what = $) OR (NOT IsClass(what,&user))
         {
            oItemAtt = $;
         }
         else
         {
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_PKPOINTER);

            if what <> $
            {
               % We've been killed by a player, so set the PKed flag for
               % the temp safety angel to trigger later, provided we meet
               % all the requirements. Check for not $ here - fastest way
               % to implement this without performing another IsClass check.
               piFlags = piFlags | PFLAG_KILLED_BY_PLAYER;
            }
         }

         lReagentBagContents = Send(self,@GetReagentBagContents);
         if lReagentBagContents <> $
         {
            lInventoryContents = [plActive,plPassive,lReagentBagContents];
         }
         else
         {
            lInventoryContents = [plActive,plPassive];
         }

         foreach lItems in lInventoryContents
         {
            foreach i in lItems
            {
               % Let the item know we died, in case it does something special.
               Send(i,@OwnerKilled);

               if Send(i,@DropOnDeath)
               {
                  if Send(oRoom,@ReqNewHold,#what=i,#new_row=iRow,#new_col=iCol)
                  {
                     if oItemAtt <> $
                     {
                        % We know this was a pk.  Only let PKillables pick up the loot.
                        % Put the appropriate item attribute on it.
                        Send(oItemAtt,@AddToItem,#oItem=i,
                              #timer_duration=PKPOINTER_TIME,
                              #state1=self);
                     }

                     Send(oBody,@NewHold,#what=i);
                  }
               }
            }
         }

         % Atrophy of skills or learning progress.
         piGain_chance = piGain_chance/2;
         Send(self,@ResetGainFlags);
         Send(self,@ResetAtrophyFlags);
         if ptAdvancement <> $
         {
            DeleteTimer(ptAdvancement);
            ptAdvancement = $;
         }

         Post(self,@EvaluatePKStatus);

         % Let SoldierShields know we died. It handles itself as appropriate.
         oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
         if oSoldierShield <> $
         {
            Send(oSoldierShield,@OwnerDied,#what=what);
         }

         % Positive karma makes us eligible for a booby prize.
         if piKarma > 5000 AND (Send(self,@GetHomeRoom) <> RID_NEWB1)
         {
            % To prevent mule money abuse, make the hammer "created".
            % This makes it worthless to try to sell. It lasts for 5 hours.
            oItem = Create(&Hammer,#ladderID=Send(self,@GetLadderID));
            oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
            Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
            Send(self,@NewHold,#what=oItem);
         }
         else
         {
            if piKarma >= 0
            {
               % To prevent mule money abuse, make the mace "created".
               % This makes it worthless to try to sell. It lasts for 5 hours.
               oItem = Create(&Mace,#ladderID=Send(self,@GetLadderID));
               oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
               Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
               Send(self,@NewHold,#what=oItem);
            }
         }
      }

      % Give out your dying scream.
      if piGender = GENDER_FEMALE
      {
         i = playerf_death_wav;
      }
      else
      {
         i = playerm_death_wav;
      }

      Send(oRoom,@SomethingWaveRoom,#what=oBody,#wave_rsc=i);
      if pbLogged_on
      {
         Send(self,@WaveSendUser,#what=self,#wave_rsc=i);
      }

      % Teleport to the Underworld.
      Send(self,@UserGotoDeadRoom);
      
      % Change health, mana, vigor.
      if Send(SYS,@GetChaosNight)
      {
         % It's a frenzy!  Give us a leg up.
         piHealth = 80*Send(self,@GetMaxHealth);
         piMana = 4*(piMax_Mana/5);
         piVigor = 200;
      }
      else
      {
         % We're not in a frenzy.  Give us the bare minimums.
         piMana = 1;
         piHealth = 1;
         piVigor = Bound(piVigor/4,15,50);
      }

      Send(self,@NewHealth);
      Send(self,@NewMana);
      Send(self,@NewVigor);

      % Refresh the client with what's really going on.
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);

         % Wake up with red foggy hangover.
         Send(self,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=5000);
      }

      if piDeathCost > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
         AND NOT (piFlags & PFLAG_MURDERER)
      {
         % Give an encouraging gmail and some mana to broadcast.
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_death_mail]);
         Send(self,@MsgSendUser,#message_rsc=player_death_mail_notice);

         % Give them half their mana to broadcast for help with.
         piMana = (piMax_mana / 2) + 2;
         Send(self,@NewMana);
      }

      if poOwner = oRoom
      {
         Debug("Player didn't teleport after death!",vrName);
      }

      propagate;
   }

   ApplyDeathPenalties()
   {
      local iAmount, bLostHealth, i, bTempSafe;

      bTempSafe = FALSE;

      if (piFlags & PFLAG_KILLED_BY_PLAYER)
      {
         bTempSafe = TRUE;
         piFlags = piFlags & ~PFLAG_KILLED_BY_PLAYER;
      }

      if (piflags & PFLAG_DEATH_RIFTING)
      {
         % Leaving the Underworld while protected, no penalties. Protection
         % is removed in NewOwner to allow them to log off without penalties.
         return;
      }

      if Send(SYS,@GetChaosNight)
      {
         % Remove any revenants.
         Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);

         % Return out.  Don't apply death penalties during frenzies.
         return;
      }

      bLostHealth = FALSE;

      % Lose your revenant, satisfied if you took a real death.
      if piDeathCost >= Send(SETTINGS_OBJECT,@GetDefaultDeathCost)
      {
         % As an outlaw, justice was met by dying. But, not if it's a cheap death!
         Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
         Post(self,@EvaluatePKStatus);

         if (piFlags & PFLAG_HAUNTED)
         {
            if pbLogged_on
            {
               Send(self,@MsgSendUser,#message_rsc=player_haunted_off);
            }

            Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
         }
      }

      % Only do this stuff if the cost of death is not zero.
      if piDeathCost > 0
      {
         if NOT (piFlags & PFLAG_TUTORIAL)
            AND NOT (piFlags & PFLAG_MURDERER)
         {
            piDeathCost = piDeathCost / 3;
         }
         else
         {
            % If you're not new, chance to lose a hp!
            if Random(1,100) <= piDeathCost
            {
               Send(self,@GainBaseMaxHealth,#amount=-1);
               bLostHealth = TRUE;
            }

            % Under 100HP and killed by a player? Receive a temporary angel.
            if bLostHealth
               AND bTempSafe
               AND piBase_max_health <= 99
               AND NOT ((piFlags & PFLAG_MURDERER)
                  OR (piFlags & PFLAG_OUTLAW))
               AND (piPreferences & CF_TEMPSAFE)
               AND Send(self,@FindUsing,#class=&SoldierShield) = $
               AND ptTempSafe = $
               AND NOT pbOptOutPvP
            {
               Post(self,@StartTempSafe);
            }
         }
      }
      else
      {
         return;
      }

      if Send(self,@CheckLog)
      {
         if bLostHealth
         {
            Debug("LOG:  ",vrName," died, lost a health point: ",
                  piMax_health,pibase_max_health,"Death Cost = ",piDeathCost);
         }
         else
         {
            Debug("LOG:  ",vrName," died, but made death cost check: ",
                  piDeathCost);
         }
      }

      % Remove from guild if now under min HP
      if piBase_max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
         AND Send(SETTINGS_OBJECT,@BootLowbiesFromGuildsUponDeath)
      {
         Send(self, @QuitGuild);
      }

      % Lose some skill or spell proficiency.

      % Murderers get hit harder.
      if (piFlags & PFLAG_MURDERER)
      {
         iAmount = -2;
      }
      else
      {
         iAmount = -1;
      }

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSpellAbility,#spell_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSkillAbility,#skill_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);
      }

      Debug("Player ",Send(self,@GetTrueName),self," took death penalties of ",
            piDeathCost," percent.");

      piDeathCost = 0;

      return;
   }

   SetDeathCost(DeathCost = $, bOverride = FALSE)
   {
      % Don't raise the cost of death, unless we want to override it.
      if DeathCost < piDeathCost
         OR bOverride
      {
         piDeathCost = DeathCost;
      }

      return;
   }

   GetDeathCost()
   {
      return piDeathCost;
   }

   CreateCorpse(Assassinated=FALSE, oPlayerKiller=$)
   {
      local inKocatan;
      
      Post(self,@MsgSendUser,#message_rsc=new_corpse_information);

      % Send current pant/shirt color to body only if they both use
      % the new two-color xlats. Otherwise, Send default colors.
      inKocatan = FALSE;
      if pbLogged_on
      {
         if Send(poOwner,@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }
      else
      {
         if Send(Send(SYS,@FindRoomByNum,
               #num=Send(self,@GetSaveRoom)),@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }

      if Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetBodyTranslation))
         AND Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetLegsTranslation))
      {
         if piGender = GENDER_MALE
         {
            % male, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan);
         }
         else
         {
            % female, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan);
         }
      }

      if piGender = GENDER_MALE
      {
         % male, default colors
         return Create(&DeadBody,
                       #victim=self,
                       #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                       #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                       #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                       #inKocatan = inKocatan);
      }
      % female, default colors
      return Create(&DeadBody,
                    #victim=self,
                    #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                    #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                    #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                    #inKocatan = inKocatan);
   }

   GetDeadName()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_name_rsc;
      }
      
      return player_dead_female_name_rsc;

   }
   
   GetDeadIcon()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_icona_rsc;
      }
 
      return player_dead_female_icona_rsc;
   }
   
   FreeHands()
   "Attempts to remove all items from hands if possible."
   {
      local i;

      foreach i in plUsing
      {
         if (Send(i,@GetItemUseType) & ITEM_USE_HAND)
            AND Send(i,@ReqUnuse)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   DoDance()
   {
      local i, iSpace;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_dance);

            return FALSE;
         }
      }

      if ptRest <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_dance_resting);

         return FALSE;
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_dance);

      piAnimation = PANM_DANCE;
      Send(poOwner,@SomethingChanged,#what=self);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=TRUE,#flagset=2);
      piAnimation = PANM_NONE;

      return;
   }

   StopDancing()
   {
      Send(self,@MsgSendUser,#message_rsc=player_stop_dance);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=FALSE,#flagset=2);
      Send(poOwner,@SomethingChanged,#what=self);
      
      return;
   }

   DoWave()
   "Causes the user do the wave animation, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_wave);

      piAnimation = PANM_WAVE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoFistAttack()
   "Causes the user do the fight animation w/fist, 1st and 3rd person"
   {
      Send(self,@DoWindowOverlayFistAttack);

      piAnimation = PANM_FIST_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoPoint()
   "Causes the user to point, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_point);

      piAnimation = PANM_POINT;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoCast()
   "Causes the user to do spell casting arm, 1st & 3rd person"
   {
      Send(self,@DoWindowOverlayHandGlow);

      piAnimation = PANM_CAST;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoBowFire()
   {
      piAnimation = PANM_BOW_FIRE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoWindowOverlayFistAttack()
   {
      if pbLogged_on
         AND Send(self,@GetSession) <> $
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         AddPacket(1,ANIMATE_ONCE, 4,175, 2,1, 2,3, 2,0);
         AddPacket(1,0);

         SendPacket(poSession);
      }

      return;
   }

   DoWindowOverlayHandGlow()
   {
      local i,iGroup;

      if pbLogged_on
         AND Send(self,@GetSession) <> $
      {
         iGroup = 0;
         foreach i in plWindow_overlays
         {
            if Send(i,@GetWindowOverlayID) = PWO_RIGHT_HAND
            {
               % Of right hand overlay already exists, we can't
               % restore it correctly yet, so just don't change it
               return;
            }
         }

         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         AddPacket(1,ANIMATE_ONCE,4,300,2,4,2,6,2,iGroup);
         AddPacket(1,1);
         AddPacket(4,player_window_overlay_glow, 1,HS_RIGHT_HAND,
                   1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,0);

         SendPacket(poSession);
      }

      return;
   }

   SetWindowOverlay(what = $)
   "Sends a message to the client about a window overlay, and adds <what> "
   "to plWindow_overlays."
   {
      Send(self,@AddWindowOverlayObject,#what=what);
      Send(self,@ChangeWindowOverlay,#what=what);

      return;
   }

   ChangeWindowOverlay(what = $)
   "Things can call this when they have a current window overlay and want "
   "to change it, such as for an attack.  Note--it's NOT verified that it's "
   "in plWindow_overlays."
   {
      if pbLogged_on
         AND Send(self,@GetSession) <> $
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,Send(what,@GetWindowOverlayHotspot));
         AddPacket(4,Send(what,@GetWindowOverlayID)); % supposedly "object id" in client
         AddPacket(4,Send(what,@GetWindowOverlay));
         AddPacket(4,Send(what,@GetName)); % useless field, used to make client parsing easier
         % Flags, drawing flags, minimapflags, namecolor, playertype, moveon type.
         AddPacket(4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         Send(what,@SendWindowOverlayAnimation);
         Send(what,@SendWindowOverlayOverlays);

         SendPacket(poSession);
      }

      return;
   }

   AddWindowOverlayObject(what = $)
   "Adds <what> to plWindow_overlays, in case the user leaves and relogs on"
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            return;
         }
      }

      plWindow_overlays = Cons(what,plWindow_overlays);

      return;
   }

   RemoveWindowOverlay(what = $)
   "Removes <what> from plWindow_overlays if it's in there, "
   "after updating client."
   {
      Send(self,@ChangeWindowOverlay,#what=what);
      Send(self,@RemoveWindowOverlayObject,#what=what);

      return;
   }

   RemoveWindowOverlayObject(what = $)
   "Removes <what> from plWindow_overlays if it's in there."
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            plWindow_overlays = DelListElem(plWindow_overlays,what);
            return;
         }
      }

      return;
   }

   VerifyOverlays()
   "Removes overlays of any overlaid item whose owner is not the player."
   {
      local i;

      foreach i in plOverlays
      {
         if Send(i,@GetOwner) <> self
         {
            Send(self,@RemoveOverlay,#what=i);
         }
      }

      return;
   }

   SetOverlay(what = $)
   "Adds <what> to plOverlays, and tells everyone we changed."
   {
      Send(self,@AddOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveOverlay(what = $)
   "Removes <what> from plOverlays if it's in there, and "
   "tells everyone we changed."
   {
      Send(self,@RemoveOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddOverlayObject(what = $)
   "Adds <what> to plOverlays, so we can keep track of whom to "
   "call about overlays"
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            return;
         }
      }

      plOverlays = Cons(what,plOverlays);

      return;
   }

   RemoveOverlayObject(what = $)
   "Removes <what> from plOverlays if it's in there."
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            plOverlays = DelListElem(plOverlays,what);

            return;
         }
      }

      return;
   }

   RemoveHair(what = $)
   {
      if what = $
      {
         return;
      }

      poHair_remove = what;
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   ResetHair()
   {
      poHair_remove = $;

      if poOwner
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx | drawfx;
      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx & drawfx;

      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIcon(what = $,new_icon = $,translation = $, alldone = TRUE)
   "Sets our icon to <new_icon>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poIcon_set = what;
      vrIcon = new_icon;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
                  (translation * PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   GetPlayerIcon()
   {
      return vrIcon;
   }

   ResetPlayerIcon(alldone=TRUE)
   "Sets our icon to its natural, unarmored state."
   {
      local i;

      poIcon_set = $;

      % A player may be wearing something under his armor.
      foreach i in plUsing
      {
         % Shirt or armor.
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            Send(i,@SetIcon);

            return;
         }
      }

      if piGender = GENDER_MALE
      {
         vrIcon = player_male_icon_rsc;
      }
      else
      {
         vrIcon = player_female_icon_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultShirtTranslation)*PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerArms(what=$,new_left_arm=$,new_right_arm=$,translation=$,alldone=TRUE)
   "Sets our legs to <new_legs>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poArms_set = what;
      prleft_Arm = new_left_arm;
      prRight_Arm = new_right_arm;

      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (translation * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerArms(alldone = TRUE)
   "Sets our icon to its natural, default-shirted state."
   {
      local iShirt_xlat, i, bFound;
      poArms_set = $;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@OverrideArms)
         {
            % Gauntlets, probably.
            prRight_arm = Send(i,@GetOverrideRightArm,#who=self);
            prleft_arm = Send(i,@GetOverrideleftArm,#who=self);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         if piGender = GENDER_MALE
         {
            prRight_arm = player_Rightarm_a_rsc;
            prLeft_arm = player_leftarm_a_rsc;
         }
         else
         {
            prRight_arm = player_Rightarm_b_rsc;
            prLeft_arm = player_leftarm_b_rsc;
         }
      }

      iShirt_xlat = Send(self,@GetDefaultShirtTranslation);
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (iShirt_xlat * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerLegs(what = $,new_legs = $,translation = $)
   "Sets our legs to <new_legs>, and keeps track of <what> to "
   "undo when necessary. Tells everyone we changed."
   {
      poLegs_set = what;
      prLegs = new_legs;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
               (translation * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerLegs()
   "Sets our icon to its natural, un-panted state."
   {
      poLegs_set = $;

      if piGender = GENDER_MALE
      {
         prLegs = player_legs_a_rsc;
      }
      else
      {
         prLegs = player_legs_b_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultPantsTranslation) * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetDefaultClothes(pants_color=-1,shirt_color=-1,rand=FALSE,increment=TRUE)
   {
      local shirt_color_xlat, pants_color_xlat, skin_color, i,
            bShirt, bLegs, bArms;

      skin_color = Send(self,@GetSkinColor);
      skin_color = Send(self,@ConvertSkinColorToXLAT,#skin_color=skin_color);

      if rand
      {
         pants_color = random(XLAT_TO_SKIN1, XLAT_TO_SKIN4);
         shirt_color = random(XLAT_TO_ORANGE, XLAT_HIGH_VALUE);
         if shirt_color = XLAT_TO_SKIN4
         {
            shirt_color = XLAT_TO_RED;
         }

         shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=shirt_color,#color2=skin_color);
         pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=pants_color,#color2=skin_color);
      }

      else
      {
         if shirt_color = -1
         {
            shirt_color_xlat = Send(self,@GetDefaultShirtTranslation);
         }
         else
         {
            shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=shirt_color,#color2=skin_color);
         }

         if pants_color = -1
         {
            pants_color_xlat = Send(self,@GetDefaultPantsTranslation);
         }
         else
         {
            pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=pants_color,#color2=skin_color);
         }
      }

      piDefault_clothes = (shirt_color_xlat*SHIRT_MUL) | (pants_color_xlat*PANTS_MUL);

      bShirt = FALSE;
      bLegs = FALSE;
      bArms = FALSE;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
         {
            bArms = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            % ITEM_USE_BODY is armor
            bShirt = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_LEGS
         {
            bLegs = TRUE;
         }
      }

      if NOT bArms
      {
         Send(self,@ResetPlayerArms);
      }

      if NOT bShirt
      {
         Send(self,@ResetPlayerIcon);
      }

      if NOT bLegs
      {
         Send(self,@ResetPlayerLegs);
      }

      Send(self,@RefreshPlayerVisualGear);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RefreshPlayerVisualGear()
   {
      local n, lRefreshItemTypes, i, iHighestLayer, oHighestGear,
            iLowestLayer, oLowestGear, oSoldierShield, bSoldierShieldSlung,
            iFrozCount;

      lRefreshItemTypes = [ITEM_USE_SHIRT,ITEM_USE_BODY,ITEM_USE_LEGS];

      foreach n in lRefreshItemTypes
      {
         iHighestLayer = 0;
         oHighestGear = $;
         foreach i in plUsing
         {
            if IsClass(i,&DefenseModifier)
               AND Send(i,@GetItemUseType) & n
            {
               if Send(i,@GetLayer) >= iHighestLayer
               {
                  iHighestLayer = Send(i,@GetLayer);
                  oHighestGear = i;
               }
            }
         }

         if oHighestGear <> $
         {
            Send(oHighestGear,@DoPlayerArt);
         }
      }

      % Check for headgear, which has special overlays
      % In this case, we actually refresh the lowest layer to put it underneath
      iLowestLayer = 100000;
      oLowestGear = $;
      foreach i in plUsing
      {
         if IsClass(i,&DefenseModifier)
            AND Send(i,@GetItemUseType) & ITEM_USE_HEAD
         {
            if Send(i,@GetLayer) <= iLowestLayer
            {
               iLowestLayer = Send(i,@GetLayer);
               oLowestGear = i;
            }
         }

         if oLowestGear <> $
         {
            Send(oLowestGear,@UndoPlayerArt);
            Send(oLowestGear,@DoPlayerArt);
         }
      }

      % Check for Soldier Shield sling
      bSoldierShieldSlung = FALSE;
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         iFrozCount = 0;
         foreach i in plUsing
         {
            if IsClass(i,&JewelOfFroz)
            {
               iFrozCount++;
            }

            if (IsClass(i,&Shield)
               AND NOT IsClass(i,&SoldierShield))
               OR IsClass(i,&Bow)
               OR IsClass(i,&Lute)
               OR iFrozCount > 1
            {
               Send(oSoldierShield,@SlingOnBack,#report=FALSE);
               bSoldierShieldSlung = TRUE;

               % Now restore the first-person view of other shield
               % if we're using one
               foreach n in plUsing
               {
                  if (IsClass(n,&Shield)
                     AND NOT IsClass(n,&SoldierShield)
                     AND NOT IsClass(n,&Torch))
                  {
                     Send(self,@SetWindowOverlay,#what=n);
                  }
               }
            }
         }

         if bSoldierShieldSlung = FALSE
         {
            Send(oSoldierShield,@RemoveFromBack,#report=FALSE);
         }
      }

      return;
   }

   ConvertskincolortoXLAT(Skin_color = 0)
   {
      % Since the face translates use a single translate and the body uses
      % a double translate which has less color values available,
      % here we map the face translate to a similar body translate.
      if skin_color = PT_BLUE_TO_SKIN1
         OR skin_color = PT_BLUE_TO_SKIN2
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_SKIN3
      {
         return XLAT_TO_SKIN2;
      }

      if skin_color = PT_BLUE_TO_SKIN4
      {
         return XLAT_TO_SKIN4;
      }

      if skin_color = PT_BLUE_TO_GREEN
         OR skin_color = PT_BLUE_TO_YELLOW
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_GRAY
         OR skin_color = PT_BLUE_TO_ASHEN
      {
         return XLAT_TO_GRAY;
      }

      if skin_color = PT_BLEND25YELLOW
         OR skin_color = PT_BLUE_TO_LBLUE
      {
         return XLAT_TO_SKY;
      }

      if skin_color = PT_BLEND25RED
      {
         return XLAT_TO_BLUE;
      }

      if Send(SYS,@IsTwoColorXLAT,#Xlat=skin_color)
      {
         return Send(SYS,@DecodeSecondaryColor,#Xlat=skin_color);
      }

      return XLAT_TO_SKIN1;
   }

   SetSkinTranslation(translation = $)
   {
      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_Skin_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_SKIN_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHairTranslation(translation = $)
   {
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_HAIR_MASK;
      piBody_translations2 = piBody_translations2 | (translation * PLAYER_TRANSLATION2_HAIR_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIllusion(what = $)
   "Stores <what> as the object to call back to get our animation and overlays."
   "Tells everyone we changed."
   {
      poIllusion_set = what;

      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetIllusionForm(what = $)
   "Returns what is setting our illusion, if anything is."
   {
      if poIllusion_set = $
      {
         return $;
      }

      return Send(poIllusion_set,@IllusionGetTemplate,#who=self);
   }

   ResetPlayerIllusion()
   "Restores default lighting and DrawFX."
   {
      poIllusion_set = $;

      % Recalculate the flicker flag.
      Send(self,@RecalcFlickerFlag);

      % Reset our drawFX. Also does the SomethingChanged bit if appropriate.
      Send(self,@ResetPlayerDrawFX);

      return;
   }

   DoAttackSwing()
   {
      piAnimation = PANM_WEAPON_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   GetIcon(trueicon=FALSE)
   {
      % trueicon is set to true anytime you want to know what
      % a person really looks like.  Good example: statues.

      if poIllusion_set <> $ AND NOT trueicon
      {
         return Send(poIllusion_set,@IllusionGetIcon,#who=self);
      }

      propagate;
   }

   SendAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendAnimation,#who=self,
               #animation=iAnimation);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,2, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,3, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,5, 2,5, 2,1);

         return;
      }

      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE,4, 150, 2,6, 2,22);

         return;
      }

      propagate;
   }

   SendMoveAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveAnimation,#who=self);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_DANCE
      {    
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,6, 2,22);

         return;
      }

      % use standing torso
      AddPacket(1, ANIMATE_NONE, 2,1);

      return;
   }

   SendMoveOverlays(iAnimation = $)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveOverlays,#who=self);

         return;
      }

      % Player has 7 standard overlays:
      % right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      % Which group of arm images do we use?
      iLeft_group = 1;
      iRight_group = 1;

      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            % Bend the arm if we have a shield, a bow, or a token.
            if hotspot = HS_LEFT_WEAPON 
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1,iOverlays);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      iArms_xlat = Send(self,@GetArmsTranslation);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iLeft_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iLeft_group); 
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iRight_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }
      
      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_CYCLE, 4,100, 2,2, 2,5);
      }

      iSkin_xlat = Send(self,@GetSkinColor);

      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);

      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes,1, HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }

      if poHair_remove = $
      {  
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1); 
      }

      foreach i in plOverlays
      {
         % Moved all of this to the item kod, since items may now
         %  have more than one overlay.
         Send(i,@SendOverlayInformation,#iAnimation = $);
      }

      return;
   }

   SendOverlays(iAnimation=$)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $ and iAnimation <> $
      {
         Send(poIllusion_set,@IllusionSendOverlays,#who=self,
              #animation=iAnimation);

         return;
      }


      % Send overlay bitmap info to user.

      % Player has 7 standard overlays:
      %  right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      % Overlay info -- display correct group for animation & action

      iLeft_group = 1;
      iRight_group = 1;
      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays,#iAnimation=iAnimation);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1, iOverlays);
      iArms_xlat = Send(self,@GetArmsTranslation);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      if iArms_Xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,8, 2,8, 2,iLeft_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,5, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,9, 2,9, 2,iLeft_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE,2,iLeft_group);
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_NONE
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }
      else if iAnimation = PANM_WAVE
      {
         AddPacket(1,ANIMATE_ONCE, 4,100, 2,7, 2,10, 2,iRight_group);
      }
      else if iAnimation = PANM_POINT
      {
         AddPacket(1,ANIMATE_ONCE, 4,700, 2,12, 2,12, 2,iRight_group);
      }
      else if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,11, 2,11, 2,iRight_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,13, 2,14, 2,iRight_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,15, 2,16, 2,iRight_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,17);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,900, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,7, 2,7, 2,1);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,1);
      }

      iSkin_xlat = Send(self,@GetSkinColor);
      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);
      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes, 1,HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }

      if poHair_remove = $
      {
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1);
      }

      foreach i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation=iAnimation);
      }

      return;
   }

   MsgPlayerHitResisted(what=$,resistance=$,target=$,color_rsc=player_hit_color_none)
   "Send a message to the player if the person hit has a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5)
      {
         if resistance > (3*MAX_RESISTANCE/5)
         {
            rMessage = player_hit_immunity;
         }
         else
         {
            rMessage = player_hit_resisted;
         }
      }

      if resistance <= (MIN_RESISTANCE/5)
      {
         if resistance <= (3*MIN_RESISTANCE/5)
         {
            rMessage = player_hit_anti_immunity;
         }
         else
         {
            rMessage = player_hit_anti_resisted;
         }
      }

      if rMessage <> $
      {
         Send(what,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc,
               #parm2=Send(target,@GetCapDef),#parm3=Send(target,@GetName));
      }

      return;
   }

   MsgPlayerResistsHit(what=$,resistance=$,color_rsc=player_hit_color_none)
   "Send a message to the player if they have a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5) 
      {
         if resistance > (2*MAX_RESISTANCE/3)
         {
            rMessage = player_immune_to_hit;
         }
         else
         {
            rMessage = player_resists_hit;
         }
      }

      if resistance < (MIN_RESISTANCE/5)
      {
         if resistance < (2*MIN_RESISTANCE/3)
         {
            rMessage = player_anti_immune_to_hit;
         }
         else
         {
            rMessage = player_anti_resists_hit;
         }
      }

      if rMessage <> $
      {
         Send(self,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc);
      }

      return;
   }

   PlayerWasHit(atype = 0, aspell = 0)
   "Select a message to Send the player when they are hit."
   {
      if aspell > 0 % do spell attacks first, so flaming swords use the special
      {
         if (aspell&ATCK_SPELL_FIRE) > 0 { return player_was_burned;}
         if (aspell&ATCK_SPELL_SHOCK) > 0 { return player_was_shocked;}
         if (aspell&ATCK_SPELL_COLD) > 0 { return player_was_frozen;}
         if (aspell&ATCK_SPELL_HOLY) > 0 { return player_was_holyhit;}
         if (aspell&ATCK_SPELL_UNHOLY) > 0 { return player_was_unholyhit;}
         if (aspell&ATCK_SPELL_QUAKE) > 0 { return player_was_quaked;}
      }

      if atype > 0   % do weapon attacks (odd ones first).
      {
         if (atype&ATCK_WEAP_BITE) > 0 { return player_was_bitten;}
         if (atype&ATCK_WEAP_CLAW) > 0 { return player_was_clawed;}
         if (atype&ATCK_WEAP_STING) > 0 { return player_was_stung;}
         if (atype&ATCK_WEAP_SLASH) > 0 { return player_was_slashed;}
         if (atype&ATCK_WEAP_BLUDGEON) > 0 { return player_was_bludgeoned;}
         if (atype&ATCK_WEAP_PIERCE) > 0 { return player_was_pierced;}
         if (atype&ATCK_WEAP_THRUST) > 0 { return player_was_thrusted;}

         % Put non-weapon strokes here.
         if (atype&ATCK_WEAP_PUNCH) > 0 {return player_was_punched;}
         if (atype&ATCK_WEAP_KICK) > 0 {return player_was_kicked;}
      }

      return player_was_hit;
   }

   AddPoison(strength = 0, bVigorLoss = TRUE)
   {
      if ptPoison = $
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      piPoisonStrength = piPoisonStrength + strength;

      if bVigorLoss
      {
         piVigor = piVigor - 20;
         Send(self,@NewVigor);
      }

      return;
   }

   RemovePoison(strength = 0)
   {
      piPoisonStrength = piPoisonStrength - strength;

      return;
   }

   PoisonTimer()
   {
      ptPoison = $;

      % For safety's sake
      if piPoisonStrength <= 0
      {
         piPoisonStrength = 0;

         return;
      }

      if poOwner <> $
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      if poOwner = $
      {
         return;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if NOT Send(poOwner,@SafePlayerAttack)
         OR Send(poOwner,@IsValidTarget,#who=self)
      {
         % Poison only hurts you in the arena if you are a combatant.
         piHealth = piHealth - piPoisonStrength / 10;
         if piHealth < 1
         {
            piHealth = 1;
         }

         Send(self,@NewHealth);
      }

      return;
   }

   AddMight(points = 0, bAbsolute = TRUE)
   "Returns signed change to might (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMight;

      iOrigMight = piMightMod;
      piMightMod = piMightMod + points;

      if NOT bAbsolute
      {
         piMightMod = bound(piMightMod,-piMight,(MAXIMUM_STAT-piMight));
      }

      Send(self,@DrawMight);
      
      if Send(self,@HasSkill,#num=SKID_HEAVY_ARMOR)
      {
         Send(self,@DrawDefense);
      }

      Post(self,@DrawCapacity);

      return piMightMod - iOrigMight;
   }

   AddIntellect(points = 0, bAbsolute = TRUE)
   "Returns signed change to intellect (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellectMod;
      piIntellectMod = piIntellectMod + points;

      if NOT bAbsolute
      {
         piIntellectMod = bound(piIntellectMod,-piIntellect,(MAXIMUM_STAT-piIntellect));
      }

      Send(self,@DrawIntellect);

      return piIntellectMod - iOrigIntellect;
   }

   AddAim(points = 0, bAbsolute = TRUE)
   "Returns signed change to aim (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAim;

      iOrigAim = piAimMod;
      piAimMod = piAimMod + points;

      if NOT bAbsolute
      {
         piAimMod = bound(piAimMod,-piAim,(MAXIMUM_STAT-piAim));
      }

      Send(self,@DrawAim);
      Post(self,@DrawOffense);

      return piAimMod - iOrigAim;
   }

   AddStamina(points = 0, bAbsolute = TRUE)
   "Returns signed change to stamina (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigStamina;

      iOrigStamina = piStaminaMod;
      piStaminaMod = piStaminaMod + points;

      if NOT bAbsolute
      {
         piStaminaMod = bound(piStaminaMod,-piStamina,(MAXIMUM_STAT-piStamina));
      }

      Send(self,@DrawStamina);
      Send(self,@DrawHPChance);

      return piStaminaMod - iOrigStamina;
   }

   AddAgility(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAgility;

      iOrigAgility = piAgilityMod;
      piAgilityMod = piAgilityMod + points;

      if NOT bAbsolute
      {
         piAgilityMod = Bound(piAgilityMod,-piAgility,(MAXIMUM_STAT-piAgility));
      }

      Send(self,@DrawAgility);
      Post(self,@DrawDefense);

      return piAgilityMod - iOrigAgility;
   }

   AddMysticism(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticismMod;
      piMysticismMod = piMysticismMod + points;

      if NOT bAbsolute
      {
         piMysticismMod = Bound(piMysticismMod,-piMysticism,(MAXIMUM_STAT-piMysticism));
      }

      Send(self,@DrawMysticism);
      Send(self,@ComputeMaxMana);

      return piMysticismMod - iOrigMysticism;
   }

   StartResting()
   {
      if ptRest <> $
      {
         return;
      }

      Send(self,@CancelFortitude);

      if Send(self,@GetSkillAbility,#skill_num=SKID_TRACK) > 0
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_TRACK),@StopTracking,#who=self);
      }

      Send(self,@BreakTrance,#event=EVENT_REST);
      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));
      Send(self,@ResetPlayerFlagList);
      
      if Send(self,@HasSkill,#num=SKID_MAYURASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_MAYURASANA),@StartedResting,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_SIRSASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_SIRSASANA),@StartedResting,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_SALABHASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_SALABHASANA),@StartedResting,#who=self);
      }

      return;
   }

   IsResting()
   "If there is no rest timer, the player is not resting."
   {
      if ptRest = $
      {
         return FALSE;
      }

      return TRUE;
   }

   GetRestTime()
   {
      local iTime, lRadiusState;

      iTime = 1000 + (30* (51-Send(self,@getStamina)));

      iTime = Bound(iTime,1000,$);
      
      if Send(self,@GetStamina) > 50
      {
         iTime = iTime - Send(self,@GetStamina)*2;
      }

      if Send(self,@GetStance) <> $
      {
         iTime = Send(Send(self,@GetStance),@ModifyRestTime,#who=self,#iTime=iTime);
      }

      return iTime;
   }

   RestTimer()
   {
      ptRest = $;

      if piVigor < piVigor_rest_threshold
      {
         Send(self,@RestAddExertion,#amount=-10000);
      }

      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));
      
      if Send(self,@HasSkill,#num=SKID_PADMASANA)
         AND Send(self,@IsEnchanted,#byClass=&Debuff)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_PADMASANA),@ClearDebuffs,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_VRIKSHASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_VRIKSHASANA),@SenseHiddenAndInvisible,#who=self);
      }

      return;
   }

   StopResting()
   {
      if ptRest <> $
      {
         DeleteTimer(ptRest);
         ptRest = $;
      }
      
      if Send(self,@HasSkill,#num=SKID_MAYURASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_MAYURASANA),@StoppedResting,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_SIRSASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_SIRSASANA),@StoppedResting,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_SALABHASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_SALABHASANA),@StoppedResting,#who=self);
      }
      
      if Send(self,@HasSkill,#num=SKID_VRIKSHASANA)
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_VRIKSHASANA),@StoppedResting,#who=self);
      }

      Send(self,@StartFortitude);

      Send(self,@ResetPlayerFlagList);

      return;
   }

   IsCursedByItems()
   "Returns TRUE if player is using an item that's cursed, FALSE otherwise."
   {
      local i;

      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   RemoveCurseAllItems()
   "Returns TRUE if the player has a cursed item stripped away, FALSE if not."
   {
      local i, bFound;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            Send(self,@UnuseItem,#what=i);
            bFound = TRUE;
         }
      }

      return bFound;
   }

   GetArmor()
   "If plUsing holds any armor, return that object."
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Armor)
         {
            return i;
         }
      }

      return $;
   }

   IsDead()
   {
      return (piHealth <= 0);
   }

   SetTranceFlag()
   {
      piFlags = piFlags | PFLAG_TRANCE;

      return;
   }

   ClearTranceFlag()
   {
      piFlags = piFlags & (~PFLAG_TRANCE);

      return;
   }

   SetFlickerFlag()
   {
      piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

      return;
   }

   RecalcFlickerFlag()
   "Called by anything that sets the flag when it wants to unset it. "
   "Checks if we still have anything that still requires the flag."
   {
      local i;

      % Unset flag.
      piDrawEffectFlag = piDrawEffectFlag & (~OF_FLICKERING);

      % Check torches and glow enchantment.
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
            OR IsClass(i,&MithrilShield)
            OR IsClass(i,&JewelOfFroz)
            OR (IsClass(i,&Weapon)
               AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

            return;
         }
      }

      % Check radius enchantments.
      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
            AND NOT Send(First(i),@GetOldAreaEnchStyle)
         {
            piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

            return;
         }
      }

      return;
   }

   BreakTrance(event = 0, what = $)
   {
      local i, oEnch,state, bFound, oYellNum, oYellRoom;

      if event = EVENT_RUN
         OR event = EVENT_DAMAGE
         OR event = EVENT_ATTACK
         OR event = EVENT_CAST
         OR (event = EVENT_STANCE_CHANGE
               AND what <> $
               AND NOT IsClass(what,&LightFeet))
      {
         if NOT (poStance <> $
               AND IsClass(poStance,&LightFeet))
           OR event = EVENT_STANCE_CHANGE
         {
            Post(Send(SYS,@FindSkillByNum,#num=SKID_SNEAK),@StopSneaking,#who=self);
         }
         if event = EVENT_RUN
            OR event = EVENT_DAMAGE
            OR event = EVENT_ATTACK
            OR event = EVENT_CAST
            OR (event = EVENT_STANCE_CHANGE
               AND what <> $
               AND NOT IsClass(what,&LightFeet))
         {
            Post(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),@StopHiding,#who=self);
         }
         
         if event = EVENT_RUN
            AND Send(self,@FindUsing,#class=&VoidstepTabi) <> $
         {
            Send(Send(self,@FindUsing,#class=&VoidstepTabi),@WearerRan);
         }
         
         Post(Send(SYS,@FindSkillByNum,#num=SKID_SPY),@StopSpying,#who=self);
      }

      bFound = FALSE;
      foreach i in plEnchantments
      {
         oEnch = Nth(i,2);
         if IsClass(oEnch,&Spell) OR IsClass(oEnch,&Trance)
         {
            state = $;
            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               state = Nth(i,3);
            }

            if IsClass(oEnch,&Trance)
            {
               Send(oEnch,@BreakTrance,#who=self,#state=state,
                    #event=event,#what=what,
                    #time_remaining=GetTimeRemaining(Nth(i,1)));
            }
            else
            {
               Send(oEnch,@BreakTrance,#who=self,#state=state,
                     #event=event,#what=what);
            }

            bFound = TRUE;
         }
      }

      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
         {
            Send(Nth(i,1),@BreakTrance,#who=Nth(i,3),#event=event);
         }
      }

      if event = EVENT_NEWOWNER
      {
         foreach oYellNum in Send(poOwner,@GetYellZone)
         {
            oYellRoom = Send(SYS,@FindRoomByNum,#num=oYellNum);
            if Send(oYellRoom,@BreakTrance,#who=self)
            {
               bFound = TRUE;

               break;
            }
         }
      }

      if poOwner <> $
         AND Send(poOwner,@BreakTrance,#who=self,#event=event)
      {
         bFound = TRUE;
      }

      return bFound;
   }

   RecalcBulkAndWeight()
   {
      return;
   }

   GetRacialLightLevel()
   {
      switch(piPlayerRace)
      {
         case RACE_HUMAN:
            return 5;
         case RACE_HALF_ORC:
            return 60;
         case RACE_HALF_DEMON:
            return 0;
         case RACE_HALF_ELF:
            return 15;
         case RACE_DROW:
            return 25;
         case RACE_HALF_UNDINE:
            return 25;
         case RACE_DRACONIAN:
            return 35;
         case RACE_GNOME:
            return 30;
         case RACE_AUTOMATON:
            return 5;
      }
      return 5;
   }

   RecalcLight()
   {
      local i, iLight, iState, oWeapon, oItemAtt;

      % TODO: Make this into a general check.

      % Default base value
      iLight = Send(self,@GetRacialLightLevel);

      % Torch, Amulet
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }

         if IsClass(i,&ShadowAmulet)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }
      }

      iState = Send(self,@GetEnchantedState,#what=Send(SYS,@FindSpellByNum,#num=SID_NIGHT_VISION));
      if iState <> $
      {
         iLight = iLight + iState;
      }

      foreach i in plReservedSpells
      {
         if IsClass(Nth(i,1),&TouchAttackSpell)
         {
            iLight = iLight + Send(Nth(i,1),@GetEnchantmentLight);
         }
      }

      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),&TouchAttackSpell)
         {
            iLight = iLight + Send(Nth(i,2),@GetEnchantmentLight);
         }
      }

      % Glowing weapons?
      oWeapon = Send(self,@LookupPlayerWeapon);
      if oWeapon <> $
      {
         iState = Send(oWeapon,@GetAttributeData,#ItemAtt=WA_GLOWING);
         if iState <> $
         {
            iLight = iLight + Nth(iState,3);
         }
      }
      
      if poOwner <> $
         AND Send(poOwner,@OverridePlayerLightLevel)
      {
         iLight = Send(poOwner,@GetOverridePlayerLightLevel);
      }

      if piLight <> iLight
      {
         piLight = iLight;
         Send(self,@NewLight);
      }

      return;
   }

   GetPlayerLightLevel()
   "Calls RecalcLight and returns the light level."
   {
      Send(self,@RecalcLight);

      % This should be accurate after calling RecalcLight.
      return piLight;
   }

   UnuseAllItems()
   {
      local i;

      foreach i in plUsing
      {
         Send(self,@UnuseItem,#what=i,#Recalibrate=TRUE);
      }

      if plUsing <> $
      {
         plUsing = $;
      }

      return Send(SYS,@GetSuccessRsc);
   }

   RecalibratePlayer()
   {
      local i, bSoldier;

      bSoldier = FALSE;
      if Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         bSoldier = TRUE;
      }

      Send(self,@UnuseAllItems);
      Send(self,@RemoveAllEnchantments);
      Send(self,@RecalcBulkAndWeight);
      Send(self,@ResetPlayerFlagList);

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
         Send(self,@MsgSendUser,#message_rsc=second_wind_finished);
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
               #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }

      Send(self,@SetVigorRestThreshold);

      Send(self,@EndCrystalizeManaSurge);

      % All attack modifiers should be a room enchantment, a personal
      % enchantment or something they are wearing. If one still exists,
      % bug.  This is also true for defense modifiers and resistances.
      if plAttack_modifiers <> $
      {
         foreach i in plAttack_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had attmod",Send(i,@GetName));
         }

         plAttack_modifiers = $;
      }

      if plDefense_modifiers <> $
      {
         foreach i in plDefense_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had defmods",Send(i,@GetName));
         }
         
         plDefense_modifiers = $;
      }

      if plResistances <> $
      {
         foreach i in plResistances
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had resistance",first(i),Nth(i,2));
         }

         plResistances = $;
      }

      plResistances = Send(self,@GetRacialBaseResistances);

      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();
      piKill_count_decay = Bound(piKill_count_decay,0,$);

      if plEnchantments <> $
      {
         foreach i in plEnchantments
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had enchantments",Send(Nth(i,2),@GetName));
         }

         plEnchantments = $;
      }

      if piLight <> 5
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "had bad light value",piLight,"after being stripped!");
         piLight = 5;
      }

      if piMax_health <> piBase_max_health
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "with max health",piMax_health,"did not match Base Max Health",
               piBase_max_health);
         piMax_health = piBase_max_health;
      }

      Send(self,@ComputeMaxMana);

      if piDrawfx <> 0
      {
         Debug("Recalibrating: Player",Send(self,@GetTrueName),
               "with piDrawFX was equal to",piDrawFX,"instead of 0.");
         piDrawFX = 0;
      }

      if poIllusion_set <> $
      {
         Debug("recalibrating: Player",Send(self,@GetTrueName),
               "with illusion_set not set to $!");
         poIllusion_set = $;
      }

      if poGuild <> $ AND NOT Send(poGuild,@IsMember,#who=self)
      {
         Debug("Player",Send(self,@GetTrueName),"points to guild",
               Send(poGuild,@GetName)," but guild doesn't point to player!");
      }
      
      % Reset our modifiers
      Send(self,@ZeroMods);

      if bSoldier
      {
         foreach i in plPassive
         {
            if IsClass(i,&SoldierShield)
            {
               Send(self,@TryUseItem,#what=i);
            }
         }
      }

      Send(self,@ClearStance);
      Send(self,@ClearElementalImbalance);

      % Reset death costs to 0.
      piDeathCost = 0;

      poEvilTwin = $;

      return Send(SYS,@GetSuccessRsc);
   }

   RecalibrateBaseResistances()
   {
      % Clearing old resistance system values.
      plResistances = Send(self,@GetRacialBaseResistances);
      return;
   }

   GetBulkMax()
   {
      return viBulk_hold_max + (Send(self,@GetMight) * 30);
   }

   GetWeightMax()
   {
      return viWeight_hold_max + (Send(self,@GetMight) * 30);
   }

   CountKnownAtLevel(school=$,level=$)
   {
      local i, count, nSID, nObj;

      count = 0;
      foreach i in plSkills
      {
         nSID = Send(self,@DecodeSkillNum,#compound=i);
         nObj = Send(SYS,@FindSkillByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         if Send(nObj,@IsUtilitySkill)
         {
            continue;
         }

         % Is this in the same school?
         if Send(nObj,@GetSchool) = school
            AND Send(nobj,@GetLevel) = level
         {
            count = count + 1;
         }
      }
      foreach i in plSpells
      {
         nSID = Send(self,@DecodeSpellNum,#compound=i);
         nObj = Send(SYS,@FindSpellByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         if Send(nObj,@GetIntellectExempt)
         {
            continue;
         }

         % Is this in the same school?
         if (Send(nObj,@GetSchool) = school)
            and (Send(nobj,@GetLevel)) = level
         {
            count = count + 1;
         }
      }

      return count;
   }

   PlayerCanLearn(spell_num=0,skill_num=0)
   "New routine as of 14 June 97. Intended to allow for more schools, "
   "odd numbers of spells at a spell level and easier understanding."
   "The proverbial trick is that players have to know WHY they aren't "
   "learning. For example, if a player can't learn because he has too "
   "many competing schools, he needs to know that."
   {
      local obj, iHave, prev_level,
            aHigh, bHigh, cHigh, iBase, i, temp,
            nObj, nSID, index, iNeed, nSchool, nLevel, bKnowOne,
            iWeapon, iKraanan, iShalille, iQor, iFaren, iRiija, iJala,
            iKnightcraft, iBanditry, iSorcery, iWitchery, iAlchemy, iShadowcraft, iBestiary;
      % This function is close to parameter limit.

      % Phase one. Assert our data. Be sure we have been fed a valid spell
      % and skill num for a spell item that actually exists.
      if spell_num = 0
      {
         if skill_num = 0
         {
            Debug("No data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            obj = Send(SYS,@FindSkillByNum,#num=skill_num);
         }
      }
      else
      {
         if skill_num <> 0
         {
            Debug("Too much data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            obj = Send(SYS,@FindSpellByNum,#num=spell_num);
         }
      }
      if obj = $
      {
         Debug("Fed a spell number for a spell that does not exist in the "
               "system.");

         return PLAYER_LEARN_ERROR;
      }

      if NOT Send(obj,@IsAccessible)
      {
         % Sacred Haven server.
         return PLAYER_LEARN_ERROR;
      }

      if IsClass(obj,&Spell) AND NOT Send(obj,@IsEnabled)
      {
         % Spell is temporarily disabled.
         return PLAYER_LEARN_ERROR;
      }
      
      % Check for Witchery hatreds.
      if Send(obj,@GetSchool) = SS_WITCHERY
      {
         if Send(obj,@GetSubSchool) = SSS_WITCHERY_XAERDUN
         {
            if Send(self,@HasWitcherySubSchool,#school=SSS_WITCHERY_VENTDAL)
            {
               return PLAYER_LEARN_HAS_VENTDAL;
            }
         }
         if Send(obj,@GetSubSchool) = SSS_WITCHERY_VENTDAL
         {
            if Send(self,@HasWitcherySubSchool,#school=SSS_WITCHERY_XAERDUN)
            {
               return PLAYER_LEARN_HAS_XAERDUN;
            }
         }
         if Send(obj,@GetSubSchool) = SSS_WITCHERY_NEQUZON
         {
            if Send(self,@HasWitcherySubSchool,#school=SSS_WITCHERY_IWODACH)
            {
               return PLAYER_LEARN_HAS_IWODACH;
            }
         }
         if Send(obj,@GetSubSchool) = SSS_WITCHERY_IWODACH
         {
            if Send(self,@HasWitcherySubSchool,#school=SSS_WITCHERY_NEQUZON)
            {
               return PLAYER_LEARN_HAS_NEQUZON;
            }
         }
      }

      % Phase three. We begin to find our need.  Start by finding out how many
      % spells exist at ALL at that level. While we are going through the spell
      % skill list, count the spells/skills that count towards our total. Note
      % that we only want the top three spells/skills at that school and level.

      bKnowOne = FALSE;

      % Check to see if they have any spells of the next level.
      %  If so, let them buy any spells they want.
      iHave = Send(self,@CountKnownAtLevel,#school=Send(obj,@GetSchool),#level=Send(obj,@GetLevel)+1);
      if iHave > 0
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % See how many spells they have at this level.
      iHave = Send(self,@CountKnownAtLevel,#school=Send(obj,@GetSchool),#level=Send(obj,@GetLevel));
      if iHave > 0
      {
         % For level 3 or higher, they can learn if they have another spell
         % in that school and level. If they have two spells at a lower level,
         % they need 2 or more spells in that school or level. This prevents
         % people getting all level 2 spells fresh out of character creation.
         if Send(obj,@GetLevel) > 2
            OR iHave >= 2
         {
            return PLAYER_LEARN_SUCCESS;
         }

         % Flag it so we know that they already have a spell in that level.
         bKnowOne = TRUE;
      }

      if Send(obj,@GetLevel) > 1
      {
         prev_level = Send(SYS,@GetNumAtLevel,#school=Send(obj,@GetSchool),#level=Send(obj,@GetLevel)-1);
      }
      else
      {
         prev_level = 0;
      }

      aHigh = 0; bHigh = 0; cHigh = 0;

      iWeapon = 0;
      iKnightcraft = 0;
      iBanditry = 0;
      iSorcery = 0;
      iWitchery = 0;
      iAlchemy = 0;
      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iShadowcraft = 0;
      iBestiary = 0;

      foreach i in plSkills
      {
         nSID=Send(self,@DecodeSkillNum,#compound=i);
         nobj=Send(SYS,@FindSkillByNum,#num=nSID);

         if nobj = $
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         nSchool = Send(nobj,@GetSchool);
         nLevel = Send(nobj,@GetLevel);

         % Is this in the same school at level N-1?
         if Send(obj,@GetSchool) = nSchool AND (Send(obj,@GetLevel)-1) = (nLevel)
         {
            index = Send(self,@DecodeSkillAbility,#compound=i);
            if index > aHigh
            {
               temp = aHigh;
               aHigh = index;
               index = temp;
            }

            if index > bHigh
            {
               temp = bHigh;
               bHigh = index;
               index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         if NOT Send(nobj,@IsUtilitySkill)
         {
            if nSchool = SKS_FENCING
               AND nLevel > iWeapon
            {
               iWeapon = nLevel;
            }
            if nSchool = SKS_KNIGHTCRAFT
               AND nLevel > iKnightcraft
            {
               iKnightcraft = nLevel;
            }
            if nSchool = SKS_BANDITRY
               AND nLevel > iBanditry
            {
               iBanditry = nLevel;
            }
            if nSchool = SKS_SORCERY
               AND nLevel > iSorcery
            {
               iSorcery = nLevel;
            }
            if nSchool = SS_WITCHERY
               AND nLevel > iWitchery
            {
               iWitchery = nLevel;
            }
            if nSchool = SKS_ALCHEMY
               AND nLevel > iAlchemy
            {
               iAlchemy = nLevel;
            }
            if nSchool = SKS_SHADOWCRAFT
               AND nLevel > iShadowcraft
            {
               iShadowcraft = nLevel;
            }
            if nSchool = SS_BESTIARY
               AND nLevel > iBestiary
            {
               iBestiary = nLevel;
            }
         }
      }

      foreach i in plSpells
      {
         nSID=Send(self,@DecodeSpellNum,#compound=i);
         nobj=Send(SYS,@FindSpellByNum,#num=nSID);
         
         if nobj = $
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         nSchool = Send(nobj,@GetSchool);
         nLevel = Send(nobj,@GetLevel);

         if (NOT IsClass(nobj,&Spell)) OR (nLevel> 10)
         {
            continue;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         if nSchool = SS_DM_COMMAND
         {
            continue;
         }

         % Is this in the same school at level N-1?
         if Send(obj,@GetSchool) = nSchool AND (Send(obj,@GetLevel)-1) = (nlevel)
         {
            index = Send(self,@DecodeSpellAbility,#compound=i);

            if index > aHigh
            {
               temp = aHigh; aHigh = index; index = temp;
            }

            if index > bHigh
            {
               temp = bHigh; bHigh = index; index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         if NOT Send(nobj,@GetIntellectExempt)
         {
            if nSchool = SS_KRAANAN
               AND nLevel > iKraanan
            {
               iKraanan = nLevel;
            }

            if nSchool = SS_SHALILLE
               AND nLevel > iShalille
            {
               iShalille = nLevel;
            }

            if nSchool = SS_QOR
               AND nLevel > iQor
            {
               iQor = nLevel;
            }

            if nSchool = SS_FAREN
               AND nLevel > iFaren
            {
               iFaren = nLevel;
            }

            if nSchool = SS_RIIJA
               AND nLevel > iRiija
            {
               iRiija = nLevel;
            }

            if nSchool = SS_JALA
               AND nLevel > iJala
            {
               iJala = nLevel;
            }

            if nSchool = SKS_KNIGHTCRAFT
               AND nLevel > iKnightcraft
            {
               iKnightcraft = nLevel;
            }

            if nSchool = SS_WITCHERY
               AND nLevel > iWitchery
            {
               iWitchery = nLevel;
            }
            
            if nSchool = SKS_ALCHEMY
               AND nLevel > iAlchemy
            {
               iAlchemy = nLevel;
            }
            
            if nSchool = SKS_SHADOWCRAFT
               AND nLevel > iShadowcraft
            {
               iShadowcraft = nLevel;
            }
            
            if nSchool = SS_BESTIARY
               AND nLevel > iBestiary
            {
               iBestiary = nLevel;
            }
         }
      }

      if Send(obj,@GetLevel) > 1
      {
         % Only top three matter in the math.
         iHave = aHigh + bHigh + cHigh;
      }
      else
      {
         % You always have the "max" for level 1
         iHave = (3 * 99);
      }

      % Do easy checks to prevent unnecessary math.
      % Keep these checks here so they are of lower precedence than
      % the 'you already have this spell' check.

      if NOT Send(obj,@KarmaCheck,#who=self)
      {
         return PLAYER_LEARN_KARMA;
      }

      % Player can't learn level this because he knows nothing of
      %  previous level.
      if iHave = 0
      {
         return PLAYER_LEARN_NOBASE;
      }

      % We have done all the information gathering, so now, lets compute:

      temp =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
               + Send(SYS,@GetLevelLearnPoints,#level=iKnightcraft)
               + Send(SYS,@GetLevelLearnPoints,#level=iBanditry)
               + Send(SYS,@GetLevelLearnPoints,#level=iSorcery)
               + Send(SYS,@GetLevelLearnPoints,#level=iWitchery)
               + Send(SYS,@GetLevelLearnPoints,#level=iAlchemy)
               + Send(SYS,@GetLevelLearnPoints,#level=iShadowcraft)
               + Send(SYS,@GetLevelLearnPoints,#level=iBestiary)
               + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
               + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
               + Send(SYS,@GetLevelLearnPoints,#level=iQor)
               + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
               + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
               + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      % Okay, we're going into new territory if we don't already know one
      %  spell in the school, so we're increasing the level of our
      %  knowledge.  Add points.
      if not bKnowOne
      {
         temp = temp + Send(SYS,@GetLevelLearnPoints,#level=Send(obj,@GetLevel))
                           - Send(SYS,@GetLevelLearnPoints,#level=(Send(obj,@GetLevel)-1));
      }

      % How this oddball equation works: You have a POINTS_SLOPE that determines
      %  how steep the advancement slope is.  A higher slope results in lower
      %  levels requiring less points, but each school level gained counts more
      %  against future learning.  You hit your max when you get to 297 points
      %  (3*99), so when your points equals max points, you've maxxed out.  
      %  Intellect gives you a bonus to learning, currently about 20 points
      %  for 50 Intellect (approximately mastering 2 extra schools)
      iNeed =   (temp * POINTS_SLOPE)
              + (297 - (Send(SETTINGS_OBJECT, @GetMaxLearnPoints) * POINTS_SLOPE))
              - ((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5);

      % NOTE: if you modify the above equation, also modify GivePlayerAllSkills
      %  and GivePlayerAllSpells as needed

      % Bound iNeed to a reasonable low level so people can't just rush in and
      %  get high level with very little work.
      iNeed = bound(iNeed,MIN_NEEDED_TO_ADVANCE,$);

      % If the previous level has fewer than three spells, help them out.
      if prev_level = 1
      {
         iNeed= iNeed / 3;
      }

      if prev_level = 2
      {
         iNeed = (iNeed*2)/3;
      }

      if iHave >= iNeed
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % Okay, at this point, we know that they didn't pass the test.  Now give
      % them a good reason why.  Essentially, if they know a lot of other
      % divisions and it's slowing them down, tell them that.  Otherwise,
      % be more generic.
      
      % Is it now impossible to actually learn this spell level?  This would
      % mean that the need is greater than 99% in three of the previous
      % level's spells, or 297 (most of the time).  Levels with fewer than
      % three spells are a special instance.
      if iNeed > (99*(bound(prev_level,1,3)))
      {
         return PLAYER_LEARN_IMPOSSIBLE;
      }

      % Return info in this format (base 10):  xxxy, where xxx is the number
      % of spell or skill points they need, and y is the reason why they
      % failed.  Only condition is "not enough points".
      return ((10*(iNeed-iHave))+PLAYER_LEARN_BASE);
   }

   HasWitcherySubSchool(school=SSS_WITCHERY_NEQUZON)
   {
      local i, nSID, nobj;
      
      foreach i in plSpells
      {
         nSID=Send(self,@DecodeSpellNum,#compound=i);
         nobj=Send(SYS,@FindSpellByNum,#num=nSID);
         
         if Send(nobj,@GetSchool) = SS_WITCHERY
         {
            if Send(nobj,@GetSubSchool) = school
            {
               return TRUE;
            }
         }
      }
      foreach i in plSkills
      {
         nSID=Send(self,@DecodeSkillNum,#compound=i);
         nobj=Send(SYS,@FindSkillByNum,#num=nSID);
         
         if Send(nobj,@GetSchool) = SS_WITCHERY
         {
            if Send(nobj,@GetSubSchool) = school
            {
               return TRUE;
            }
         }
      }
      return FALSE;
   }

   GetTotalLearnPoints(except = $)
   {
      local iSpell, iSID, oSpellObj, iSchool, iLevel, iKraanan, iShalille, iSkill, oSkillObj,
            iQor, iFaren, iRiija, iJala, iWeapon, iBanditry, iSorcery, iWitchery, iKnightcraft, iAlchemy, 
            iShadowcraft, iBestiary, iTotalLearnPoints;

      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iWeapon = 0;
      iKnightcraft = 0;
      iBanditry = 0;
      iSorcery = 0;
      iWitchery = 0;
      iAlchemy = 0;
      iShadowcraft = 0;
      iBestiary = 0;

      foreach iSpell in plSpells
      {
         iSID = Send(self,@DecodeSpellNum,#compound=iSpell);
         oSpellObj = Send(SYS,@FindSpellByNum,#num=iSID);
         
         if oSpellObj = $
         {
            continue;
         }

         iSchool = Send(oSpellObj,@GetSchool);
         iLevel = Send(oSpellObj,@GetLevel);

         if NOT Send(oSpellObj,@GetIntellectExempt)
            AND iSchool <> SS_DM_COMMAND
            AND except <> iSchool
         {
            if iSchool = SS_KRAANAN
               AND iLevel > iKraanan
            {
               iKraanan = iLevel;
            }

            if iSchool = SS_SHALILLE
               AND iLevel > iShalille
            {
               iShalille = iLevel;
            }

            if iSchool = SS_QOR
               AND iLevel > iQor
            {
               iQor = iLevel;
            }

            if iSchool = SS_FAREN
               AND iLevel > iFaren
            {
               iFaren = iLevel;
            }

            if iSchool = SS_RIIJA
               AND iLevel > iRiija
            {
               iRiija = iLevel;
            }

            if iSchool = SS_JALA
               AND iLevel > iJala
            {
               iJala = iLevel;
            }

            if iSchool = SS_WITCHERY
               AND iLevel > iWitchery
            {
               iWitchery = iLevel;
            }

            if iSchool = SKS_KNIGHTCRAFT
               AND iLevel > iKnightcraft
            {
               iKnightcraft = iLevel;
            }

            if iSchool = SKS_ALCHEMY
               AND iLevel > iAlchemy
            {
               iAlchemy = iLevel;
            }

            if iSchool = SKS_SHADOWCRAFT
               AND iLevel > iShadowcraft
            {
               iShadowcraft = iLevel;
            }

            if iSchool = SS_BESTIARY
               AND iLevel > iBestiary
            {
               iBestiary = iLevel;
            }
         }
      }

      foreach iSkill in plSkills
      {
         iSID = Send(self,@DecodeSkillNum,#compound=iSkill);
         oSkillObj = Send(SYS,@FindSkillByNum,#num=iSID);
         
         if oSkillObj = $
         {
            continue;
         }

         iSchool = Send(oSkillObj,@GetSchool);
         iLevel = Send(oSkillObj,@GetLevel);

         if NOT Send(oSkillObj,@IsUtilitySkill)
            AND iSchool <> SS_DM_COMMAND
            AND except <> iSchool
         {
            if iSchool = SKS_FENCING
               AND iLevel > iWeapon
               AND iLevel <> 50
            {
               iWeapon = iLevel;
            }

            if iSchool = SKS_BANDITRY
               AND iLevel > iBanditry
            {
               iBanditry = iLevel;
            }

            if iSchool = SKS_SORCERY
               AND iLevel > iSorcery
            {
               iSorcery = iLevel;
            }

            if iSchool = SS_WITCHERY
               AND iLevel > iWitchery
            {
               iWitchery = iLevel;
            }

            if iSchool = SKS_KNIGHTCRAFT
               AND iLevel > iKnightcraft
            {
               iKnightcraft = iLevel;
            }

            if iSchool = SKS_ALCHEMY
               AND iLevel > iAlchemy
            {
               iAlchemy = iLevel;
            }

            if iSchool = SKS_SHADOWCRAFT
               AND iLevel > iShadowcraft
            {
               iShadowcraft = iLevel;
            }

            if iSchool = SS_BESTIARY
               AND iLevel > iBestiary
            {
               iBestiary = iLevel;
            }
         }
      }

      if iWeapon = $
         OR iWeapon > 6
      {
         Debug("iWeapon");
         Debug(iWeapon);
      }

      if iKnightcraft = $
         OR iKnightcraft > 6
      {
         Debug("iKnightcraft");
         Debug(iKnightcraft);
      }

      if iBanditry = $
         OR iBanditry > 6
      {
         Debug("iBanditry");
         Debug(iBanditry);
      }

      if iSorcery = $
         OR iSorcery > 6
      {
         Debug("iSorcery");
         Debug(iSorcery);
      }

      if iWitchery = $
         OR iWitchery > 6
      {
         Debug("iWitchery");
         Debug(iWitchery);
      }

      if iAlchemy = $
         OR iAlchemy > 6
      {
         Debug("iAlchemy");
         Debug(iAlchemy);
      }

      if iShadowcraft = $
         OR iShadowcraft > 6
      {
         Debug("iShadowcraft");
         Debug(iShadowcraft);
      }

      if iBestiary = $
         OR iBestiary > 6
      {
         Debug("iBestiary");
         Debug(iBestiary);
      }

      if iKraanan = $
         OR iKraanan > 6
      {
         Debug("iKraanan");
         Debug(iKraanan);
      }

      if iShalille = $
         OR iShalille > 6
      {
         Debug("iShalille");
         Debug(iShalille);
      }

      if iQor = $
         OR iQor > 6
      {
         Debug("iQor");
         Debug(iQor);
      }

      if iFaren = $
         OR iFaren > 6
      {
         Debug("iFaren");
         Debug(iFaren);
      }

      if iRiija = $
         OR iRiija > 6
      {
         Debug("iRiija");
         Debug(iRiija);
      }

      if iJala = $
         OR iJala > 6
      {
         Debug("iJala");
         Debug(iJala);
      }

      iTotalLearnPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
                         + Send(SYS,@GetLevelLearnPoints,#level=iKnightcraft)
                         + Send(SYS,@GetLevelLearnPoints,#level=iBanditry)
                         + Send(SYS,@GetLevelLearnPoints,#level=iSorcery)
                         + Send(SYS,@GetLevelLearnPoints,#level=iWitchery)
                         + Send(SYS,@GetLevelLearnPoints,#level=iAlchemy)
                         + Send(SYS,@GetLevelLearnPoints,#level=iShadowcraft)
                         + Send(SYS,@GetLevelLearnPoints,#level=iBestiary)
                         + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
                         + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
                         + Send(SYS,@GetLevelLearnPoints,#level=iQor)
                         + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
                         + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
                         + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      return iTotalLearnPoints;
   }

   OptOutPvP()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_TEMPSAFE,#value=TRUE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      pbOptOutPvP = TRUE;
      return;
   }

   EvaluatePKStatus(dbug=FALSE)
   "This should always be run AFTER the player undergoes whatever changes "
   "(i.e. quits a guild or drops below 30 health).  Also, take steps to ensure "
   "it is not run immediately prior to death."
   {
      local i, ass_game;

      if (piFlags & PFLAG_PKILL_LOCK)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
      {
         if poGuild = $
            AND piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            AND NOT (piFlags & PFLAG_MURDERER)
            AND NOT (piFlags & PFLAG_OUTLAW)
            AND piReincarnations = 0
         {
            ass_game = Send(SYS,@GetAssassinGame);
            if Send(ass_game,@IsCombatant,#who=self)
            {
               Send(self,@MsgSendUser,#message_rsc=Player_dagger_shatters);
               Send(ass_game,@RemoveFromGame,
                     #who=self,#RemoveFromRecords=FALSE);
            }

            Send(self,@MsgSendUser,#message_rsc=player_regain_angel);
            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
            Send(self,@PlayerIsIntriguing);
         }
      }
      else
      {
         if poGuild <> $
            OR piBase_Max_health >= Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            OR (piFlags & PFLAG_MURDERER)
            OR (piFlags & PFLAG_OUTLAW)
         {
            if Send(SYS,@IsPKAllowed)
            {
               % Happylanders don't get 'vulnerable' message.
               Send(self,@MsgSendUser,#message_rsc=player_no_angel);
            }

            % Once you've become killable, you no longer get tutorial messages
            % and bonuses.  You also lose your newbie string.
            Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
            Send(self,@RemoveHonorString,#string=player_newbie_honor_string);

            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);
            if dbug = TRUE
            {
               Debug("Someone with less than 30 health managed to guild or "
                     "outlaw",self);
            }
         }
      }

      return;
   }

   PKillEnable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      if Send(SYS,@IsPKAllowed)
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_angel);
      }

      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillDisable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   % Note: a player with PKILL_ENABLE set will have it reset at will if 
   % an event naturally causes it to.  If you want to not have this change,
   % then call PkillLock below.  This will ensure that the status of
   % PKILL_ENABLE will never change, with the exception of a suicide.

   PkillLock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillUnlock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   StartTempSafe()
   {
      local iTime;

      % First, check if we're in a guild hall. Players can exploit this
      % system by dying in a guild hall and using PoL or the UW node to
      % teleport back to their bodies with temp safe activated, which would
      % leave them unable to be killed and inside a hall. Teleport players
      % from the guild hall to their hometown.
      if poOwner <> $
         AND IsClass(poOwner,&GuildHall)
      {
         Send(self,@AdminGotoSafety);
      }

      % This returns minutes, so convert to milliseconds.
      iTime = Send(SETTINGS_OBJECT,@GetTempSafeTime);
      iTime = iTime * 60 * 1000;

      if ptTempSafe <> $
      {
         DeleteTimer(ptTempSafe);
      }
      ptTempSafe = CreateTimer(self,@EndTempSafe,iTime);
      piFlags = piFlags | PFLAG_TEMPSAFE;
      Send(self,@MsgSendUser,#message_rsc=player_temp_safe);

      return;
   }

   EndTempSafe()
   {
      ptTempSafe = $;

      if pbOptOutPvP
      {
         return;
      }

      piFlags = piFlags & ~PFLAG_TEMPSAFE;
      if poOwner <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe_end);
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetFaction(faction = FACTION_NEUTRAL)
   {
      local oSoldierShield;

      if faction < FACTION_NEUTRAL
         OR faction > FACTION_NORMAL_MAX
      {
         return FALSE;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      if oSoldierShield <> $
         AND faction <> Send(oSoldierShield,@GetFaction)
      {
         Send(oSoldierShield,@LostFaction);
      }

      piFaction = faction;

      return TRUE;
   }

   GetFaction()
   {
      return piFaction;
   }

   % Need to be able to keep track of their service...
   % When players join, and subsequently log on, the
   % updated time gets set and the timer gets started.

   UpdateFactionService(full=False,middle=False,front=False,adjust=True)
   {
      local tyme, oSoldierShield;

      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      tyme = GetTime();

      % Don't require new service if the player has been an active soldier.
      if oSoldierShield = $
      {
         piFactionServiceUpdate = piFactionServiceUpdate + tyme - piFactionTimeUpdated;
      }
      else
      {
         % Get rid of warnings.
         if piFactionServiceUpdate > FACTION_WARN_TIME
         {
            piFactionServiceUpdate = FACTION_WARN_TIME;
         }
      }

      piFactionTimeUpdated = tyme;

      if NOT adjust
      {
         return;
      }

      if full
      {
         piFactionServiceUpdate = 0;
      }
      else if middle
      {
         piFactionServiceUpdate = piFactionServiceUpdate / 2;
      }
      else if front
      {
         piFactionServiceUpdate = 3* piFactionServiceUpdate / 4;
      }

      return;
   }

   FactionServiceTimer(renew=TRUE)
   {
      % Attempts to delete any existing timer, then passes to
      % FactionServiceRenew which creates a new timer if conditions are met.

      if ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer = $;
      }

      Send(Self,@FactionServiceRenew,#renew=renew);

      return;
   }

   FactionServiceRenew(renew=TRUE)
   {
      % This function now handles renewal of ptFactionTimer and should
      % only be accessed from FactionServiceTimer() after the $ check.

      local iHistory;
      
      ptFactionTimer = $;
      
      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      Send(Self,@UpdateFactionService,#adjust=FALSE);
      if piFactionServiceUpdate > FACTION_RESIGN_TIME
      {
         % Add bNoTimer = TRUE so we don't try to delete a non-existent timer.
         Send(self,@ResignFaction,#bNoTimer=TRUE);

         return;
      }

      if piFactionServiceUpdate > FACTION_WARN_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=player_faction_time);
         % This should be unnecessary (since loyalty quests reschedule
         % themselves at completion), but is included nonetheless to 
         % ensure that if you've been warned, there's a quest waiting for you.

         if piFaction = FACTION_PRINCESS
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
            iHistory = First(Send(self,@GetQuestHistory,
                        #index=QST_ID_PRINCESS_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_PRINCESS_SERVICE);
            }
         }

         if piFaction = FACTION_DUKE
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_DUKE_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_DUKE_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_DUKE_SERVICE);
            }
         }

         if piFaction = FACTION_REBEL
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_REBEL_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_REBEL_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_REBEL_SERVICE);
            }
         }
      }

      if renew AND Send(SYS,@GetParliament) <> $
         AND (NOT Send(Send(SYS,@GetParliament),@IsShutdown))
      {
         ptFactionTimer = CreateTimer(self,@FactionServiceRenew,
                                             FACTION_UPDATE_TIME);
      }

      return;
   }

   PlayerIsIntriguing()
   "Evaluates player and sets the PFLAG_INTRIGUING"
   {
      local bIntrigue, wasint, i, oParl;

      bIntrigue=0;

      oParl=Send(SYS,@GetParliament);
      if oParl = $
      {
         return FALSE;
      }

      wasint = (piFlags & PFLAG_INTRIGUING);

      if wasint AND Send(oParl,@IsShutdown)
      {
         Send(self,@MsgSendUser,#message_rsc=player_intrigue_shut);
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=False);
         Send(oParl,@UpdateEffects,#who=self);
         if ptFactionTimer<>$
         {
            DeleteTimer(ptFactionTimer);
            ptFactionTimer=$;
         }

         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused,#what=self);

               break;
            }
         }
         return FALSE;
      }

      if Send(oParl,@IsShutdown)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
         AND (Send(self,@PlayerIsHPIntrigue)
              OR Send(self,@PlayerIsAdept))
      {
         bIntrigue = PFLAG_INTRIGUING;
      }

      if wasint <> bIntrigue
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=bIntrigue);
      }

      if NOT wasint AND bIntrigue
      {
         if piFactionEffect <> 0
         {
            Debug("NonIntriguing Player",Send(self,@GetName),"had effects "
                  "set:",piFactionEffect);
            piFactionEffect=0;
         }

         piFaction = FACTION_NEUTRAL;
         Send(oParl,@UpdateEffects,#who=self);
         Send(oParl,@MovetoFaction,#who=self,#faction=FACTION_NEUTRAL);
         Send(self,@ReceiveNestedMail,#from=intrigue_ambassador,
              #dest_list=[self],#nest_list=[4,player_intrigue_mail]);
      }

      if wasint AND NOT bIntrigue
      {
         Send(self,@MsgSendUser,#message_rsc=player_lost_intriguing);
         Send(self,@ResignFaction);
         Send(oParl,@MovetoFaction,#who=self,#faction=(-1));
         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused);

               break;
            }
         }
      }

      return bIntrigue;
   }

   JoinFaction(new_faction=FACTION_NEUTRAL)
   "Returns true if the joining was a success"
   {
      local factliege, oParliament, oQuestEngine;

      if NOT Send(Self,@PlayerIsIntriguing)
      {
         return FALSE;
      }

      if new_faction <= FACTION_NEUTRAL
         OR new_faction > FACTION_NORMAL_MAX
      {
         return FALSE;
      }

      if piFaction <> FACTION_NEUTRAL
      {
         return FALSE;
      }

      piFaction = new_faction;
      % Increase the max number of loyalty quests by one, and schedule one.
      oQuestEngine = Send(SYS,@GetQuestEngine);
      
      if piFaction = FACTION_PRINCESS
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_PRINCESS_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_PRINCESS_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_DUKE_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_DUKE_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_DUKE_SERVICE,#override=TRUE);
      }

      if piFaction = FACTION_REBEL
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_REBEL_SERVICE,
               #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                      #index=QST_ID_REBEL_SERVICE),
                                      QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_REBEL_SERVICE,#override=TRUE);
         Post(self,@DrawOffense);
      }

      piFactionTimeUpdated = GetTime();
      piFactionServiceUpdate = 0;
      oParliament = Send(SYS,@GetParliament);

      if piFaction <> FACTION_NEUTRAL
      {
         factliege = Send(oParliament,@GetLiege,#faction=piFaction);
      }

      ptFactionTimer = $;
      Send(Self,@FactionServiceTimer);
      Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
      Send(oParliament,@UpdateEffects,#who=self);
      Send(self,@MsgSendUser,#message_rsc=player_join_faction,
            #parm1=Send(factliege,@GetDef),#parm2=Send(factliege,@GetName));

      return TRUE;
   }

   ResignLoyaltyFailed()
   {
      % Don't boot the player unless they've been factioned longer
      % than 5400 seconds (90 minutes)

      if piFactionServiceUpdate < 5400
      {
         return;
      }

      Send(self,@ResignFaction);

      return;
   }

   ResignFaction(bNoTimer=FALSE)
   {
      local numMembers, oParliament, oQuestEngine, oQuest, oFlagPole;

      if poOwner <> $
      {
         oFlagPole = Send(poOwner,@FindHoldingActive,#Class=&Flagpole);
         if oFlagPole <> $ AND Send(oFlagPole,@IsClaimAttemptInProgress)
         {
            if Send(oFlagPole,@GetClaimer) = self
            {
               Send(oFlagPole,@ClaimFailed);
            }
         }
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      if (oQuestEngine = $)
      {
         return;
      }

      if Send(Self,@PlayerIsIntriguing)
         AND piFaction <> FACTION_NEUTRAL
      {
         Send(self,@MsgSendUser,#message_rsc=player_unfactioned);
      }

      % Decrease the max number of loyalty quests by one
      if piFaction = FACTION_PRINCESS
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_PRINCESS_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,
                 #index=QST_ID_PRINCESS_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Princess faction members!");
         }
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_DUKE_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);

         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_DUKE_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Duke faction members!");
         }
      }

      if piFaction = FACTION_REBEL
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_REBEL_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_REBEL_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Rebel faction members!");
         }
         Post(self,@DrawOffense);
      }

      Send(self,@ResetFaction,#faction=FACTION_NEUTRAL);

      if NOT bNoTimer
         AND ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
      }

      ptFactionTimer=$;
      piFactionTimeUpdated = 0;
      piFactionServiceUpdate = 0;

      oParliament = Send(SYS,@GetParliament);
      if oParliament <> $
      {
         if Send(self,@PlayerIsIntriguing)
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
         }
         else
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=(-1));
         }

         Send(oParliament,@UpdateEffects,#who=self);
      }

      return;
   }

   PlayerIsHPIntrigue()
   "If player has over 40hp base."
   {
      return (piBase_Max_health >= Send(SETTINGS_OBJECT,@GetIntrigueEnableHP));
   }

   PlayerIsAdept()
   "If player has 5th level spell over the enabling percent, then true"
   {
      local i, sid, oSpell;

      foreach i in plSpells
      {
         sid = abs(i/100);
         oSpell = Send(SYS,@FindSpellByNum,#num=sid);
         if IsClass(oSpell,&Spell) AND Send(oSpell,@GetLevel) = 5
            AND (i mod 100) >= INTRIGUE_ENABLE_SPELL
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   CheckTokenInNewRoom(what=$)
   "If we are carrying a token, lets drop it."
   {
      local i, bFound;

      if what = $
         OR poOwner = $
         OR Send(poOwner,@CanTokenEnterRoom)
      {
         return;
      }

      bFound = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Token)
         {
            bFound = TRUE;
            Send(i,@NewUnused,#where=what);
         }
      }

      if bFound
      {
         % Give a different message depending on the room.
         if IsClass(poOwner,&GuildHall)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_hall);

            return;
         }

         if Send(poOwner,@IsArena)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_arena);

            return;
         }

         if IsClass(poOwner,&SurvivalRoom)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_survival);

            return;
         }

         Send(self,@MsgSendUser,#message_rsc=player_lost_token_generic);
      }

      return;
   }

   GetFactionService()
   {
      return piFactionServiceUpdate;
   }

   GetFactionEffect()
   {
      return piFactionEffect;
   }

   SetFactionEffect(effect=0)
   {
      piFactionEffect = effect;

      return;
   }

   TokenDeliveryReward(mob=$)
   {
      local tobj,classes;

      classes = Send(Send(SYS,@GetLibrary),@GetQuestRewardList);
      if classes = $
      {
         return;
      }

      if IsClass(mob,&Council)
         OR (IsClass(mob,&Factions) AND Send(mob,@GetFaction) = piFaction)
         OR (IsClass(mob,&ShalillePriestess) AND piFaction = FACTION_NEUTRAL)
      {
         tobj = Create(Nth(classes,Random(1,Length(classes))));
         if Send(self,@ReqNewHold,#what=tobj)
         {
            Send(self,@NewHold,#what=tobj);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
         else
         {
            Send(poOwner,@NewHold,#what=tobj,#new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward_heavy,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
      }

      return;
   }

   GetInstrumentLevel()
   "Returns the power of the instrument we are holding."
   {
      local i, iPower;

      iPower = 0;

      % Search through for the instrument of the highest power.
      %  We could have a necklace and a lute.  Let the lute contribute
      %  its power, rather than the necklace.
      foreach i in plUsing
      {
         if IsClass(i,&Instrument)
         {
            iPower = iPower + Send(i,@GetInstrumentLevel);
         }
      }

      return iPower;
   }

   ZeroMods()
   "Should NOT be called before removing all potential stat-modifying things"
   {
      piMightMod = 0;
      piIntellectMod = 0;
      piMysticismMod = 0;
      piAgilityMod = 0;
      piStaminaMod = 0;
      piAimMod = 0;

      return;
   }

   CheckLog()
   {
      return (piFlags & PFLAG_LOG);
   }

   DecayPKillCount()
   {
      % 50% chance to reduce the kill count.  This is to eliminate
      % the people who attempt to exploit this system for gain.
      if Random(1,100) > 50
      {
         piKill_count_decay = piKill_count_decay - 1;
         piKill_count_decay = Bound(piKill_count_decay,0,$);
      }

      return;
   }

   GetUnjustifiedKills()
   {
      return piKill_count;
   }

   GetDecayedUnjustifiedKills()
   {
      return piKill_count_decay;
   }

   GetJustifiedKills()
   {
      return piJustified_kill_count;
   }

   UserReqNewOwner(RID=0)
   {
      local oRoom;

      if RID = 0
      {
         return;
      }

      oRoom = Send(SYS,@FindRoomByNum,#num=RID);
      if oRoom = $
      {
         Debug("Got an invalid room!");
         return FALSE;
      }

      if IsClass(oRoom,&GuildHall)
         AND NOT IsClass(oRoom,&WaylayOasis)
         AND NOT IsClass(oRoom,&GuildHall15)
         AND NOT IsClass(oRoom,&AncientZiggurat)
         AND Send(self,@GetLadderID) <> 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_enter_ladder);

         return FALSE;
      }

      if IsClass(oRoom,&GuildHall)
         AND (NOT (piFlags & PFLAG_PKILL_ENABLE))
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_enter);

         return FALSE;
      }

      Send(self,@BreakTrance,#event=EVENT_REQNEWOWNER);

      return TRUE;
   }

   GivePlayerAllSpells(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
                              (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;
               
               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSpells)
      {
         if NOT IsClass(i,&Spell)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSpell,#num=Send(i,@GetSpellNum),
                     #iability=iAbility,#dontSend=TRUE);
            }
         }
      }

      % Set Karma enough for them to cast their highest level spell.
      if school = SS_SHALILLE
      {
         % Need 10 Karma per spell level (+10 for fudge).
         piKarma = level * 1000;
      }

      if school = SS_QOR
      {
         % Need -10 Karma per spell level (-10 for fudge).
         piKarma = level * -1000;
      }
      Send(self,@ToCliSpells);
      Send(self,@DrawKarma);

      return TRUE;
   }

   GivePlayerAllSkills(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
            (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;

               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSkills)
      {
         if NOT IsClass(i,&Skill)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSkill,#num=Send(i,@GetSkillNum),
                     #iability=iAbility,#dontSend=TRUE);
            }
         }
      }

      Send(self,@ToCliSkills);

      return TRUE;
   }

   GetSchoolLevels(include_cant_forget=FALSE)
   {
      local i, iLevel, iCanForget, iSchool, oSpell, oSkill,
            iShal, iQor, iKraan, iFaren, iRiija, iJala,
            iWC, iKC, iBA, iSO, iWI, iAlch, iBesti, iShad;
      
      iShal = 0;
      iQor = 0;
      iKraan = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iWC = 0;
      iKC = 0;
      iBA = 0;
      iSO = 0;
      iWI = 0;
      iAlch = 0;
      iBesti = 0;
      iShad = 0;

      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=i));

         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iCanForget) OR (NOT iCanForget AND include_cant_forget)
         {
            switch(iSchool)
            {
               case SS_SHALILLE:
                  if iLevel > iShal
                  {
                     iShal = iLevel;
                  }
                  break;
               case SS_QOR:
                  if iLevel > iQor
                  {
                     iQor = iLevel;
                  }
                  break;
               case SS_KRAANAN:
                  if iLevel > iKraan
                  {
                     iKraan = iLevel;
                  }
                  break;
               case SS_FAREN:
                  if iLevel > iFaren
                  {
                     iFaren = iLevel;
                  }
                  break;
               case SS_RIIJA:
                  if iLevel > iRiija
                  {
                     iRiija = iLevel;
                  }
                  break;
               case SS_JALA:
                  if iLevel > iJala
                  {
                     iJala = iLevel;
                  }
                  break;
               case SKS_FENCING:
                  if iLevel > iWC
                  {
                     iWC = iLevel;
                  }
                  break;
               case SKS_KNIGHTCRAFT:
                  if iLevel > iKC
                  {
                     iKC = iLevel;
                  }
                  break;
               case SKS_BANDITRY:
                  if iLevel > iBA
                  {
                     iBA = iLevel;
                  }
                  break;
               case SKS_SORCERY:
                  if iLevel > iSO
                  {
                     iSO = iLevel;
                  }
                  break;
               case SS_WITCHERY:
                  if iLevel > iWI
                  {
                     iWI = iLevel;
                  }
                  break;
               case SKS_ALCHEMY:
                  if iLevel > iAlch
                  {
                     iAlch = iLevel;
                  }
                  break;
               case SS_BESTIARY:
                  if iLevel > iBesti
                  {
                     iBesti = iLevel;
                  }
                  break;
               case SKS_SHADOWCRAFT:
                  if iLevel > iShad
                  {
                     iShad = iLevel;
                  }
                  break;
            }
         }
      }

      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));

         iLevel = Send(oSkill,@GetLevel);
         iCanForget = Send(oSkill,@CanForget);
         iSchool = Send(oSkill,@GetSchool);

         if (iCanForget) OR (NOT iCanForget AND include_cant_forget)
         {
            switch(iSchool)
            {
               case SS_SHALILLE:
                  if iLevel > iShal
                  {
                     iShal = iLevel;
                  }
                  break;
               case SS_QOR:
                  if iLevel > iQor
                  {
                     iQor = iLevel;
                  }
                  break;
               case SS_KRAANAN:
                  if iLevel > iKraan
                  {
                     iKraan = iLevel;
                  }
                  break;
               case SS_FAREN:
                  if iLevel > iFaren
                  {
                     iFaren = iLevel;
                  }
                  break;
               case SS_RIIJA:
                  if iLevel > iRiija
                  {
                     iRiija = iLevel;
                  }
                  break;
               case SS_JALA:
                  if iLevel > iJala
                  {
                     iJala = iLevel;
                  }
                  break;
               case SKS_FENCING:
                  if iLevel > iWC
                  {
                     iWC = iLevel;
                  }
                  break;
               case SKS_KNIGHTCRAFT:
                  if iLevel > iKC
                  {
                     iKC = iLevel;
                  }
                  break;
               case SKS_BANDITRY:
                  if iLevel > iBA
                  {
                     iBA = iLevel;
                  }
                  break;
               case SKS_SORCERY:
                  if iLevel > iSO
                  {
                     iSO = iLevel;
                  }
                  break;
               case SS_WITCHERY:
                  if iLevel > iWI
                  {
                     iWI = iLevel;
                  }
                  break;
               case SKS_ALCHEMY:
                  if iLevel > iAlch
                  {
                     iAlch = iLevel;
                  }
                  break;
               case SS_BESTIARY:
                  if iLevel > iBesti
                  {
                     iBesti = iLevel;
                  }
                  break;
               case SKS_SHADOWCRAFT:
                  if iLevel > iShad
                  {
                     iShad = iLevel;
                  }
                  break;
            }
         }
      }

      return [iShal, iQor, iKraan, iFaren, iRiija, iJala, iWC, iKC, iBA, iSO, iWI, iAlch, iBesti, iShad];
   }

   % Designed this just like GetSpellSchoolLevels in case a skill school
   % is added later and this needs to be extended.
   GetSkillSchoolLevels(include_cant_forget=FALSE)
   {
      local i, lSchoolLevels, oSkill, iLevel, iWeaponCraftLevel, iCanForget, iSchool,
            iKnightcraftLevel, iBanditryLevel, iSorceryLevel, iWitcheryLevel, iAlchemyLevel,
            iShadowcraftLevel, iBestiaryLevel;

      iWeaponCraftLevel = 0;
      iKnightcraftLevel = 0;
      iBanditryLevel = 0;
      iSorceryLevel = 0;
      iWitcheryLevel = 0;
      iAlchemyLevel = 0;
      iShadowcraftLevel = 0;
      iBestiaryLevel = 0;
      iLevel = 0;
      iCanForget = TRUE;

      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                      #compound=i));
         iLevel = Send(oSkill,@GetLevel);
         iCanForget = Send(oSkill,@CanForget);
         iSchool = Send(oSkill,@GetSchool);
         
         if iCanForget OR (NOT iCanForget AND include_cant_forget)
         {
            if iSchool = SKS_FENCING
            {
               if iLevel > iWeaponCraftLevel
               {
                  iWeaponCraftLevel = iLevel;
               }
            }
            if iSchool = SKS_KNIGHTCRAFT
            {
               if iLevel > iKnightcraftLevel
               {
                  iKnightcraftLevel = iLevel;
               }
            }
            if iSchool = SKS_BANDITRY
            {
               if iLevel > iBanditryLevel
               {
                  iBanditryLevel = iLevel;
               }
            }
            if iSchool = SKS_SORCERY
            {
               if iLevel > iSorceryLevel
               {
                  iSorceryLevel = iLevel;
               }
            }
            if iSchool = SS_WITCHERY
            {
               if iLevel > iWitcheryLevel
               {
                  iWitcheryLevel = iLevel;
               }
            }
            if iSchool = SKS_ALCHEMY
            {
               if iLevel > iAlchemyLevel
               {
                  iAlchemyLevel = iLevel;
               }
            }
            if iSchool = SKS_SHADOWCRAFT
            {
               if iLevel > iShadowcraftLevel
               {
                  iShadowcraftLevel = iLevel;
               }
            }
            if iSchool = SS_BESTIARY
            {
               if iLevel > iBestiaryLevel
               {
                  iBestiaryLevel = iLevel;
               }
            }
         }

      }

      lSchoolLevels = [iWeaponCraftLevel,iKnightcraftLevel,iBanditryLevel,iSorceryLevel,iWitcheryLevel,iAlchemyLevel];

      return lSchoolLevels;
   }

   GetSpellSchoolLevels(include_cant_forget=FALSE)
   {
      local i, lSchoolLevels, oSpell, iSchool, iLevel, iCanForget,
            shalille_level, qor_level, kraanan_level, faren_level,
            riija_level, jala_level;

      shalille_level = 0;
      qor_level = 0;
      kraanan_level = 0;
      faren_level = 0;
      riija_level = 0;
      jala_level = 0;
      iCanForget = TRUE;

      % Get max level in each school. Yes, this is ugly but I'm trying for
      % the least number of comparisons possible per spell. Schools in order
      % of popularity, your results may vary. 10/25/2014 103 stats: 578 kran,
      % 228 faren, 284 shal, 160 riija, 216 qor, 151 jala
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                      #compound=i));
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iCanForget) OR (NOT iCanForget AND include_cant_forget)
         {
            if (iSchool = SS_KRAANAN)
            {
               if (iLevel > kraanan_level)
               {
                  kraanan_level = iLevel;
               }
            }
            else if (iSchool = SS_SHALILLE)
            {
               if (iLevel > shalille_level)
               {
                  shalille_level = iLevel;
               }
            }
            else if (iSchool = SS_QOR)
            {
               if (iLevel > qor_level)
               {
                  qor_level = iLevel;
               }
            }
            else if (iSchool = SS_FAREN)
            {
               if (iLevel > faren_level)
               {
                  faren_level = iLevel;
               }
            }
            else if (iSchool = SS_RIIJA)
            {
               if (iLevel > riija_level)
               {
                  riija_level = iLevel;
               }
            }
            else if (iSchool = SS_JALA)
            {
               if (iLevel > jala_level)
               {
                  jala_level = iLevel;
               }
            }
         }
      }

      % Order matters here, they appear in the order listed in blakston.khd.
      lSchoolLevels = [shalille_level,qor_level,kraanan_level,
                       faren_level,riija_level,jala_level];

      return lSchoolLevels;
   }

   StripSpellsOfSchool(school = 0, All = FALSE)
   {
      local i, j, k;

      if (ALL)
      {
         j = 1;
         while (j < NUM_SCHOOLS)
         {
            k = 1;
            while (k < NUM_SPELL_LEVELS)
            {
               Send(self, @StripSpellsOfSchoolByLevel, #school=j, #level=k);
               ++k;
            }
            ++j;
         }
      }
      else
      {
         k=1;
         while (k < NUM_SPELL_LEVELS)
         {
            Send(self, @StripSpellsOfSchoolByLevel, #school=school, #level=k);
            ++k;
         }
      }

      return;
   }

   StripSpellsAndSkillsOfSchoolByLevel(school_index = 0, level = 0)
   {
      local i, oSpell, oSkill, iSchool, iLevel, iCanForget, iSpellNum, lSchools, iStripSchool;
      
      % For these purposes, we are looking at a specific array of the 12 schools.
      lSchools = [SS_SHALILLE,
                  SS_QOR,
                  SS_KRAANAN,
                  SS_FAREN,
                  SS_RIIJA,
                  SS_JALA,
                  SKS_FENCING,
                  SKS_KNIGHTCRAFT,
                  SKS_BANDITRY,
                  SKS_SORCERY,
                  SS_WITCHERY,
                  SKS_ALCHEMY];
      iStripSchool = Nth(lSchools,school_index);
      
      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iSchool = iStripSchool) AND (iLevel = level) AND iCanForget
         {
            Send(self,@RemoveSpell,#num=iSpellNum);
         }
      }
      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oSkill,@GetSchool);
         iLevel = Send(oSkill,@GetLevel);
         
         if (iSchool = iStripSchool) AND (iLevel = level)
         {
            Send(self,@RemoveSkill,#num=Send(self,@DecodeSkillNum,#compound=i));
         }
      }
      return;
   }

   StripSpellsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSpell, iSchool, iLevel, iCanForget, iSpellNum;
   
      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iSchool = school) AND (iLevel = level) AND iCanForget
         {
            Send(self,@RemoveSpell,#num=iSpellNum);
         }
      }
      return;
   }

   StripSkillsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSkill, iSchool, iLevel;
      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oSkill,@GetSchool);
         iLevel = Send(oSkill,@GetLevel);
         
         if (iSchool = school) AND (iLevel = level)
         {
            Send(self,@RemoveSkill,#num=Send(self,@DecodeSkillNum,#compound=i));
         }
      }
      return;
   }
   
   IsWizard()
   {
      if Length(plSpells) > 50
      {
         return TRUE;
      }

      return FALSE;
   }

   ClearSpellList()
   {
      plSpells = $;
      return;
   }

   GetMaster()
   {
      return $;
   }

   IsInvisible()
   {
      return (piFlags & PFLAG_INVISIBLE);
   }

   IsShadowForm()
   {
      return (piDrawFX & DRAWFX_BLACK);
   }

   IsPetrified()
   {
      return (piDrawfX & DRAWFX_SECONDTRANS);
   }

   IsMorphed()
   {
      return (piFlags & PFLAG_MORPHED);
   }

   %%% Get Color Routines

   GetSkinColor()
   {
      return (piBody_translations & PLAYER_TRANSLATION_Skin_MASK)
                  /PLAYER_TRANSLATION_Skin_MUL;
   }

   GetHairColor()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_HAIR_MASK)
                  /PLAYER_TRANSLATION2_HAIR_MUL;
   }

   GetLegsTranslation()
   {
      % This returns the whole translation, including skin color.
      return (piBody_translations & PLAYER_TRANSLATION_LEGS_MASK)
                  /PLAYER_TRANSLATION_LEGS_MUL;
   }

   GetArmsTranslation()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_ARMS_MASK)
                  /PLAYER_TRANSLATION2_ARMS_MUL;
   }

   GetBodyTranslation()
   {
      % This returns the armor/shirt torso (not arms) color.  note that skin is
      %  included in this, in the case of a low-cut dress, for example.
      return (piBody_translations & PLAYER_TRANSLATION_BODY_MASK)
               /PLAYER_TRANSLATION_BODY_MUL;
   }

   GetDefaultShirtTranslation()
   "This includes skin tones - important for the arms."
   {
      return ((piDefault_Clothes & SHIRT_MASK) / SHIRT_MUL);
   }

   GetDefaultShirtColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultShirtTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   GetCurrentShirtColor()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&shirt)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return Send(self,@GetDefaultShirtTranslation);
   }

   GetDefaultPantsTranslation()
   "This includes skin tones."
   {
      return (((piDefault_Clothes & PANTS_MASK) / PANTS_MUL));
   }

   GetDefaultPantsColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultPantsTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   SetSkinColor(color = 1)
   {
      local iColor, i;

      % Arms (hands) and face are the only default things that need to
      % have skin colors associated with it.  Other items in use
      % may need to, though (low cut dress).

      Send(self,@SetSkinTranslation,#translation=color);
      iColor = Send(self,@GetDefaultShirtColor);
      Send(self,@SetDefaultClothes,#shirt_color = iColor);
      foreach i in plUsing
      {
         Send(i,@DoPlayerArt);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   GetTattooed()
   {
      return pbTattooed;
   }

   VerifySorceryAndTattooed()
   "Implemented to check all existing players for sorcery skills and set them to tattooed."
   {
      local i, oAbility;
      
      foreach i in plSkills
      {
         oAbility = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         if Send(oAbility,@GetSchool) = SKS_SORCERY
         {
            Send(self,@SetTattooed,#value=TRUE);
            return;
         }
      }
      return;
   }

   CheckTattooed()
   "Call this function when Sorcery skills are bought or lost, or when reserving spells."
   {
      % Shrunken head takes over the player's head and will call SetHead when removed
      if Send(self,@FindUsing,#class=&ShrunkenHeadMask) = $
         AND piPlayerRace <> RACE_DRACONIAN
      {
         if piGender = GENDER_MALE
         {
            Send(self,@SetHead,#head=charinfo_head_ax_icon);
         }
         else
         {
            Send(self,@SetHead,#head=charinfo_head_kx_icon);
         }
         if poOwner <> $
         {
            Send(poOwner,@SomethingChanged,#what=self);
         }
      }
      
      return;
   }

   SetTattooed(value=FALSE)
   "Call this function when Sorcery skills are bought or lost, or when reserving spells."
   {
      pbTattooed = value;

      % Shrunken head takes over the player's head and will call SetHead when removed
      if Send(self,@FindUsing,#class=&ShrunkenHeadMask) = $
         AND piPlayerRace <> RACE_DRACONIAN
      {
         if piGender = GENDER_MALE
         {
            Send(self,@SetHead,#head=charinfo_head_ax_icon);
         }
         else
         {
            Send(self,@SetHead,#head=charinfo_head_kx_icon);
         }
         if poOwner <> $
         {
            Send(poOwner,@SomethingChanged,#what=self);
         }
      }
      
      return;
   }

   SetHead(head=$)
   {
      local iReservedPercent;

      if head = $
      {
         return;
      }

      if (head = charinfo_head_ax_icon
          OR head = charinfo_head_kx_icon)
         AND Send(self,@GetTattooed)
         AND piPlayerRace <> RACE_DRACONIAN
      {
         if piGender = GENDER_MALE
         {
            iReservedPercent = Send(self,@GetPercentReservedManaTotal);
            
            if iReservedPercent = 0
            {
               prHead = charinfo_head_axt6_icon;
            }
            else if iReservedPercent < 25
            {
               prHead = charinfo_head_axt5_icon;
            }
            else if iReservedPercent < 50
            {
               prHead = charinfo_head_axt4_icon;
            }
            else if iReservedPercent < 75
            {
               prHead = charinfo_head_axt3_icon;
            }
            else if iReservedPercent < 100
            {
               prHead = charinfo_head_axt2_icon;
            }
            else
            {
               prHead = charinfo_head_axt1_icon;
            }
            return;
         }
         else
         {
            iReservedPercent = Send(self,@GetPercentReservedManaTotal);
            
            if iReservedPercent = 0
            {
               prHead = charinfo_head_kxt6_icon;
            }
            else if iReservedPercent < 25
            {
               prHead = charinfo_head_kxt5_icon;
            }
            else if iReservedPercent < 50
            {
               prHead = charinfo_head_kxt4_icon;
            }
            else if iReservedPercent < 75
            {
               prHead = charinfo_head_kxt3_icon;
            }
            else if iReservedPercent < 100
            {
               prHead = charinfo_head_kxt2_icon;
            }
            else
            {
               prHead = charinfo_head_kxt1_icon;
            }
            return;
         }
      }

      prHead = head;

      return;
   }

   SetEyes(eyes=$)
   {
      if eyes = $
      {
         return;
      }

      prEyes = eyes;

      return;
   }

   SetNose(Nose=$)
   {
      if Nose = $
      {
         return;
      }

      prNose = Nose;

      return;
   }

   SetMouth(Mouth=$)
   {
      if Mouth = $
      {
         return;
      }

      prMouth = Mouth;

      return;
   }

   GetHeadRsc()
   {
      return prHead;
   }

   GetEyesRsc()
   {
      return prEyes;
   }

   GetMouthRsc()
   {
      return prMouth;
   }

   GetNoseRsc()
   {
      return prNose;
   }

   GetHairRsc()
   {
      return prToupee;
   }

   GetLeftArmRsc()
   {
      return prLeft_arm;
   }

   GetRightArmRsc()
   {
      return prRight_arm;
   }

   GetLegsRsc()
   {
      return prLegs;
   }

   GetExpression()
   {
      return piAction;
   }

   GetShieldRsc()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlay);
         }
      }

      return $;
   }

   GetShieldOverlayHotspot()
   {
      local i;
      
      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlayHotspot);
         }
      }

      return $;
   }

   GetShieldTranslation()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&GuildShield)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return 0;
   }

   IsLoggedOn()
   {
      return pbLogged_on;
   }

   ClearQuestHistory()
   "Stubbed here, since variable is defined in user - DOH!"
   "(real function is also in user.kod)"
   {
      return;
   }

   ResetMonsterChasers()
   {
      if Send(self,@IsEnchanted,#byClass=&SoothingPresence)
      {
         Send(self,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_SOOTHING_PRESENCE));
      }

      if Send(self,@IsEnchanted,#byClass=&ToweringPresence)
      {
         Send(self,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_TOWERING_PRESENCE));
      }

      piMonsterChasers = 0;

      return;
   }

   AddToMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers + level;

      return;
   }

   SubtractFromMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers - level;

      return;
   }

   GetMonsterChasers()
   {
      return piMonsterChasers;
   }

   SomeoneSaid(what=$,type=$,string=$,parm1=$,parm2=$,
               parm3=$,parm4=$,parm5=$,parm6=$,parm7=$,parm8=$)
   {
      local oSnoop;

      if type = SAY_NORMAL AND IsClass(what,&Player)
      {
         % si: removed (and what <> self) to allow communication
         % between shrunken head and owner.
         oSnoop = Send(self,@FindHolding,#class=&ShrunkenHead);
         if oSnoop <> $
         {
            Send(oSnoop,@SomeoneOverheard,#from=what,#to=self,#string=string);
         }
      }

      propagate;
   }

   SomeoneOverheard(from=$,to=$,type=$,string=$)
   {
      return;
   }

   RemoveInaccessibleSpells()
   {
      local num, i, oSpell, iability;

      foreach i in plSpells
      {
         num = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=num);
         if NOT Send(oSpell,@IsAccessible)
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            Send(self,@RemoveSpell,#num=num);
         }
      }

      Send(self,@ToCliStats,#group=3);
      Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      return;
   }

   ResetPlayerView()
   {
      if Send(self,@GetSession) <> $
      {
         AddPacket(1,BP_RESET_VIEW);
         SendPacket(poSession);
      }

      return;
   }

   SetPlayerView(what = $, iFlags = 0, iHeight = 0, iLight = 0)
   {
      if Send(self,@GetSession) = $
      {
         return;
      }

      if what = $
      {
         Send(self,@ResetPlayerView);
      }
      else
      {
         AddPacket(1,BP_SET_VIEW, 4,what, 4,iFlags, 4,iHeight, 1,iLight);

         SendPacket(poSession);
      }

      return;
   }

   % Removes the shirt.  Used by the WarEvent event.
   RemoveShirt()
   {
      local i;
      
      foreach i in plUsing
      {
         if IsClass(i,&Shirt)
            OR IsClass(i,&LightRobe)
            OR IsClass(i,&Robe)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   BondItem(what=$)
   {
      if what = $ OR NOT IsClass(what,&Item)
      {
         Debug("Tried to bond to invalid item.");
      }

      if Send(what,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         %  this should only be possible through Admin fiddling
         return Send(SYS,@GetFailureRsc);
      }

      if poBondedItem <> $
      {
         Send(self,@ClearBondedItem);
      }

      poBondedItem = what;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@AddtoItem,
           #oItem=poBondedItem,#oPlayer=self);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      return;
   }

   ClearBondedItem()
   {
      local oldBondedItem;

      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      if poBondedItem = $
      {
         return;
      }

      oldBondedItem = poBondedItem;
      poBondedItem = $;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@RemoveFromItem,
            #oItem=oldBondedItem);

      return;
   }

   BondedItemReport()
   {
      ptBondedItemReport = $;
      if poBondedItem = $
      {
         Debug("trying to report location with no bonded item!");

         return;
      }
      
      if NOT Send(self,@IsLoggedOn)
      {
         % Don't run bonded item reports on logged off users.
         return;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),
           @BondedItemReport,#BondedItem=poBondedItem,#BondedPlayer=self);

      return;
   }

   IsUndead()
   {
      return Send(self,@IsUsingA,#class=&NecromancerAmulet);
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing "
   "server time."
   {
      local time;

      % Reset our attack timer, a traditional use of this function when attack
      %  time was a timestamp instead of a timer.

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      time = GetTime();

      piLastDeathTime = time;
      piGuildRejoinTimestamp = time;
      piLast_restart_time = time;
      piTimeLastStomachUpdate = time;
      piTimeAttackedPlayer = time;

      return;
   }

   ClearAttackTimer()
   {
      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }
      return;
   }

   UpdateJewelsOfFroz()
   {
      local i, bFound;

      foreach i in plUsing
      {
         if IsClass(i,&JewelOfFroz)
         {
            bFound = TRUE;
         }
      }

      if bFound
      {
         Send(self,@SendLightingInformation);
      }
      return;
   }

   SendLightingInformation()
   {
      local i, oLightObject, iColor, iIntensity, bOverride, iOverrideLightColor;

      if poIllusion_set <> $
      {
         if NOT Send(poIllusion_set,@IllusionGetLightingInformation,#who=self)
         {
            % No lighting information
            propagate;
         }

         return;
      }

      bOverride = FALSE;
      iOverrideLightColor = LIGHT_WHITE;
      if poOwner <> $
      {
         bOverride = Send(poOwner,@LightingColorOverride);
         iOverrideLightColor = Send(poOwner,@GetLightingColorOverride,#what=self);
      }

      % Petrified gives off no light
      if Send(self,@IsEnchanted,#byClass=&Petrified)
      {
         if bOverride
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,0, 2,iOverrideLightColor);
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,0, 2,LIGHT_WHITE);
         }
         return;
      }
      % Hold gives off a purple glow
      if Send(self,@IsEnchanted,#byClass=&Hold)
      {
         if bOverride
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,iOverrideLightColor);
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,LIGHT_BPURPLE);
         }
         return;
      }
      % Blind gives off a dim green glow
      if Send(self,@IsEnchanted,#byClass=&Blind)
      {
         if bOverride
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,iOverrideLightColor);
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,50, 2,LIGHT_BGREEN);
         }
         return;
      }
      % Dazzle is blazing white
      if Send(self,@IsEnchanted,#byClass=&Dazzle)
      {
         if bOverride
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,100, 2,iOverrideLightColor);
         }
         else
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),1,255, 2,LIGHT_WHITE);
         }
         return;
      }

      % Bitflag check, don't need to check anything if not set.
      if NOT (piDrawEffectFlag & OF_FLICKERING)
      {
         propagate;
      }

      iIntensity = 0;
      iColor = 0;
      % Check each lighting effect, strongest one wins.
      % TODO: these should be additive, and the client should produce
      % a combined lighting effect. Also, if more lighting effects are added
      % this should probably query everything, just in case.

      foreach i in plUsing
      {
         if IsClass(i,&MithrilShield)
         {
            iIntensity = iIntensity + Send(i,@GetLightIntensity);
            iColor = Send(i,@GetLightColor);
         }
      }

      % Check torches and glow enchantment only here, hardcoded color/intensity.
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
            OR (IsClass(i,&Weapon)
               AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            iIntensity = iIntensity + 120;
            iColor = LIGHT_FIRE;
         }
      }

      % Check frozzes here
      foreach i in plUsing
      {
         if IsClass(i,&JewelOfFroz)
         {
            iIntensity = iIntensity + Send(i,@GetLightIntensity,#oWeapon=Send(self,@GetWeapon));
            iColor = Send(i,@GetLightColor,#oWeapon=Send(self,@GetWeapon));
         }
      }

      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
         {
            oLightObject = First(i);
            if Send(oLightObject,@GetOldAreaEnchStyle)
            {
               continue;
            }

            if Send(oLightObject,@GetLightIntensity) >= iIntensity
            {
                iIntensity = Send(oLightObject,@GetLightIntensity);
                iColor = Send(oLightObject,@GetLightColor);
            }
         }
      }

      if bOverride
      {
         iColor = iOverrideLightColor;
      }
      
      if poOwner <> $
         AND IsClass(poOwner,&ChaosStratumRoom)
      {
         iIntensity = Bound(iIntensity,180,$);
      }

      if iIntensity > 0
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),
                   1,iIntensity, 2,iColor);

         return;
      }

      propagate;
   }

   IsInSameRoom(what = $)
   "Determine if given object is in same room as we are."
   {
      local what_owner, found;

      if poOwner = $ OR what = $
      {
         return FALSE;
      }

      found = FALSE;
      what_owner = Send(what,@GetOwner);
      while what_owner <> $
      {
         if what_owner = poOwner
         {
            found = TRUE;
            break;
         }
         what_owner = Send(what_owner,@GetOwner);
      }

      return found;
   }

   AddDonationYear(year = $)
   "Add to the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      local y;

      % Already in the list?
      foreach y in plDonationYears
      {
         if y = year
         {
            return;
         }
      }

      plDonationYears = Cons(year, plDonationYears);

      return;
   }

   RemoveDonationYear(year = $)
   "Remove from the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      plDonationYears = DelListElem(plDonationYears, year);

      return;
   }

   SetLoadoutList(set_list = $)
   {
      plLoadout_list = set_list;

      return;
   }

   GetLoadoutList()
   {
      return plLoadout_list;
   }

   ClearBoundLocation()
   {
      piBound_Room = $;
      piBound_row = 0;
      piBound_col = 0;
      piBound_fine_row = 0;
      piBound_fine_col = 0;
      piBound_angle = 0;
      return;
   }

   BindPlayerToCurrentLocation()
   "Saves the player's current location as a special teleport destination."
   {
      if poOwner = $
      {
         return;
      }

      piBound_Room = Send(poOwner,@GetRoomNum);
      piBound_row = piRow;
      piBound_col = piCol;
      piBound_fine_row = piFine_row;
      piBound_fine_col = piFine_col;
      piBound_angle = Send(self,@GetAngle);

      return;
   }

   SendPlayerToBoundLocation()
   "Sends the player to their saved teleport destination."
   {
      if poOwner = $
         OR piBound_Room = $
         OR NOT pbLogged_on
      {
         return;
      }

      Send(SYS,@UtilGoNearSquare,#what=self,
            #where=Send(SYS,@FindRoomByNum,#num=piBound_room),
            #new_row=piBound_row,#new_col=piBound_col,
            #fine_row=piBound_fine_row,#fine_col=piBound_fine_col,
            #new_angle=piBound_angle, #max_distance=3);

      return;
   }

   GetBoundLocationName()
   {
      if piBound_room <> $
      {
         return Send(Send(SYS,@FindRoomByNum,#num=piBound_room),@GetName);
      }

      return $;
   }

   GetBoundLocationRoomNum()
   {
      return piBound_room;
   }

   GetBoundLocationRow()
   {
      return piBound_row;
   }

   GetBoundLocationCol()
   {
      return piBound_col;
   }

   SetDeathRiftProtection(value=FALSE)
   {
      if value
      {
         if poOwner <> $
            AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         {
            % Only allow Death Rift Protection for those already
            % logged on and in the Underworld
            piFlags = piflags | PFLAG_DEATH_RIFTING;

            return;
         }
      }
      else
      {
         if ptDeathRiftTimer <> $
         {
            DeleteTimer(ptDeathRiftTimer);
            ptDeathRiftTimer = $;
         }
         piFlags = piflags & ~PFLAG_DEATH_RIFTING;
      }

      return;
   }

   StartDeathRiftTimer()
   {
      ptDeathRiftTimer = CreateTimer(self,@DeathRiftBoot,DEATH_RIFT_INTERVAL);

      return;
   }

   DeathRiftBoot()
   "Players that linger too long will find themselves cast "
   "out of the Underworld."
   {
      ptDeathRiftTimer = $;

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         AND (piflags & PFLAG_DEATH_RIFTING)
      {
         Send(self,@AdminGoToSafety);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=death_rift_stayed_too_long);
         }
      }

      return;
   }

   LeaveBuilderGroupTimer()
   {
      ptLeaveBuilderGroupTimer = $;

      Send(self,@LeaveBuilderGroup);

      return;
   }

   LeaveBuilderGroup()
   {
      local i, each_obj;

      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = $;
      }

      if poOwner <> $
      {
         Send(poOwner,@RemoveFromBuilderGroup,#who=self);
         Send(poOwner,@SomethingChanged,#what=self);

         % Let's see that we left the group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChanged,#what=each_obj);
            }
         }
      }

      return;
   }

   JoinBuilderGroup()
   {
      local i, each_obj;

      % Refresh an active group membership
      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         return;
      }

      if poOwner <> $
      {
         Send(poOwner,@AddToBuilderGroup,#who=self);
         Send(poOwner,@SomethingChanged,#what=self);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         % Let's see our new group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChanged,#what=each_obj);
            }
         }
      }

      return;
   }

   IsCrystalizeManaSurging()
   {
      return piCrystalizeManaSurging;
   }

   StartCrystalizeManaSurge(surge_time=1000)
   {
      if ptCrystalizeManaSurgeTimer = $
      {
         ptCrystalizeManaSurgeTimer = CreateTimer(self,@EndCrystalizeManaSurgeTimer,surge_time);
         piCrystalizeManaSurging = TRUE;
         Send(self,@ComputeMaxMana);
      }

      return;
   }

   EndCrystalizeManaSurgeTimer()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@EndCrystalizeManaSurge);

      return;
   }

   EndCrystalizeManaSurge()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      piCrystalizeManaSurging = FALSE;
      Send(self,@ComputeMaxMana);

      return;
   }

   GetManaSurgeTimer()
   {
      return ptCrystalizeManaSurgeTimer;
   }

   RemoveAllHexes()
   {
      local i, bRemovedHexes;
      
      bRemovedHexes = FALSE;
      
      foreach i in plEnchantments
      {
         if isClass(Nth(i,2),&Hex)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2));
            bRemovedHexes = TRUE;
         }
      }
      
      if bRemovedHexes
      {
         Send(self,@MsgSendUser,#message_rsc=hexes_removed_by_safe_place_msg);
      }
      
      return;
   }

   RechargeAllRods()
   {
      local i, bGainedCharges;

      bGainedCharges = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Rod)
            AND Send(i,@FullyRecharge)
         {
            bGainedCharges = TRUE;
         }
      }

      if bGainedCharges
      {
         Send(self,@MsgSendUser,#message_rsc=rods_fully_recharged_by_safe_place_msg);
      }

      return;
   }

   % This section deals with minion code.
   CommandMinionAttack(oMaster=$,oTarget=$)
   {
      local oActive;

      % If we have minions, we only want them to attack Battlers,
      % not items or anything else that can damage us.
      if plControlledMinions = $
         OR oTarget = $
         OR NOT IsClass(oTarget,&Battler)
         OR IsClass(oTarget,&Revenant)
      {
         return;
      }
      
      % No attacking master.
      if oTarget = oMaster
         OR oTarget = self
      {
         return;
      }

      % Lets not have the minions kill each other. Check if the target is
      % a minion under our control.
      if IsClass(oTarget,&Monster)
         AND Send(oTarget,@GetMaster) = self
      {
         return;
      }
      
      if GetTime() <= piLastAutomaticCommandMinionAttackTime + 2
      {
         return;
      }

      if Send(self,@AllowPlayerAttack,#victim=oTarget)
      {
         piLastAutomaticCommandMinionAttackTime = GetTime();
         foreach oActive in plControlledMinions
         {
            if IsClass(oActive,&Monster)
               AND Send(oActive,@GetMaster) = self
               AND Send(oActive,@GetTarget) <> oTarget
               AND NOT (Send(oActive,@GetTarget) <> $
                        AND Send(Send(oActive,@GetTarget),@IsEnchanted,#byClass=&MarkofAggression)
                        AND NOT Send(oTarget,@IsEnchanted,#byClass=&MarkofAggression))
            {
               Send(oActive,@SetBehaviorFlag,
                     #flag=AI_MOVE_FOLLOW_MASTER,#value=FALSE);
               Send(oActive,@TargetSwitch,#what=oTarget,
                     #iHatred=100);
               Send(oActive,@EnterStateChase,#target=oTarget,
                     #actnow=TRUE);
            }
         }
      }

      return;
   }

   SumDamageReduction()
   {
      local iArmor, d, iCorrode, iCorrodeMultiple;

      iArmor = 0;

      foreach d in plDefense_modifiers
      {
         if IsClass(d,&DefenseModifier)
         {
            iArmor = iArmor + Send(d,@GetDamageReduction);
         }

         if IsClass(d,&ArmorOfGort)
         {
            iArmor = iArmor + (Send(self,@GetEnchantedState,#what=d) / 25);
         }
      }

      iCorrode = Send(self,@GetStatusEffect,#type=STATUS_CORRODE);
      if iCorrode > 0
      {
         iCorrodeMultiple = Send(SETTINGS_OBJECT,
                            @GetElementalMultiple,#type=STATUS_CORRODE);
         
         if iArmor > 0
         {
            iArmor = Bound(iArmor - (iCorrode/iCorrodeMultiple),0,$);
         }
      }

      return iArmor;
   }

   CanEvilTwin()
   {
      return TRUE;
   }

   GetReagentBag()
   {
      return GetListElemByClass(plPassive,&ReagentBag);
   }

   GetReagentBagContents()
   {
      local oBag;

      oBag = GetListElemByClass(plPassive,&ReagentBag);
      if oBag <> $
      {
         return Send(oBag,@GetReagentBagContents);
      }

      return $;
   }

   StartLoggedOnRefreshPhaseTime()
   {
      if ptLoggedOnRefreshPhaseTimer <> $
      {
         DeleteTimer(ptLoggedOnRefreshPhaseTimer);
         ptLoggedOnRefreshPhaseTimer = $;
      }
      
      if Send(self,@IsLoggedOn)
      {
         ptLoggedOnRefreshPhaseTimer = CreateTimer(self,@LoggedOnRefreshPhaseTime,60000 * 5);
      }
      
      return;
   }

   CancelLoggedOnRefreshPhaseTime()
   {
      if ptLoggedOnRefreshPhaseTimer <> $
      {
         DeleteTimer(ptLoggedOnRefreshPhaseTimer);
         ptLoggedOnRefreshPhaseTimer = $;
      }
      return;
   }

   LoggedOnRefreshPhaseTime(timer=$)
   {
      ptLoggedOnRefreshPhaseTimer = $;
      
      Send(self,@RefreshPhaseTimeToBase);
      
      return;
   }

   StartPhaseTimer()
   {
      local i;

      if ptPhaseTimer = $
      {
         ptPhaseTimer = CreateTimer(self,@PhaseTimerEnd,piRemainingPhaseTime);

         % Stop any rescue attempts if the user phases out.
         if ptRescue <> $
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_phase);
            DeleteTimer(ptRescue);
            ptRescue = $;
         }

         % If this player has created any evil twins, delete them.
         if plEvilTwins <> $
         {
            foreach i in plEvilTwins
            {
               Send(i,@Delete);
            }
            plEvilTwins = $;
         }
      }

      if ptPhaseVisualEffectTimer = $
      {
         ptPhaseVisualEffectTimer = CreateTimer(self,@PhaseVisualEffectTimer,2000);
      }

      % Add phase time to piTimeAttackedPlayer if it is currently
      % preventing the player from casting escape spells.
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 + (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }
   
   PhaseVisualEffectTimer(timer = $)
   {
      ptPhaseVisualEffectTimer = $;
      Send(self,@PhaseVisualEffect);

      return;
   }

   PhaseVisualEffect()
   {
      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }

      Send(Send(SYS,@FindSpellByNum,#num=SID_PHASE),
            @AdjustVisualEffectBasedOnTimeRemaining,#who=self);

      if ptPhaseVisualEffectTimer = $
         AND (piFlags & PFLAG_PHASED)
      {
         ptPhaseVisualEffectTimer = CreateTimer(self,@PhaseVisualEffectTimer,2000);
      }

      return;
   }

   FreezePhaseTimer()
   {
      if ptPhaseTimer <> $
      {
         piRemainingPhaseTime = GetTimeRemaining(ptPhaseTimer);
         DeleteTimer(ptPhaseTimer);
         ptPhaseTimer = $;
         
         if ptPhaseVisualEffectTimer <> $
         {
            DeleteTimer(ptPhaseVisualEffectTimer);
            ptPhaseVisualEffectTimer = $;
         }
      }

      % If we added phase time to piTimeAttackedPlayer before,
      % remove what is remaining (restore to original time).
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 - (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   PhaseSurrenderEarly()
   {
      local oPhase;

      if ptPhaseTimer <> $
      {
         DeleteTimer(ptPhaseTimer);  
         ptPhaseTimer = $;
      }

      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }
      
      oPhase = Send(SYS,@FindSpellByNum,#num=SID_PHASE);
      Send(self,@RemoveEnchantment,#what=oPhase);
      Send(oPhase,@NotifyRoomPenalty,#who=self);
      Send(oPhase,@InflictFlatPenalties,#who=self);

      Post(self,@AdminGoToLastSafeRoom);

      Send(self,@RefreshPhaseTimeToBase);

      return;
   }

   PhaseTimerEnd()
   {
      local oPhase;

      ptPhaseTimer = $;

      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }
      
      oPhase = Send(SYS,@FindSpellByNum,#num=SID_PHASE);
      Send(self,@RemoveEnchantment,#what=oPhase);
      Send(oPhase,@NotifyRoomPenalty,#who=self);
      Send(oPhase,@InflictFlatPenalties,#who=self);

      Post(self,@AdminGoToLastSafeRoom);

      Send(self,@RefreshPhaseTimeToBase);

      return;
   }

   GetRemainingPhaseTime()
   {
      if ptPhaseTimer <> $
      {
         return GetTimeRemaining(ptPhaseTimer);
      }

      return piRemainingPhaseTime;
   }

   GetBasePhaseTime()
   {
      if (piFlags & PFLAG_MURDERER)
         OR (piFlags & PFLAG_OUTLAW)
      {
         return Send(SETTINGS_OBJECT,
               @GetOutlawMurdererLogoffPenaltyGhostTime);
      }

      return Send(SETTINGS_OBJECT,@GetLogoffPenaltyGhostTime);
   }

   RefreshPhaseTimeToBase()
   {
      if ptLoggedOnRefreshPhaseTimer <> $
      {
         DeleteTimer(ptLoggedOnRefreshPhaseTimer);
         ptLoggedOnRefreshPhaseTimer = $;
      }

      if piRemainingPhaseTime <> Send(self,@GetBasePhaseTime)
      {
         piRemainingPhaseTime = Send(self,@GetBasePhaseTime);
      }

      return;
   }

   SetPhaseTimeEqualTo(amount=60000)
   "Used by logoff ghosts to sync up penalty times."
   {
      piRemainingPhaseTime = amount;

      % Logoff ghosts call this when the player returns, so we remove
      % the phase time remaining from piTimeAttackedPlayer here if we
      % added it when the user logged off.
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 - (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   CanPhaseAgain(time=$)
   {
      if ptCanPhaseTimer <> $
      {
         return FALSE;
      }

      if time > 0
      {
         ptCanPhaseTimer = CreateTimer(self,@CanPhaseTimer,time);
      }

      return TRUE;
   }

   CanPhaseTimer()
   {
      ptCanPhaseTimer = $;

      return;
   }

   GetLastHitByBattler()
   {
      return piTimeLastHitByBattler;
   }
   
   WasHitRecently()
   {
      if piTimeLastHitByBattler = 0
      {
         return FALSE;
      }
      else if piTimeLastHitByBattler < GetTime() - DURATION_RECENTLY_SECONDS
      {
         return FALSE;
      }

      return TRUE;
   }

   GetLastPvpWarned()
   {
      return piTimeAttackedByPlayer;
   }
   
   DoPvpNotify()
   {
      % Don't gong if we are already in pvp
      if piTimeAttackedPlayer < GetTime() - PVP_NOTIFY_DECAY
      {
         if poOwner <> $
         {
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=pvp_notify_wav);
            piTimeAttackedByPlayer = GetTime();
         }
      }

      return;
   }

   % Use this for when either phase or spectator do the same thing
   IsInCannotInteractMode()
   {
      if (piFlags & PFLAG_PHASED)
         OR (piFlags & PFLAG_SPECTATOR)
      {
         return TRUE;
      }

      return FALSE;
   }

   IsPhasedOut()
   {
      return (piFlags & PFLAG_PHASED);
   }

   IsLikelyVictim()
   {
      if Send(self,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      propagate;
   }

   AddCorpse(corpse=$)
   {
      plCorpses = Cons(corpse,plCorpses);
      return;
   }

   RemoveCorpse(corpse=$)
   {
      if plCorpses <> $
         AND FindListElem(plCorpses,corpse) <> 0
      {
         plCorpses = DelListElem(plCorpses, corpse);
      }
      return;
   }

   GetCorpses()
   {
      return plCorpses;
   }

   GetLastCorpse()
   {
      if plCorpses <> $
      {
         return First(plCorpses);
      }
      return $;
   }

   ClearStance()
   {
      local oStance;
      
      oStance = Send(self,@GetStance);
      
      if oStance <> $
      {
         Send(oStance,@EndStance,#who=self);
      }

      poStance = $;
      Post(self,@DrawOffense);
      Post(self,@DrawDefense);
      
      return;
   }
   
   BeginStance(what=$)
   {
      Send(self,@BreakTrance,#event=EVENT_STANCE_CHANGE,#what=what);

      poStance = what;
      
      Post(self,@DrawOffense);
      Post(self,@DrawDefense);
      
      return;
   }
   
   GetStance()
   {
      return poStance;
   }

   ReserveSong(oSpell=$,iFlatManaReserved=0)
   {
      if oSpell <> $
         AND NOT Send(self,@HasReservedSong,#oSpell=oSpell)
      {
         Send(self,@LoseMana,#amount=iFlatManaReserved);
         plReservedSongs = Cons([oSpell,iFlatManaReserved],plReservedSongs);
         Post(self,@ComputeMaxMana);
         return TRUE;
      }
      return FALSE;
   }

   UnReserveSong(oSpell=$)
   {
      local i;
      
      foreach i in plReservedSongs
      {
         if Nth(i,1) = oSpell
         {
            plReservedSongs = DelListElem(plReservedSongs,i);
            Post(self,@ComputeMaxMana);
            return TRUE;
         }
      }
      return FALSE;
   }

   ReserveSpell(oSpell=$,iPercentManaReserved=0,iSpellPower=0)
   {
      local iState;
      
      iState=Send(oSpell,@GetStateValue,
                        #iSpellpower=iSpellpower,
                        #who=self,
                        #target=self);

      if oSpell <> $
         AND NOT Send(self,@HasReservedSpell,#oSpell=oSpell)
      {
         plReservedSpells = 
            Cons([oSpell,iPercentManaReserved,iState,iSpellPower],plReservedSpells);
         Post(self,@ResetPlayerFlagList);
         Post(self,@ComputeMaxMana);
         Send(self,@ShowAddEnchantment,#what=oSpell,#type=ENCHANTMENT_PLAYER);
         Post(self,@CheckTattooed);

         Post(self,@DrawResistances);
         
         return TRUE;
      }

      return FALSE;
   }
   
   UnReserveSpell(oSpell=$,report=TRUE,remain=FALSE)
   {
      local i;

      if oSpell <> $
         AND Send(self,@HasReservedSpell,#oSpell=oSpell)
      {
         foreach i in plReservedSpells
         {
            if First(i) = oSpell
            {
               Send(First(i),@EndEnchantment,#who=self,#state=Nth(i,3),#report=report,#remain=remain);
               Post(self,@ComputeMaxMana);
               plReservedSpells = DelListElem(plReservedSpells,i);
               Send(self,@ShowRemoveEnchantment,#what=oSpell,
                                                #type=ENCHANTMENT_PLAYER);
               Post(self,@ResetPlayerFlagList);

               Post(self,@CheckTattooed);

               Post(self,@DrawResistances);

               return TRUE;
            }
         }
      }
      return FALSE;
   }
   
   UnReserveAllSpells()
   {
      local i, bRemoved;

      bRemoved = FALSE;
      foreach i in plReservedSpells
      {
         Send(First(i),@EndEnchantment,#who=self,#state=Nth(i,3));
         Send(self,@ShowRemoveEnchantment,#what=Nth(i,1),
                                          #type=ENCHANTMENT_PLAYER);
         plReservedSpells = DelListElem(plReservedSpells,i);
         bRemoved = TRUE;
      }

      if bRemoved
      {
         Post(self,@ComputeMaxMana);
      }

      return;
   }
   
   UnReserveAllSongs()
   {
      local i, bRemoved;

      bRemoved = FALSE;
      foreach i in plReservedSongs
      {
         plReservedSongs = DelListElem(plReservedSongs,i);
         bRemoved = TRUE;
      }

      plReservedSongs = $;

      if bRemoved
      {
         Post(self,@ComputeMaxMana);
      }

      return;
   }
   
   GetPercentManaReserved(oSpell=$)
   {
      local i;
      
      foreach i in plReservedSpells
      {
         if First(i) = oSpell
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }

   GetFlatManaReserved(oSpell=$)
   {
      local i;

      foreach i in plReservedSongs
      {
         if First(i) = oSpell
         {
            return Nth(i,2);
         }
      }
      
      return 0;
   }

   GetMaxManaWithoutReservedPenalties()
   {
      return piBaseMax_mana;
   }
   
   GetPercentReservedManaTotal()
   {
      local i, iPercentReservedTotal;
      
      iPercentReservedTotal = 0;
      foreach i in plReservedSpells
      {
         iPercentReservedTotal = iPercentReservedTotal + Nth(i,2);
      }
      
      return iPercentReservedTotal;
   }

   GetFlatReservedManaTotal()
   {
      local i, iFlatReservedTotal;
      
      iFlatReservedTotal = 0;
      foreach i in plReservedSongs
      {
         iFlatReservedTotal = iFlatReservedTotal + Nth(i,2);
      }

      return iFlatReservedTotal;
   }

   GetReservedSongs()
   {
      return plReservedSongs;
   }

   GetReservedSpells()
   {
      return plReservedSpells;
   }

   HasPurgeableReservedSpell()
   {
      local i;

      foreach i in plReservedSpells
      {
         if Send(First(i),@CanBeRemovedByPlayer)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   HasReservedSpell(oSpell=$)
   {
      local i;
      
      foreach i in plReservedSpells
      {
         if First(i) = oSpell
         {
            return TRUE;
         }
      }
      return FALSE;
   }

   HasReservedSong(oSpell=$)
   {
      local i;

      foreach i in plReservedSongs
      {
         if First(i) = oSpell
         {
            return TRUE;
         }
      }
      return FALSE;
   }

   GetCastPower(what=$)
   {
      local i;

      % Check reserved spells before moving up to battler
      foreach i in plReservedSpells
      {
         if First(i) = what
         {
            return Nth(i,4);
         }
      }

      propagate;
   }

   ReservesForThisLevel(iLevel=0)
   {
      if poStance = Send(SYS,@FindSkillByNum,#num=SKID_CASTING_STANCE)
      {
         if iLevel = 1
         {
            return Send(self,@GetSkillAbility,#Skill_num=SKID_LINK_ONE);
         }
         if iLevel = 2
         {
            return Send(self,@GetSkillAbility,#Skill_num=SKID_LINK_TWO);
         }
         if iLevel = 3
         {
            return Send(self,@GetSkillAbility,#Skill_num=SKID_LINK_THREE);
         }
         if iLevel = 4
         {
            return Send(self,@GetSkillAbility,#Skill_num=SKID_LINK_FOUR);
         }
         if iLevel = 5
         {
            return Send(self,@GetSkillAbility,#Skill_num=SKID_LINK_FIVE);
         }
      }
      return FALSE;
   }
   
   UseReserveSkill(oSpell=$,iSpellPower=0)
   {
      local iLevel;
      
      iLevel = Send(oSpell,@GetLevel);
      
      if iLevel = 1
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_LINK_ONE),
                  @DoSkill,#who=self,
                           #oSpell=oSpell,
                           #iSpellPower=iSpellPower);
         return;
      }
      
      if iLevel = 2
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_LINK_TWO),
                  @DoSkill,#who=self,
                           #oSpell=oSpell,
                           #iSpellPower=iSpellPower);
         return;
      }
      
      if iLevel = 3
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_LINK_THREE),
                  @DoSkill,#who=self,
                           #oSpell=oSpell,
                           #iSpellPower=iSpellPower);
         return;
      }
      
      if iLevel = 4
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_LINK_FOUR),
                  @DoSkill,#who=self,
                           #oSpell=oSpell,
                           #iSpellPower=iSpellPower);
         return;
      }
      
      if iLevel = 5
      {
         Send(Send(SYS,@FindSkillByNum,#num=SKID_LINK_FIVE),
                  @DoSkill,#who=self,
                           #oSpell=oSpell,
                           #iSpellPower=iSpellPower);
         return;
      }
      
      return;
   }
   
   IsEnchanted(what=$,byClass=&Spell)
   {
      local i;
      
      foreach i in plReservedSpells
      {
         if (what = $
            AND IsClass(First(i),byClass))
            OR First(i) = what
         {
            return TRUE;
         }
      }
      
      propagate;
   }

   GetEnchantedState(what=$)
   {
      local i;

      foreach i in plReservedSpells
      {
         if Nth(i,1) = what
         {
            return Nth(i,3);
         }
      }

      propagate;
   }
   
   InflictWait(time=1000)
   {
      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }
      
      ptAttackTimer = CreateTimer(self,@AttackTimer,time);
      
      return;
   }
   
   GetActiveTouchSpell()
   {
      local i;
      
      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),&TouchAttackSpell)
         {
            return Nth(i,2);
         }
      }
      
      foreach i in plReservedSpells
      {
         if IsClass(Nth(i,1),&TouchAttackSpell)
         {
            return Nth(i,1);
         }
      }
      
      return $;
   }

   GetHexIncEffect(iSpellPower=0,oTarget=$)
   {
      local iRunesEff, oRunes, iNightgripEff, oNightgrip, i, iGearIncEffect, lBindingSongState, iBindingSongInc;

      iRunesEff = 0;
      oRunes = Send(SYS,@FindSkillByNum,#num=SKID_UNHALLOWED_RUNES);

      if oRunes <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_UNHALLOWED_RUNES) > 0
         AND Send(oRunes,@DoSkill,#who=self)
      {
         iRunesEff = Send(oRunes,@GetIncHexEffectiveness,#who=self);
      }

      iNightgripEff = 0;
      oNightgrip = Send(SYS,@FindSkillByNum,#num=SKID_NIGHTGRIP);

      if oNightgrip <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_NIGHTGRIP) > 0
         AND Send(oNightgrip,@DoSkill,#who=self,#oTarget=oTarget)
      {
         iNightgripEff = Send(oNightgrip,@GetIncHexEffectiveness,#who=self,#oTarget=oTarget);
      }

      iBindingSongInc = 0;
      lBindingSongState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&BindingSong);
      if lBindingSongState <> $
      {
         iBindingSongInc = Send(Nth(lBindingSongState,1),@GetHexIncEffect,#iSongPower=Nth(lBindingSongState,2));
      }
      
      iGearIncEffect = 0;
      foreach i in plUsing
      {
         iGearIncEffect = iGearIncEffect + Send(i,@GetHexIncEffect);
      }
      return iSpellPower + 1 + iRunesEff + iNightgripEff + iGearIncEffect + iBindingSongInc;
   }

   GetHexResistance()
   {
      local iArcaneKnowledgeRes, iHermitageRes, oKnowledge, oHermitage, i, iGearResistance,
            lBindingSongState, iBindingSongRes, iRacialRes;
      
      iArcaneKnowledgeRes = 0;
      oKnowledge = Send(SYS,@FindSkillByNum,#num=SKID_ARCANE_KNOWLEDGE);

      if oKnowledge <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_ARCANE_KNOWLEDGE) > 0
         AND Send(oKnowledge,@DoSkill,#who=self)
      {
         iArcaneKnowledgeRes = Send(oKnowledge,@GetHexResistance,#who=self);
      }
      
      iHermitageRes = 0;
      oHermitage = Send(SYS,@FindSkillByNum,#num=SKID_HERMITAGE);

      if oHermitage <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_HERMITAGE) > 0
         AND Send(oHermitage,@DoSkill,#who=self)
      {
         iHermitageRes = Send(oHermitage,@GetHexResistance,#who=self);
      }

      iBindingSongRes = 0;
      lBindingSongState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&BindingSong);
      if lBindingSongState <> $
      {
         iBindingSongRes = Send(Nth(lBindingSongState,1),@GetHexResistance,#iSongPower=Nth(lBindingSongState,2));
      }
      
      iGearResistance = 0;
      foreach i in plUsing
      {
         iGearResistance = iGearResistance + Send(i,@GetHexResistance);
      }

      iRacialRes = Send(self,@GetRacialHexResistance);
      
      return bound(piHexResistance+iArcaneKnowledgeRes+iHermitageRes+iGearResistance+iBindingSongRes+iRacialRes,-200,200);
   }

   GetCasterMaxHexes()
   {
      local iHexesMax, oRunes;

      iHexesMax = Send(SETTINGS_OBJECT,@GetHexesMax);
      oRunes = Send(SYS,@FindSkillByNum,#num=SKID_BLOOD_RUNES);

      if oRunes <> $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_BLOOD_RUNES) > 0
         AND Send(oRunes,@DoSkill,#who=self)
      {
         iHexesMax = iHexesMax + Send(oRunes,@GetMaxHexesIncrease);
      }
      
      if Send(self,@IsUsingA,#class=&WitcheryCrest)
      {
         iHexesMax++;
      }
                  
      return iHexesMax;
   }

   SetDeathTime(iTime=0)
   {
      piLastDeathTime = iTime;
      return;
   }

   GetMaleDeathWav()
   {
      return playerm_death_wav;
   }

   GetFemaleDeathWav()
   {
      return playerf_death_wav;
   }

   SetPrismDefeated(num=NTH_LIGHTNING_PRISM, value=1)
   {
      if Nth(plPrismsDefeated,num) = 0
         AND value = 1
      {
         Send(self,@PrismDefeatedMessage,#type=num);
      }
      SetNth(plPrismsDefeated,num,value);
      
      if Nth(plPrismsDefeated,NTH_LIGHTNING_PRISM) = 1
         AND Nth(plPrismsDefeated,NTH_ICE_PRISM) = 1
         AND Nth(plPrismsDefeated,NTH_ACID_PRISM) = 1
         AND Nth(plPrismsDefeated,NTH_FIRE_PRISM) = 1
         AND Nth(plPrismsDefeated,NTH_DEATH_PRISM) = 1
         AND Nth(plPrismsDefeated,NTH_LIFE_PRISM) = 1
      {
         Post(self,@MsgSendUser,#message_rsc=all_six_prisms_defeated_msg);
      }
      
      Post(self,@DrawResistances);

      return;
   }
   
   ClearPrismsDefeated()
   {
      plPrismsDefeated = [0,0,0,0,0,0];
      return;
   }

   PrismDefeatedMessage(type=NTH_LIGHTNING_PRISM)
   {
      % Handles the various elemental attunement messages.

      switch(type)
      {
         case NTH_LIGHTNING_PRISM:
            Post(self,@MsgSendUser,#message_rsc=lightning_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
         case NTH_ICE_PRISM:
            Post(self,@MsgSendUser,#message_rsc=ice_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
         case NTH_ACID_PRISM:
            Post(self,@MsgSendUser,#message_rsc=acid_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
         case NTH_FIRE_PRISM:
            Post(self,@MsgSendUser,#message_rsc=fire_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
         case NTH_DEATH_PRISM:
            Post(self,@MsgSendUser,#message_rsc=death_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
         case NTH_LIFE_PRISM:
            Post(self,@MsgSendUser,#message_rsc=life_attunement_msg,
                                   #parm1=Send(SETTINGS_OBJECT,@GetPrismResistanceReward),
                                   #parm2=Send(SETTINGS_OBJECT,@GetPrismMaxResistanceReward),
                                   #parm3=Send(SETTINGS_OBJECT,@GetPrismEmpowermentReward));
            return;
      }
      return;
   }

   BrokenFactionTimerCheck()
   {
      % This will throw one-time errors because GetTimeRemaining will fail.
      % However, it will fix the error on existing characters.
      % ptFactionTimer sometimes didn't clear for some reason
      % and ResetTimerReference will throw complaints forever.
      if ptFactionTimer <> $
         AND GetTimeRemaining(ptFactionTimer) = $
      {
         ptFactionTimer = $;
      }
      return;
   }

   UsedBloodMagic()
   {
      pbUsedBloodMagic = TRUE;
      return;
   }
   
   CastOrFizzledNoteBloodMagic()
   {
      % Once the spell's cast or fizzled, turn imping back on.
      pbUsedBloodMagic = FALSE;
      return;
   }
   
   GetUsedBloodMagic()
   {
      return pbUsedBloodMagic;
   }

   HasSwordOfTheHunt()
   {
      local i;

      foreach i in plActive
      {
         if IsClass(i,&HunterSword)
         {
            return TRUE;
         }         
      }
      return FALSE;
   }

   HasAmuletOfTheThree()
   {
      local i;

      foreach i in plActive
      {
         if IsClass(i,&NecromancerAmulet)
         {
            return TRUE;
         }         
      }
      return FALSE;
   }
   
   SetMasteredSkill(num=0)
   {
      if piMasteredSkill = SKID_PROFICIENCY_SWORD
         OR num = SKID_PROFICIENCY_SWORD
      {
         Post(self,@DrawDefense);
      }
      if piMasteredSkill = SKID_FORTITUDE
         OR num = SKID_FORTITUDE
      {
         Post(self,@SetVigorRestThreshold);
      }

      piMasteredSkill=num;

      return;
   }
   
   SetMasteredSpell(num=0)
   {
      piMasteredSpell=num;
      return;
   }
   
   GetMasteredSkill()
   {
      return piMasteredSkill;
   }
   
   GetMasteredSpell()
   {
      return piMasteredSpell;
   }
   
   HasMasteredThisSkill(num=0)
   {
      if piMasteredSkill = num
      {
         return TRUE;
      }
      return FALSE;
   }
   
   HasMasteredThisSpell(num=0)
   {
      if piMasteredSpell = num
      {
         return TRUE;
      }
      return FALSE;
   }
   
   UsedPortal(what=$)
   {
      local i;
      
      foreach i in Send(self,@GetPassiveQuests)
      {
         Send(i,@UsedPortal,#what=what);
      }
      return;
   }

   SetInformReincarnationProgress(value=TRUE)
   {
      pbInformReincarnationProgress = value;
      return;
   }

   BarberRandomizeSkinColor()
   {
      if piPlayerRace = RACE_HUMAN
      {
         piOriginalSkinColor = Random(1,4);
         Send(self,@SetSkinTranslation,#translation=piOriginalSkinColor);
         Send(self,@SetDefaultClothes,#shirt_color=Bound(piOriginalSkinColor-1,1,$),#pants_color=Bound(piOriginalSkinColor-1,1,$));
         if poOwner <> $
         {
            Send(poOwner,@SomethingChanged,#what=self);
         }
         return;
      }
      return;
   }

   BarberIncrementHair()
   {
       local lHairStyles, i, bNext;
       
       if poHair_remove <> $
       {
          % Can't see our hair. Don't mess things up.
          % This covers shrunken head masks, helmets, draconian race.
          return;
       }
    %  prEyes = charinfo_eyes_ax_icon;
    %  prMouth = charinfo_nose_ax_icon;
    %  prNose = charinfo_mouth_ax_icon;
    %  prToupee = charinfo_hair_cd_icon;
    
      lHairStyles = [charinfo_hair_ac_icon,
                     charinfo_hair_ba_icon,
                     charinfo_hair_bc_icon,
                     charinfo_hair_cd_icon,
                     charinfo_hair_ca_icon,
                     charinfo_hair_db_icon,
                     charinfo_hair_ad_icon,
                     charinfo_hair_bb_icon,
                     charinfo_hair_bd_icon,
                     charinfo_hair_cb_icon,
                     charinfo_hair_dc_icon,
                     charinfo_hair_dr_icon,
                     charinfo_hair_xa_icon,
                     charinfo_hair_xb_icon,
                     charinfo_hair_bald_icon];

      % Handle end of list
      if prToupee = Nth(lHairStyles,Length(lHairStyles))
      {
         prToupee = First(lHairStyles);
         Send(poOwner,@SomethingChanged,#what=self);
         return;
      }

      bNext = FALSE;
      foreach i in lHairStyles
      {
         if bNext
         {
            prToupee = i;
            Send(poOwner,@SomethingChanged,#what=self);
            return;
         }
         if prToupee = i
         {
            bNext = TRUE;
         }
      }

      return;
   }

   BarberRandomizeHairColor()
   {
       local lHairColors, iHair_translation;
       
       if poHair_remove <> $
       {
          % Can't see our hair. Don't mess things up.
          % This covers shrunken head masks, helmets, draconian race.
          return;
       }
    
      lHairColors = [0,
                     PT_GRAY_TO_ORANGE,
                     PT_GRAY_TO_RED,
                     PT_GRAY_TO_SKIN1,
                     PT_GRAY_TO_SKIN2,
                     PT_GRAY_TO_SKIN3,
                     PT_GRAY_TO_SKIN4,
                     PT_GRAY_TO_SKIN5,
                     PT_GRAY_TO_PLATBLOND,
                     PT_GRAY_TO_KORANGE,
                     PT_GRAY_TO_KRED,
                     PT_GRAY_TO_KGRAY,
                     PT_GRAY_TO_BLACK,
                     PT_GRAY_TO_BLOND];

      Send(self,@SetHairTranslation,#translation=Nth(lHairColors,Random(1,Length(lHairColors))));
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetBaseSize()
   {
      local iRacialSizeBonus;
      
      iRacialSizeBonus = 0;
      switch(piPlayerRace)
      {
         case RACE_HALF_UNDINE:
            iRacialSizeBonus = -100;
            break;
         case RACE_HALF_DEMON:
            iRacialSizeBonus = -50;
            break;
         case RACE_GNOME:
            iRacialSizeBonus = -25;
            break;
         case RACE_DROW:
            iRacialSizeBonus = -25;
            break;
         case RACE_HALF_ELF:
            iRacialSizeBonus = -25;
            break;
         case RACE_HALF_ORC:
            iRacialSizeBonus = 50;
            break;
         case RACE_DRACONIAN:
            iRacialSizeBonus = 100;
            break;
         case RACE_AUTOMATON:
            iRacialSizeBonus = 30;
            break;
      }

      return viBaseSize + iRacialSizeBonus;
   }

   GetKnockbackPercentage()
   {
      local i, iGearBonus;
      
      iGearBonus = 0;
      foreach i in plUsing
      {
         iGearBonus = iGearBonus + Send(i,@GetKnockbackResistance);
      }

      return Bound(viBaseKnockbackPercentage - iGearBonus,0,$);
   }

   GetStunPercentage()
   {
      local i, iGearBonus;
      
      iGearBonus = 0;
      foreach i in plUsing
      {
         iGearBonus = iGearBonus + Send(i,@GetStunResistance);
      }

      return Bound(viBaseStunPercentage - Send(self,@GetStamina)/2 - iGearBonus,0,$);
   }

   GetBleedPercentage()
   {
      if piPlayerRace = RACE_AUTOMATON
      {
         % Automatons can't bleed.
         return 0;
      }
      return Bound(viBaseBleedPercentage - Send(self,@GetAgility)/2,0,$);
   }

   GetCriticalPercentage()
   {
      return 100;
   }

   GetCriticalHitRate(oWeapon=$)
   {
      local iStanceCritMultiplier, iBaseCritRate, iAimMultiplier, iFinalCritRate;

      iBaseCritRate = Send(oWeapon,@GetCriticalHitRate);

      % Scale of 100 for granularity purposes
      % 1%  = 100
      % 5%  = 500
      % 10% = 1000
      % 15% = 1500
      % 20% = 2000
      
      % Check for base crit bonuses
      if IsClass(oWeapon,&Dagger)
         AND Send(self,@HasSkill,#num=SKID_BLADE_MASTERY)
      {
         iBaseCritRate = Send(Send(SYS,@FindSkillByNum,#num=SKID_BLADE_MASTERY),@ModifyBaseCritRate,#who=self,#iBaseCritRate=iBaseCritRate);
      }
      if (IsClass(oWeapon,&Mace)
         OR IsClass(oWeapon,&Hammer)
         OR IsClass(oWeapon,&SpiritualHammer))
         AND Send(self,@HasSkill,#num=SKID_BASH)
      {
         iBaseCritRate = Send(Send(SYS,@FindSkillByNum,#num=SKID_BASH),@ModifyBaseCritRate,#who=self,#iBaseCritRate=iBaseCritRate);
      }

      % Aim multiplier can increase crit rate up to 50%
      iAimMultiplier = 100 + (Send(self,@GetAim)/2);
      
      % Combine base and aim
      iFinalCritRate = (iBaseCritRate * iAimMultiplier)/100;

      % Check for stance multipliers. 100 means no change
      iStanceCritMultiplier = 100;
      if poStance <> $
      {
         if IsClass(poStance,&HeavyAttackStance)
         {
            iStanceCritMultiplier = 300;
         }
         %if IsClass(poStance,&LightAttackStance)
         %{
         %   iStanceCritMultiplier = 50;
         %}
      }
      
      % Combine rate and stance multiplier
      iFinalCritRate = (iFinalCritRate * iStanceCritMultiplier)/100;

      return Bound(iFinalCritRate,0,10000);
   }

   GetKnockbackPower()
   {
      local iStanceBonus;
      
      iStanceBonus = 100;
      
      if poStance <> $
      {
         if IsClass(poStance,&HeavyAttackStance)
         {
            iStanceBonus = 300;
         }
         if IsClass(poStance,&LightAttackStance)
            OR IsClass(poStance,&ShadowstepStance)
            OR (Send(self,@GetWeapon) = $
               AND Send(self,@HasSkill,#num=SKID_FLICKER_STRIKE))
         {
            iStanceBonus = 50;
         }
      }
      return (((Send(self,@GetSize) * (100+Send(self,@GetMight)/2))*iStanceBonus)/100)/100;
   }
   
   GetStunPower()
   {
      local iStanceBonus;
      
      iStanceBonus = 100;
      
      if poStance <> $
      {
         if IsClass(poStance,&HeavyAttackStance)
         {
            iStanceBonus = 300;
         }
         if IsClass(poStance,&LightAttackStance)
            OR IsClass(poStance,&ShadowstepStance)
            OR (Send(self,@GetWeapon) = $
               AND Send(self,@HasSkill,#num=SKID_FLICKER_STRIKE))
         {
            iStanceBonus = 50;
         }
      }
      return (Send(self,@GetSize)*iStanceBonus)/100;
   }

   GetBleedPower()
   {
      local iBleedPower;
      
      iBleedPower = Send(self,@GetSize);
      
      if Send(self,@HasSkill,#num=SKID_BLEED_MASTERY)
      {
         iBleedPower = Send(Send(SYS,@FindSkillByNum,#num=SKID_BLEED_MASTERY),@ModifyBleedPower,#who=self,#iBleedPower=iBleedPower);
      }
      
      return iBleedPower;
   }

   AttemptTrainStatPoint(type=STAT_ID_AIM)
   {
      local iMight, iIntellect, iStamina, iAgility, iMysticism, iAim;

      iMight = piMight;
      iIntellect = piIntellect;
      iStamina = piStamina;
      iAgility = piAgility;
      iMysticism = piMysticism;
      iAim = piAim;

      % Let's see what the player's situation would look like if we incremented
      switch(type)
      {
         case STAT_ID_MIGHT:
            iMight++;
            break;
         case STAT_ID_INTELLECT:
            iIntellect++;
            break;
         case STAT_ID_STAMINA:
            iStamina++;
            break;
         case STAT_ID_AGILITY:
            iAgility++;
            break;
         case STAT_ID_MYSTICISM:
            iMysticism++;
            break;
         case STAT_ID_AIM:
            iAim++; 
            break;
      }

      % Range check
      if (iMight < 1 OR iMight > Send(self,@GetMaxMight))
         OR (iIntellect < 1 OR iIntellect > Send(self,@GetMaxIntellect))
         OR (iStamina < 1 OR iStamina > Send(self,@GetMaxStamina))
         OR (iAgility < 1 OR iAgility > Send(self,@GetMaxAgility))
         OR (iMysticism < 1 OR iMysticism > Send(self,@GetMaxMysticism))
         OR (iAim < 1 OR iAim > Send(self,@GetMaxAim))
      {
         return FALSE;
      }
      
      % Total stat points check
      if ((iMight + iIntellect + iStamina + iAgility + iMysticism + iAim)
             > Send(self,@GetTotalRawStatPoints) )
      {
         return FALSE;
      }

      % Now that we've checked everything would be correct, actually increment stat.
      switch(type)
      {
         case STAT_ID_MIGHT:
            piMight++;
            Post(self,@MsgSendUser,#message_rsc=gained_might_msg,#parm1=piMight);
            Post(self,@DrawMight);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_INTELLECT:
            piIntellect++;
            Post(self,@MsgSendUser,#message_rsc=gained_intellect_msg,#parm1=piIntellect);
            Post(self,@DrawIntellect);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_STAMINA:
            piStamina++;
            Post(self,@MsgSendUser,#message_rsc=gained_stamina_msg,#parm1=piStamina);
            Post(self,@DrawStamina);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_AGILITY:
            piAgility++;
            Post(self,@MsgSendUser,#message_rsc=gained_agility_msg,#parm1=piAgility);
            Post(self,@DrawAgility);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_MYSTICISM:
            piMysticism++;
            Post(self,@MsgSendUser,#message_rsc=gained_mysticism_msg,#parm1=piMysticism);
            Post(self,@DrawMysticism);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_AIM:
            piAim++;
            Post(self,@MsgSendUser,#message_rsc=gained_aim_msg,#parm1=piAim);
            Post(self,@DrawAim);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
      }

      return FALSE;
   }

   AttemptTrainStatPoints(type=STAT_ID_AIM,amount=5)
   {
      local iMight, iIntellect, iStamina, iAgility, iMysticism, iAim;

      iMight = piMight;
      iIntellect = piIntellect;
      iStamina = piStamina;
      iAgility = piAgility;
      iMysticism = piMysticism;
      iAim = piAim;

      % Let's see what the player's situation would look like if we incremented
      switch(type)
      {
         case STAT_ID_MIGHT:
            iMight = iMight + amount;
            break;
         case STAT_ID_INTELLECT:
            iIntellect = iIntellect + amount;
            break;
         case STAT_ID_STAMINA:
            iStamina = iStamina + amount;
            break;
         case STAT_ID_AGILITY:
            iAgility = iAgility + amount;
            break;
         case STAT_ID_MYSTICISM:
            iMysticism = iMysticism + amount;
            break;
         case STAT_ID_AIM:
            iAim = iAim + amount;
            break;
      }

      % Range check
      if (iMight < 1 OR iMight > Send(self,@GetMaxMight))
         OR (iIntellect < 1 OR iIntellect > Send(self,@GetMaxIntellect))
         OR (iStamina < 1 OR iStamina > Send(self,@GetMaxStamina))
         OR (iAgility < 1 OR iAgility > Send(self,@GetMaxAgility))
         OR (iMysticism < 1 OR iMysticism > Send(self,@GetMaxMysticism))
         OR (iAim < 1 OR iAim > Send(self,@GetMaxAim))
      {
         return FALSE;
      }
      
      % Total stat points check
      if ((iMight + iIntellect + iStamina + iAgility + iMysticism + iAim)
             > Send(self,@GetTotalRawStatPoints) )
      {
         return FALSE;
      }

      % Now that we've checked everything would be correct, actually increment stat.
      switch(type)
      {
         case STAT_ID_MIGHT:
            piMight = piMight + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_might_msg,#parm1=piMight);
            Post(self,@DrawMight);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_INTELLECT:
            piIntellect = piIntellect + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_intellect_msg,#parm1=piIntellect);
            Post(self,@DrawIntellect);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_STAMINA:
            piStamina = piStamina + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_stamina_msg,#parm1=piStamina);
            Post(self,@DrawStamina);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_AGILITY:
            piAgility = piAgility + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_agility_msg,#parm1=piAgility);
            Post(self,@DrawAgility);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_MYSTICISM:
            piMysticism = piMysticism + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_mysticism_msg,#parm1=piMysticism);
            Post(self,@DrawMysticism);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
         case STAT_ID_AIM:
            piAim = piAim + amount;
            Post(self,@MsgSendUser,#message_rsc=gained_aim_msg,#parm1=piAim);
            Post(self,@DrawAim);
            Post(self,@GiveUnassignedStatPointsReport);
            return TRUE;
      }

      return FALSE;
   }

   GiveUnassignedStatPointsReport()
   {
      Send(self,@MsgSendUser,#message_rsc=unassigned_stat_points,#parm1=Send(self,@GetTotalRawStatPoints)-(piMight+piIntellect+piStamina+piAgility+piMysticism+piAim));
      return;
   }

   GiveSchoolsReport()
   {
      local iShal, iQor, iWC, iKC, iBanditry, iSorcery, iWitchery, iAlchemy, iKraanan, iFaren, iRiija, iJala, iBestiary, iShadowcraft,
            iCurrentLearnPoints, iIntRemaining, lSchoolLevels;
      
      lSchoolLevels = Send(self,@GetSchoolLevels);

      iShal = Nth(lSchoolLevels,1);
      iQor = Nth(lSchoolLevels,2);
      iKraanan = Nth(lSchoolLevels,3);
      iFaren = Nth(lSchoolLevels,4);
      iRiija = Nth(lSchoolLevels,5);
      iJala = Nth(lSchoolLevels,6);
      iWC = Nth(lSchoolLevels,7);
      iKC = Nth(lSchoolLevels,8);
      iBanditry = Nth(lSchoolLevels,9);
      iSorcery = Nth(lSchoolLevels,10);
      iWitchery = Nth(lSchoolLevels,11);
      iAlchemy = Nth(lSchoolLevels,12);
      iBestiary = Nth(lSchoolLevels,13);
      iShadowcraft = Nth(lSchoolLevels,14);

      Send(self,@MsgSendUser,#message_rsc=schools_report);
      if iShal > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_shal,#parm1=iShal);
      }
      if iQor > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_qor,#parm1=iQor);
      }
      if iWC > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_wc,#parm1=iWC);
      }
      if iKC > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_kc,#parm1=iKC);
      }
      if iBanditry > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_banditry,#parm1=iBanditry);
      }
      if iShadowcraft > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_shadowcraft,#parm1=iShadowcraft);
      }
      if iSorcery > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_sorcery,#parm1=iSorcery);
      }
      if iWitchery > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_witchery,#parm1=iWitchery);
      }
      if iKraanan > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_kraanan,#parm1=iKraanan);
      }
      if iFaren > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_faren,#parm1=iFaren);
      }
      if iRiija > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_riija,#parm1=iRiija);
      }
      if iJala > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_jala,#parm1=iJala);
      }
      if iAlchemy > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_alchemy,#parm1=iAlchemy);
      }
      if iBestiary > 0
      {
         Send(self,@MsgSendUser,#message_rsc=schools_report_bestiary,#parm1=iBestiary);
      }

      iCurrentLearnPoints = Send(self,@GetTotalLearnPoints);
      iIntRemaining = 16 + ((Send(self,@GetRawIntellect)/5)*2) - iCurrentLearnPoints;

      Send(self,@MsgSendUser,#message_rsc=schools_report_intelligence_remaining,#parm1=iIntRemaining/2);
      Send(self,@MsgSendUser,#message_rsc=schools_report_level_one_note);
      return;
   }

   SetLeapKnockback(value=FALSE)
   {
      pbLeapKnockback = value;
      return;
   }
   
   IsShadow()
   {
      return Send(self,@IsEnchanted,#byClass=&ShadowForm);
   }

   GetLastUnstableInfusionChoice()
   {
      return piLastUnstableInfusionChoice;
   }

   SetLastUnstableInfusionChoice(iElement=ATCK_SPELL_FIRE)
   {
      piLastUnstableInfusionChoice = iElement;
      return;
   }

   GetElementalImbalancePower(aspell=0)
   {
      if Send(self,@GetSkillAbility,#Skill_num=SKID_ELEMENTAL_IMBALANCE) > 0
      {
         return Send(Send(SYS,@FindSkillByNum,#num=SKID_ELEMENTAL_IMBALANCE),@GetElementalImbalancePower,#who=self,#aspell=aspell);
      }
      return 0;
   }
   
   FullHeal()
   {
      % Fully heal the player. Used by event content.
      Send(self,@SetHealth,#amount=Send(self,@GetMaxHealth));
      return;
   }
   
   GetCharmResistance()
   {
      % This is a percentage value
      return piBase_Max_Health/4;
   }

   IsRenowned()
   {
      % Does this player have a statue?
      return piRenowned;
   }

   SetRenowned(value=FALSE)
   {
      piRenowned = value;
      return;
   }
   
   BeginHoldingBreath()
   {
      if ptBreathTimer = $
      {
         piBreathRemaining = piNaturalBreathTime;
         Send(self,@SetDrawingBreath,#value=TRUE);
         
         if piPlayerRace = RACE_HALF_UNDINE
         {
            Send(self,@MsgSendUser,#message_rsc=undine_breath);
         }
         else if piPlayerRace = RACE_AUTOMATON
         {
            Send(self,@MsgSendUser,#message_rsc=automaton_breath);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=start_holding_breath);
         }
         ptBreathTimer = CreateTimer(self,@BreathLoss,piBreathTime);
      }
      return;
   }
   
   BreathLoss(timer=$)
   {
      local oWaterBreathing, iBreathLoss;

      ptBreathTimer = $;
      
      iBreathLoss = 1000;
      
      oWaterBreathing = Send(SYS,@FindSpellByNum,#num=SID_WATER_BREATHING);
      if oWaterBreathing <> $
         AND Send(self,@IsEnchanted,#what=oWaterBreathing)
      {
         iBreathLoss =  Send(oWaterBreathing,@ModifyBreathLoss,
                                             #who=self,
                                             #iBreathLoss=iBreathLoss,
                                             #iSpellPower=Send(self,@GetEnchantedState,#what=oWaterBreathing));
      }
      
      if Send(self,@HasSkill,#num=SKID_MATSYASANA)
      {
         iBreathLoss = Send(Send(SYS,@FindSkillByNum,#num=SKID_MATSYASANA),@ModifyBreathLoss,#who=self,#iBreathLoss=iBreathLoss);
      }
      
      piBreathRemaining = Bound(piBreathRemaining - iBreathLoss,0,piNaturalBreathTime);
      
      if piPlayerRace = RACE_HALF_UNDINE
         OR piPlayerRace = RACE_AUTOMATON
      {
         piBreathRemaining = piNaturalBreathTime;
      }
      
      Post(self,@DrawVigor);

      ptBreathTimer = CreateTimer(self,@BreathLoss,piBreathTime);
      
      return;
   }

   TakeABreath()
   {
      Send(self,@SetDrawingBreath);
      if piBreathRemaining > 0
         AND ptBreathTimer <> $
      {
         DeleteTimer(ptBreathTimer);
         ptBreathTimer = $;
         Send(self,@MsgSendUser,#message_rsc=take_breath);
      }
      else if piBreathRemaining = 0
         AND ptBreathTimer <> $
      {
         DeleteTimer(ptBreathTimer);
         ptBreathTimer = $;
         Send(self,@MsgSendUser,#message_rsc=relief_take_breath);
      }
      piBreathRemaining = 60000;
      return;
   }
   
   GetBreathRemaining()
   {
      return piBreathRemaining;
   }
   
   GetNaturalBreathMax()
   {
      return piNaturalBreathTime;
   }

   GetHasBreath()
   {
      if piBreathRemaining = 0
      {
         return FALSE;
      }
      return TRUE;
   }
   
   DeleteStatueCrest()
   {
      local i, oCrest;
      
      oCrest = Send(self,@FindHolding,#class=&Crest);
      
      if oCrest <> $
      {
         Send(oCrest,@Delete);
      }
      return;
   }

   ClearStats()
   {
      piMight = 1;
      piIntellect = 1;
      piStamina = 1;
      piAgility = 1;
      piMysticism = 1;
      piAim = 1;

      Send(self,@DrawMight);
      Send(self,@DrawIntellect);
      Send(self,@DrawStamina);
      Send(self,@DrawAgility);
      Send(self,@DrawMysticism);
      Send(self,@DrawAim);
      Send(self,@GiveUnassignedStatPointsReport);
      
      pbClearedStatsRecently = TRUE;
      return;
   }
   
   ClearedStatsRecently()
   {
      return pbClearedStatsRecently;
   }
   
   GetFreeLeadership()
   {
      return Bound(Send(self,@CalculateLeadershipMax,#bCharming=FALSE) - Send(self,@CalculateLeadershipUsed),0,$);
   }

   CalculateLeadershipMax(oMonster=$, bCharming=TRUE)
   {
      local iLeadership, oGear, iWillpowerBonus, iSoulDominationBonus;
      
      iLeadership = Bound(Send(self,@GetBaseMaxHealth),20,100);
      
      foreach oGear in Send(self,@GetPlayerUsing)
      {
         iLeadership = iLeadership + Send(oGear,@GetLeadershipBonus);
      }

      iWillpowerBonus = 0;
      if Send(self,@HasSkill,#num=SKID_WILLPOWER)
      {
         iWillpowerBonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_WILLPOWER),@GetMinionLimitBoost,#who=self,#oMonster=oMonster,#bCharming=bCharming);
         
         % Up to double
         iLeadership = (iLeadership * iWillpowerBonus)/100;
      }

      iSoulDominationBonus = 0;
      if Send(self,@HasSkill,#num=SKID_SOUL_DOMINATION)
      {
         iSoulDominationBonus = Send(Send(SYS,@FindSkillByNum,#num=SKID_SOUL_DOMINATION),@GetMinionLimitBoost,#who=self,#oMonster=oMonster,#bCharming=bCharming);
         
         % Can double again
         iLeadership = (iLeadership * iSoulDominationBonus)/100;
      }

      if Send(self,@IsUsingA,#class=&BestiaryCrest)
      {
         % Double again for Beastmaster
         iLeadership = iLeadership * 2;
      }

      return iLeadership;
   }

   CalculateLeadershipUsed()
   {
      local iControlledLeadershipCosts, oActive;

      iControlledLeadershipCosts = 0;
      foreach oActive in plControlledMinions
      {
         if IsClass(oActive,&Monster)
           % AND Send(oActive,@GetMaster) = self           % This line leads to timing issues of leadership calculation. Of course we're their master.
         {
            if Send(oActive,@IsUndead)
               AND Send(self,@IsUsingA,#class=&QorCrest)
            {
               iControlledLeadershipCosts = iControlledLeadershipCosts + Send(oActive,@GetLeadershipCost)/2;
            }
            else
            {
               iControlledLeadershipCosts = iControlledLeadershipCosts + Send(oActive,@GetLeadershipCost);
            }
         }
      }
      
      return iControlledLeadershipCosts;
   }

   CanControlNewMinion(oMonster=$, bCharming=TRUE)
   {
      local iControlledLeadershipCosts, oActive, iLeadershipMax, iMonsterLeadershipCost;
      
      if oMonster = $
         OR NOT Send(oMonster,@CanBeCharmed)
      {
         return FALSE;
      }

      iLeadershipMax = Send(self,@CalculateLeadershipMax,#oMonster=oMonster,#bCharming=bCharming);
      iControlledLeadershipCosts = Send(self,@CalculateLeadershipUsed);
      iMonsterLeadershipCost = Send(oMonster,@GetLeadershipCost);

      if Send(oMonster,@IsUndead)
         AND Send(self,@IsUsingA,#class=&QorCrest)
      {
         % Qor Master can control double the undead.
         iMonsterLeadershipCost = iMonsterLeadershipCost/2;
      }

      if iControlledLeadershipCosts + iMonsterLeadershipCost <= iLeadershipMax
      {
         return TRUE;
      }
      
      % We're over our limit.
      return FALSE;
   }

   CanAssist(who=$)
   {
      if Send(who,@GetLadderID) = Send(self,@GetLadderID)
      {
         return TRUE;
      }
      return FALSE;
   }
   
   ConvertAllItemsToNonLadder()
   {
      local i, each_obj;
      
      foreach i in Send(self,@GetHolderActive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Item)
         {
            Send(each_obj,@SetLadderID,#value=0);
         }
      }
      foreach i in Send(self,@GetHolderPassive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Item)
         {
            Send(each_obj,@SetLadderID,#value=0);
         }
      }
      return;
   }
   
   GetRegion()
   {
      if poOwner <> $
      {
         return Send(poOwner,@GetRegion);
      }
      return 0;
   }
   
   GetBookPowerBonus(oSpell=$)
   {
      local i;
      if Send(self,@IsUsingA,#class=&Book)
      {
         foreach i in Send(self,@GetPlayerUsing)
         {
            if IsClass(i,&Book)
            {
               if StringContain(Send(i,@GetInscription),Send(oSpell,@GetDesc))
               {
                  return 10;
               }
            }
         }
      }
      return 0;
   }
   
   GetMarauderAntagonist()
   {
      return pbMarauderAntagonist;
   }
   
   SetMarauderAntagonist(value=FALSE)
   {
      if pbMarauderAntagonist = TRUE
         AND value = FALSE
      {
         Send(self,@MsgSendUser,#message_rsc=Marauders_leave_you_alone);
      }
      pbMarauderAntagonist = value;
      return;
   }
   
   RevertToNonLadder()
   {
      local i, each_obj;
      Send(self,@SetLadderID,#value=0);
      
      pbNotifyLadderEnded = TRUE;
      
      foreach i in Send(self,@GetHolderActive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         Send(each_obj,@SetLadderID,#value=0);
      }
      foreach i in Send(self,@GetHolderPassive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         Send(each_obj,@SetLadderID,#value=0);
      }
      return;
   }
   
   SetFinalLadderRank(value=0)
   {
      piFinalLadderRank = value;
      return;
   }
   
   SetParticipatedInLadder(value=0)
   {
      piParticipatedInLadderNumber = value;
      return;
   }
   
   InitializeLadderChallengeData()
   {
      % Not enabled yet
      return;
      
      % At 10 challenges, green mace
      % At 20 challenges, green KS
      % At 30 challenges, green helmets
      % At 40 challenges, green royal shirt?
      
      % Challenge one: Use each type of shard on an item
      % Each entry is 0 for not used, 1 for used, in order of rarity
      plLadderChallengeData = Cons([0,0,0,0,0,0,0,0,0],plLadderChallengeData);
      
      % Challenge 2: Reach maximum health
      plLadderChallengeData = Cons([0],plLadderChallengeData);
      
      % Challenge 3: Reach over 200 maximum mana
      plLadderChallengeData = Cons([0],plLadderChallengeData);
      
      % Challenge 4: 
      plLadderChallengeData = Cons([0],plLadderChallengeData);
      
      % Challenge 5: open 100 treasure chests
      plLadderChallengeData = Cons([0],plLadderChallengeData);
      
      % Challenge 10: defeat a Marauder
      plLadderChallengeData = Cons([0],plLadderChallengeData);
      
      % Challenge four: Defeat historic Bosses
      % The lupogg king, the Ghost, the orc pit boss, 
     
     
      
      % Challenge forty: reach the end of the Endless Sea Palace
      
      return;
   }

   LadderChallengeCheck(type=USED_A_SHARD,oObject=$)
   {
      local i;
      
      % Not enabled yet
      return;
      
      if plLadderChallengeData = $
      {
         Send(self,@InitializeLadderChallengeData);
      }

      switch(type)
      {
         case USED_A_SHARD:
            if oObject <> $
               AND IsClass(oObject,&Shard)
               AND NOT IsClass(oObject,&HeartStone)
            {
               if Nth(Nth(plLadderChallengeData,1),Send(oObject,@GetRarity)) <> 1
               {
                  SetNth(Nth(plLadderChallengeData,1),Send(oObject,@GetRarity),1);
                  Send(self,@MsgSendUser,#message_rsc=ladder_two_challenge_used_a_shard,#parm1=Send(oObject,@GetName));
                  
                  if FindListElem(Nth(plLadderChallengeData,1),0) = 0
                  {
                     Send(self,@MsgSendUser,#message_rsc=ladder_two_challenge_one_complete);
                     piLadderNumChallengesCompleted++;
                  }
               }
            }
            break;
      }
      return;
   }

   ConvertPreserveSpecimenSpellToSkill()
   {
      local iAbility;
      
      if Send(self,@HasSpell,#num=SID_PRESERVE_SPECIMEN)
      {
         iAbility = Send(self,@GetSpellAbility,#spell_num=SID_PRESERVE_SPECIMEN);
         Send(self,@RemoveSpell,#num=SID_PRESERVE_SPECIMEN);
         Send(self,@AddSkill,#num=SKID_PRESERVE_SPECIMEN_SKILL,#iAbility=iAbility);
      }
      return;
   }

   GetSkillConfig(config_num=1)
   {
      if plSkillConfig = $
      {
         plSkillConfig = [1,1,1,1,1,1,1,1,1,1,1,1,1];
      }
      
      if config_num > Length(plSkillConfig)
      {
         return 1;
      }
      
      return Nth(plSkillConfig,config_num);
   }
   
   SetSkillConfig(config_num=1,value=1)
   {
      if plSkillConfig = $
      {
         plSkillConfig = [1,1,1,1,1,1,1,1,1,1,1,1,1];
      }
      
      if config_num > Length(plSkillConfig)
      {
         return;
      }
      
      SetNth(plSkillConfig,config_num,value);
   
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
