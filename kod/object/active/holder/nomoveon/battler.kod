% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Battler is NoMoveOn

constants:

   include blakston.khd
   include protocol.khd

   % Raise or lower this number to raise or lower the chance the 'avoids 
   %  your attack' message comes up.
   BATTLER_AVOID_CHANCE = 50  

   % Threshold for the "wound" and "damage" levels of feedback.
   DAMAGE_THRESHOLD_WOUND = 500
   DAMAGE_THRESHOLD_DAMAGE = 1500
   
   % Battlers take bleed damage periodically
   BLEED_TIME = 5000

resources:

   include battler.lkod

   % KNOWN BUG: placing a comment on the same line as a resource definition
   %  will comment out the next line.

   battler_blue_text = "~b"
   battler_plain_text = "~n"

   % battler_attacker_hit - Your scimitar wounds Psychochild for (10) damage.
   % battler_attacker_slay - Your scimitar slays Psychochild.
   % battler_attacker_miss - Your attack is blocked by Psychochild.
   % battler_attacker_fail - Your scimitar scrapes Psychochild, failing to cause any real harm.
   % battler_defender_hit - Psychochild's scimitar wounds you for (10) damage.
   % battler_defender_slay - Psychochild's scimitar slays you.
   % battler_defender_miss - Psychochild's attack is blocked by you.
   % battler_defender_fail - Psychochild's scimitar scrapes you, failing to cause any real harm.

   battler_attacker_hit = "%sYour %s %s %s%s%s for ~k~B%i~B%s damage."
   battler_attacker_slay = "%sYour %s %s %s%s%s."
   battler_attacker_miss = "%sYour attack %s %s%s%s."
   battler_attacker_fail = "%sYour %s %s %s%s%s, failing to cause any real harm."
   battler_defender_hit = "%s%s%s%s's %s %s you for ~r~B%i~B%s damage."
   battler_defender_slay = "%s%s%s%s's %s %s you."
   battler_defender_miss = "%s%s%s%s's attack %s you."
   battler_defender_fail = "%s%s%s%s's %s %s you, failing to cause any real harm."

   battler_punch = "punch"
   battler_attack = "attack"
   battler_blocked  = "is blocked by" 
   battler_dodged  = "is dodged by"
   battler_parried  = "is parried by"
   battler_misses = "misses"

   battler_fail = "barely touches"
   battler_nick = "nicks"
   battler_wound = "wounds"
   battler_damage = "damages"
   battler_slay = "slays"

   battler_acid_fail = "wets"
   battler_acid_nick = "burns"
   battler_acid_wound = "sears"
   battler_acid_damage = "disfigures"
   battler_acid_slay = "dissolves"

   battler_fire_fail = "warms"
   battler_fire_nick = "singes"
   battler_fire_wound = "chars"
   battler_fire_damage = "scorches"
   battler_fire_slay = "incinerates"

   battler_shock_fail = "tingles"
   battler_shock_nick =  "jolts"
   battler_shock_wound = "shocks"
   battler_shock_damage = "fries"
   battler_shock_slay = "electrocutes"

   battler_cold_fail = "refreshes"
   battler_cold_nick = "cools"
   battler_cold_wound = "chills"
   battler_cold_damage = "frosts"
   battler_cold_slay = "freezes"

   battler_holy_fail = "inspires"
   battler_holy_nick = "infuses"
   battler_holy_wound = "cleanses"
   battler_holy_damage = "exorcises"
   battler_holy_slay = "purifies"

   battler_unholy_fail = "unsettles"
   battler_unholy_nick = "maligns"
   battler_unholy_wound = "pollutes"
   battler_unholy_damage = "appalls"
   battler_unholy_slay = "corrupts"

   battler_illusion_fail = "perturbs"
   battler_illusion_nick = "dismays"
   battler_illusion_wound = "frightens"
   battler_illusion_damage = "terrifies"
   battler_illusion_slay = "deranges"

   battler_charm_fail = "repulses"
   battler_charm_nick = "intrigues"
   battler_charm_wound = "captivates"
   battler_charm_damage = "enchants"
   battler_charm_slay = "charms"
   
   battler_quake_fail = "startles"
   battler_quake_nick = "shakes"
   battler_quake_wound = "buffets"
   battler_quake_damage = "slams"
   battler_quake_slay = "flattens"

   battler_bite_fail = "nips"
   battler_bite_nick = "gnaws"
   battler_bite_wound = "bites"
   battler_bite_damage = "tears into"
   battler_bite_slay = "devours"

   battler_claw_fail = "scratches"
   battler_claw_nick = "claws"
   battler_claw_wound = "rakes"
   battler_claw_damage = "rends"
   battler_claw_slay = "shreds"

   battler_sting_fail = "annoys"
   battler_sting_nick = "irritates"
   battler_sting_wound = "stings"
   battler_sting_damage = "pricks"
   battler_sting_slay = "impales"

   battler_punch_fail = "nudges"
   battler_punch_nick = "slaps"
   battler_punch_wound = "pummels"
   battler_punch_damage = "mangles"
   battler_punch_slay = "thrashes"

   battler_slash_fail = "scrapes"
   battler_slash_nick = "cuts"
   battler_slash_wound = "slashes"
   battler_slash_damage = "maims"
   battler_slash_slay = "cleaves"

   battler_bludgeon_fail = "bonks"
   battler_bludgeon_nick = "bashes"
   battler_bludgeon_wound = "crushes"
   battler_bludgeon_damage = "smashes"
   battler_bludgeon_slay = "brutalizes"

   battler_thrust_fail = "tickles"
   battler_thrust_nick = "pokes"
   battler_thrust_wound = "stabs"
   battler_thrust_damage = "impales"
   battler_thrust_slay = "runs through"

   battler_pierce_fail = "bounces off of"
   battler_pierce_nick = "grazes"
   battler_pierce_wound = "pierces"
   battler_pierce_damage = "lacerates"
   battler_pierce_slay = "fells"

   battler_champion_none = ""

   rTumbleSoundOne = Swoosh01.wav
   rTumbleSoundTwo = Swoosh02.wav
   rTumbleSoundThree = Swoosh03.wav
   rTumbleSoundFour = Swoosh04.wav

   rActiveBlockSoundOne = SwrdMtl1.wav
   rActiveBlockSoundTwo = SwrdMtl2.wav
   rActiveBlockSoundThree = SwrdMtl3.wav
   rActiveBlockSoundFour = FlshHit2.wav
   
   backstab_sound = Knife-Slice.wav

   illusion_damage_heal_msg = "Hey!  Some of those wounds were illusionary!"
   
   knockback_message = \
      "~BYou knock %s%s away!"
   knocked_back_message = \
      "~B%s%s knocks you away!"
   stun_message = \
      "~BYour attack stuns %s%s!"
   stunned_message = \
      "~B%s%s stuns you!"
   bleed_message = \
      "~BYour attack leaves %s%s bleeding!"
   bleeded_message = \
      "~BYou begin to bleed!"

   tumble_success = "You tumble out of the way of %s%s's attack!"
   enemy_tumbled = "%s%s tumbles out of the way of your attack!"

classvars:

   viObject_flags = OF_ATTACKABLE

   viBattler_level = 50

   % A measure of size and mass. 5 is Baby spider, 200 is humanoid, 300 is troll, 600 is xeo, 4000 is ice dragon
   % This number generally can't be modified except by race (see GetSize).
   % Stun, knockback, bleed resistance can, however.
   % Players are resistant to knockback and stun while wearing plate armor, for example.
   viBaseSize = 200

   % A measure of base knockback effect on this battler. 100 is normal. 0 is immune. Numbers higher than 100 = more vulnerable.
   viBaseKnockbackPercentage = 100
   % A measure of base stun effect on this battler. 100 is normal. 0 is immune. Numbers higher than 100 = more vulnerable.
   viBaseStunPercentage = 100
   % A measure of base bleed effect on this battler. 100 is normal. 0 is immune. etc.
   viBaseBleedPercentage = 100
   
   % Some monsters are so big the enemy gets a range bonus.
   viEnemyRangeBonus = 0

properties:

   % Evil twin object
   poEvilTwin = $

   % List of active evil twins (i.e. ETs we've created).
   plEvilTwins = $

   % Apparition list and target
   plApparitionList = $
   poApparitionOriginal = $

   % Store minions
   plControlledMinions = $
   ptMinionControlCheck = $

   % list of resistances, Each element is [type, value].
   plResistances = $

   % List of enchantments.
   % Each element is [ timer, object of spell, [optional state] ].
   plEnchantments = $

   % Default mana values.
   piMana = 20
   piMax_Mana = 20

   % Mana regen timer.
   ptMana = $
   
   % Reputation hashtable for monster territory/influence system
   phReputation = $

   % Keeps track of who damaged this battler recently, and for how much.
   % Used to determine who logged / killed this monster or player.
   % Form [damager, amount, timer]
   plHurtMeRecently = $
   % 20 seconds default for players, 60 for monsters
   piHurtMeTime = 20000

   % Elemental status effects. Each element is [value, type]
   % Timer removes a portion of status effect every period
   plStatusEffects = $
   ptStatusEffectTimer = $

   % Negative values mean more vulnerable to hexes, positive values resist
   % -100 is doubled effect, 100 is total immunity
   piHexResistance = 0
   
   % Track periodic bleed damage
   ptBleedTimer = $

   % Is this Battler protected by a magical shield against projectiles?
   pbMagicalShield = FALSE
   % Fine units
   piMagicalShieldRadius = 64 * 5

   % Is this Battler suffering an Elemental Imbalance?
   % Always of the form [fire mod, shock mod, cold mod, acid mod]
   % Wears off after a short time (ptElementalImbalanceTimer)
   plElementalImbalance = $
   ptElementalImbalanceTimer = $
   
   plCreatureTypes = $
   
   % What ladder are we a part of?
   % Base game is 0
   % Challenge ladders will typically be 1
   piLadderID = 0
   
   % Keep track of bombs
   % Form [bomb object, time created in seconds]
   plBombs = $
   
   % Attacked, Was attacked, cast on someone, was cast on someone
   piLastTimeInCombat = 0
   
   % What element does this battler naturally rend?
   piRendType = 0
   piRendAmount = 0

messages:

   % The first lump of code here deals with resistances and immunities/etc.
   % They are included here in battler so both user and mobiles can enjoy
   %  the effect.

   TryDeflect(what=$, caster=$)
   {
      local oDeflect, oDeflectImpact, iResult, iSquaredFineDist;

      % what is a spell. Players get to try to deflect this with Deflect spell first.
      % Deflect has its own spell considerations.

      if IsClass(self,&Player)
      {
         oDeflect = Send(SYS,@FindSpellByNum,#Num=SID_DEFLECT);
         if Send(self,@IsEnchanted,#what=oDeflect)
         {
            if Send(oDeflect,@TryDeflect,#caster=caster,#victim=self,#oSpell=what)
            {
               oDeflectImpact = Create(&DeflectImpact,#iIntensity=125,#iColor=LIGHT_LIGHTNING,#oSpell=what,#oCaster=caster);
               Send(poOwner,@NewHold,#what=oDeflectImpact,#new_row=Send(self,@GetRow),
                                                          #new_col=Send(self,@GetCol),
                                                          #fine_row=Send(self,@GetFineRow),
                                                          #fine_col=Send(self,@GetFineCol));
               return oDeflectImpact;
            }
         }
      }
      
      % No deflect spell, or we're a monster? Let's make sure this only works vs projectile spells.

      if what = $
         OR Send(what,@GetProjectileIcon) = $
         OR IsClass(what,&RadiusProjectile)
      {
         return $;
      }

      if pbMagicalShield
      {
         if poOwner <> $
            AND caster <> $
         {
            iSquaredFineDist = Send(self,@SquaredFineDistanceTo,#what=caster);
            
            if iSquaredFineDist <> $
               AND iSquaredFineDist >= piMagicalShieldRadius * piMagicalShieldRadius
            {
               oDeflectImpact = Create(&DeflectImpact,#iIntensity=125,#iColor=LIGHT_LIGHTNING,#oSpell=what,#oCaster=caster);
               Send(poOwner,@NewHold,#what=oDeflectImpact,#new_row=Send(self,@GetRow),
                                                          #new_col=Send(self,@GetCol),
                                                          #fine_row=Send(self,@GetFineRow),
                                                          #fine_col=Send(self,@GetFineCol));
               
               if piMagicalShieldRadius > 0
               {
                  iResult = Send(poOwner,@IntraTeleport,#what=oDeflectImpact,
                                                        #type=INTRA_TELEPORT_TOWARD_DESTINATION,
                                                        #distance=piMagicalShieldRadius,
                                                        #new_row=Send(caster,@GetRow),
                                                        #new_col=Send(caster,@GetCol),
                                                        #fine_row=Send(caster,@GetFineRow),
                                                        #fine_col=Send(caster,@GetFineCol));
               }
               return oDeflectImpact;
            }
         }
      }

      return $;
   }

   Delete()
   {
      local i;
      
      Send(self,@ClearBombs);
      
      if ptBleedTimer <> $
      {
         DeleteTimer(ptBleedTimer);
      }
      ptBleedTimer = $;
      
      if ptMinionControlCheck <> $
      {
         DeleteTimer(ptMinionControlCheck);
      }
      ptMinionControlCheck = $;

      % Clear minion control list. Delete each of our minions
      % unless they are reflections, which are handled separately.
      % Deleted minions will remove themselves from our list, we
      % just need to let them know they're to be deleted.
      if plControlledMinions <> $
      {
         foreach i in plControlledMinions
         {
            if IsClass(i,&Monster)
            {
               Send(i,@Delete);
            }
         }
         plControlledMinions = $;
      }

      % If this Battler has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         foreach i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      % If this Battler has an Evil Twin, delete it too.
      if poEvilTwin <> $
      {
         Send(poEvilTwin,@Delete);
      }

      % If this Battler has Apparitions attacking it, delete them.
      if plApparitionList <> $
      {
         foreach i in plApparitionList
         {
            Send(i,@Delete);
         }
         plApparitionList = $;
      }

      if plHurtMeRecently <> $
      {
         foreach i in plHurtMeRecently
         {
            if IsTimer(Nth(i,3))
            {
               DeleteTimer(Nth(i,3));
            }
            SetFirst(i,$);
            SetNth(i,2,$);
            SetNth(i,3,$);
            plHurtMeRecently = DelListElem(plHurtMeRecently,i);
         }
      }

      Send(self,@ClearAllStatusEffects);

      propagate;
   }

   ReqNewOwner(what = $)
   {
      return IsClass(what,&Room);
   }

   SayDyingWords(what=$)
   {
      return FALSE;
   }

   IsLikelyVictim()
   {
      % nearly all battlers can be attacked by a monster without provocation
      return TRUE;
   }

   IsUndead()
   {
      return FALSE;
   }

   % This checks if the battler can completely resist the effects of the spell.
   %  By default, the spell is not resisted.
   SpellResist(oSpell=$,who=$,iSpellpower=$)
   {
      return FALSE;
   }

   GetBaseResistances()
   "Monster.kod and player.kod overwrite this in custom ways."
   {
      return $;
   }

   GetCurrentResistances()
   "Spells and items can change resistances temporarily."
   {
      local oObjectAttribute, lCurResist, oEquipment, oEnchantment,
            iHumbled, iHumbledDivisor, i, iCorrode, iCorrodeDivisor,
            oGuild, oGuildHall, oRelic, lElementalImbalance;

      lCurResist = ListCopy(Send(self,@GetBaseResistances));
      
      if IsClass(self,&Monster)
         AND poOwner <> $
         AND IsClass(poOwner,&ChaosStratumRoom)
      {
         lCurResist = Send(poOwner,@ChaosModifyResistance,#resistance_list=lCurResist);
      }

      foreach lElementalImbalance in Send(self,@GetElementalImbalance)
      {
         lCurResist = Send(SYS,@AddResistance,#what=Nth(lElementalImbalance,1),
                                              #value=Nth(lElementalImbalance,2),
                                              #resistance_list=lCurResist);
      }

      foreach oObjectAttribute in plObject_attributes
      {
         lCurResist = Send(oObjectAttribute,@ModifyResistance,
                           #resistance_list=lCurResist);
      }

      foreach oEquipment in Send(self,@GetEquippedItems)
      {
         lCurResist = Send(oEquipment,@ModifyResistance,
                           #resistance_list=lCurResist);
      }

      foreach oEnchantment in Send(self,@GetEnchantmentList)
      {
         if Length(oEnchantment) > ENCHANTMENT_LIST_NO_STATE
         {
            lCurResist = Send(Nth(oEnchantment,2),@ModifyResistance,
                              #resistance_list=lCurResist,
                              #iState=Nth(oEnchantment,3));
         }
         else
         {
            lCurResist = Send(Nth(oEnchantment,2),@ModifyResistance,
                              #resistance_list=lCurResist);
         }
      }

      if IsClass(self,&Player)
      {
         foreach oEnchantment in Send(self,@GetReservedSpells)
         {
            lCurResist = Send(Nth(oEnchantment,1),@ModifyResistance,#resistance_list=lCurResist,#iState=Nth(oEnchantment,3));
         }
      }

      if IsClass(self,&Player)
         AND Send(self,@GetLadderID) = 0
      {
         oGuild = Send(self,@GetGuild);
         if oGuild <> $
         {
            oGuildHall = Send(oGuild,@GetGuildHall);
            if oGuildHall <> $
            {
               foreach oRelic in Send(oGuildHall,@GetRelicList)
               {
                  lCurResist = Send(oRelic,@ModifyResistance,#resistance_list=lCurResist);
               }
            }
         }
      }

      lCurResist = Send(self,@ApplyMaximumResistances,#resistance_list=lCurResist);

      iHumbled = Send(self,@GetStatusEffect,#type=STATUS_HUMBLED);
      if iHumbled > 0
      {
         iHumbledDivisor = Send(SETTINGS_OBJECT,@GetElementalMultiple,
                           #type=STATUS_HUMBLED);
         
         foreach i in lCurResist
         {
            if Nth(i,2) > 0
               AND Nth(i,1) < 0
            {
               SetNth(i,2,bound(Nth(i,2) - (iHumbled/iHumbledDivisor),0,$));
            }
         }
      } 

      iCorrode = Send(self,@GetStatusEffect,#type=STATUS_CORRODE);
      if iCorrode > 0
      {
         iCorrodeDivisor = Send(SETTINGS_OBJECT,@GetElementalMultiple,
                           #type=STATUS_CORRODE);
         
         foreach i in lCurResist
         {
            if Nth(i,2) > 0
               AND Nth(i,1) > 0
            {
               SetNth(i,2,bound(Nth(i,2) - (iCorrode/iCorrodeDivisor),0,$));
            }
         }
      } 

      return lCurResist;
   }

   ApplyMaximumResistances(resistance_list=$)
   {
      local oResist;

      foreach oResist in resistance_list
      {
         SetNth(oResist,2,Bound(Nth(oResist,2),MIN_RESISTANCE,Send(SETTINGS_OBJECT,@GetGeneralMaxResistance)+Send(self,@GetMaxResistanceMod,#type=Nth(oResist,1))));
      }

      return resistance_list;
   }

   GetMaxResistanceMod(type=-ATCK_SPELL_FIRE)
   {
      return 0;
   }

   GetEquippedItems()
   "Support for items equipped by players, but also some monsters, such as troops."
   {
      return $;
   }

   ResistanceCheck(atype = 0, aspell = 0, what=$)
   "Given bitvectors of attack type and spell, find the resistance modifier "
   "which applies. Largest resistance plus worst weakness gives the modifier."
   {
      local j, iResType, iMaxRes, iMinRes, iResistance, resistance_list,
         iWeaponResist, iMagicResist, iCombinedPrimaryResist, iFinalRes, bEleZero, lRend;

      iMaxRes = NO_RESISTANCE;
      iMinRes = NO_RESISTANCE;
      
      if what <> $
         AND IsClass(what,&Player)
         AND Send(what,@IsUsingA,#class=&SorceryCrest)
      {
         bEleZero = TRUE;
      }
      else
      {
         bEleZero = FALSE;
      }
      
      resistance_list = Send(self,@GetCurrentResistances);

      lRend = [0,0];
      if what <> $
      {
         lRend = Send(what,@GetRend,#victim=self,#resistance_list=resistance_list);
      }

      if Send(SETTINGS_OBJECT,@GetDirectArmorEnabled)
      {
         foreach j in resistance_list
         {
            iResType = Nth(j,1);
            if iResType > 0   
            {
               % It's a resistance to weapon type

               if (atype & iResType) <> 0
                  OR (atype <> 0 AND iResType = ATCK_WEAP_ALL)
               {
                  iResistance = Nth(j,2);

                  if iResistance > iMaxRes
                  {
                     iMaxRes = iResistance;
                  }

                  if iResistance < iMinRes
                  {
                     iMinRes = iResistance;
                  }
               }
            }
            else
            {
               % It's a resistance to spell type
               iResType = -iResType;

               if (aspell & iResType) <> 0
                  OR ((aspell <> 0 AND iResType = ATCK_SPELL_ALL)
                     AND NOT (aspell & ATCK_SPELL_DRAIN))
               {
                  iResistance = Nth(j,2);

                  if iResistance > iMaxRes
                  {
                     iMaxRes = iResistance;
                  }

                  if iResistance < iMinRes
                  {
                     iMinRes = iResistance;
                  }
               }
            }
         }

         % clip to max/min values
         iMaxRes = bound(iMaxRes,$,MAX_RESISTANCE);
         iMinRes = bound(iMinRes,MIN_RESISTANCE,$);

         return iMaxRes + iMinRes;
      }
      
      iWeaponResist = 0;
      iMagicResist = 0;
      foreach j in resistance_list
      {
         iResType = Nth(j,1);
         if iResType > 0
         {
            % It's a resistance to weapon type
            if iResType = ATCK_WEAP_ALL
               AND atype <> 0
            {
               iWeaponResist = Nth(j,2);
               
               if (iResType & Nth(lRend,1)) <> 0
               {
                  iWeaponResist = iWeaponResist - Nth(lRend,2);
               }
               continue;
            }

            if (atype & iResType) <> 0
            {
               iResistance = Nth(j,2);
               
               if (iResType & Nth(lRend,1)) <> 0
               {
                  iResistance = iResistance - Nth(lRend,2);
               }

               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }

               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
         else
         {
            % It's a resistance to spell type
            iResType = -iResType;

            if iResType = ATCK_SPELL_ALL
               AND aspell <> 0
            {
               iMagicResist = Nth(j,2);
               
               if (iResType & Nth(lRend,1)) <> 0
               {
                  iMagicResist = iMagicResist - Nth(lRend,2);
               }
               continue;
            }
            
            if (aspell & iResType) <> 0
            {
               iResistance = Nth(j,2);
               
               if (iResType & Nth(lRend,1)) <> 0
               {
                  iResistance = iResistance - Nth(lRend,2);
               }

               if bEleZero
                  AND (iResType = ATCK_SPELL_SHOCK
                     OR iResType = ATCK_SPELL_FIRE
                     OR iResType = ATCK_SPELL_COLD
                     OR iResType = ATCK_SPELL_ACID
                     OR iResType = ATCK_SPELL_HOLY
                     OR iResType = ATCK_SPELL_UNHOLY)
               {
                  iResistance = iResistance - 25;
               }

               if iResistance > iMaxRes
               {
                  iMaxRes = iResistance;
               }
               
               if iResistance < iMinRes
               {
                  iMinRes = iResistance;
               }
            }
         }
      }
      
      if iWeaponResist <> 0
         AND iMagicResist <> 0
      {
         % Partially magical attacks halve both primary resistances,
         %    but are also reduced by both.
         iWeaponResist = iWeaponResist/2;
         iMagicResist = iMagicResist/2;
      }
      
      iCombinedPrimaryResist = bound(iWeaponResist + iMagicResist,
                                        MIN_RESISTANCE,MAX_RESISTANCE);
      iFinalRes = bound(iMaxRes + iMinRes,MIN_RESISTANCE,MAX_RESISTANCE);

      iFinalRes = 100 - (((100-iCombinedPrimaryResist) * (100-iFinalRes))/100);

      return bound(iFinalRes,MIN_RESISTANCE,MAX_RESISTANCE);
   }

   GetDamageFromResistance(what = 0, value = $)
   "Adjust <what> damage according to the value multiplier"
   {
      local iDamage;

      if value > NO_RESISTANCE
      {
         iDamage = what * (MAX_RESISTANCE - value) / MAX_RESISTANCE;
      }
      else
      {
         iDamage = what * (MIN_RESISTANCE + value) / MIN_RESISTANCE;
      }

      return iDamage;
   }

   %%% Spell enchantment functions.

   RemoveEnchantmentClass(class = &Object, report=TRUE)
   "If have a current enchantment set by anything in class, end it."
   {
      local i, state, removedSomething;

      removedSomething = FALSE;

      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),class)
         {
            removedSomething = TRUE;
            if First(i) <> $
            {
               DeleteTimer(First(i));
               SetNth(i,1,$);
            }

            if Length(i) >= ENCHANTMENT_LIST_STATE
               OR IsClass(Nth(i,2),&Boon)
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#state=state,
                  #report=report);

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i);
            Send(self,@ResetPlayerFlagList,#who=self);
         }
      }

      return removedSomething;
   }

   ShowRemoveEnchantment()
   "User overrides this to send data to the client."
   {
      return;
   }

   ResetPlayerFlagList()
   {
      return;
   }

   IsEnchanted(what=$,byClass=&Spell)
   "Returns whether or not currently enchanted by <what>."
   {
      local i;

      if what = $
      {
         foreach i in plEnchantments
         {
            if IsClass(Nth(i,2),byClass)
            {
               return TRUE;
            }
         }
      }
      else
      {
         return GetListNode(plEnchantments, 2, what) <> $;
      }

      return FALSE;
   }

   GetRawState(what=$)
   "This message is needed to smoothly handle the transition from 3-element "
   "enchantment list elements to 4-element ones.  When EndEnchantment is "
   "called during RecreateAll, spells that modify stats (and are cast with "
   "the old system) need to be able to obtain the correct state.  This is the "
   "safest way to ensure the stats are reset correctly, and should be removed "
   "after the transition."
   {
      local i;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
            AND Length(i) > 2
         {
            return Nth(i,3);
         }
      }

      return $;
   }

   GetEnchantedState(what=$)
   "If enchanted by <what>, returns the state data (which MUST exist, or it's an error.  "
   "In other words, the caller must know that <what> adds state data).  Returns $ otherwise."
   {
      local i;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
            AND Length(i) > ENCHANTMENT_LIST_NO_STATE
         {
            return Nth(i,3);
         }
      }

      return $;
   }

   GetEnchantmentsByClass(enchClass=&Spell)
   "Returns a subset of plEnchantments whose elements are of the given class."
   {
      local i, returnList;
      returnList = $;

      foreach i in plEnchantments
      {
         if IsClass(Nth(i,2),enchClass)
         {
            returnList = Cons(i,returnList);
         }
      }

      return returnList;
   }

   GetEnchantmentList()
   {
      return plEnchantments;
   }

   GetCastPower(what=$)
   "This is used by purge to get the spellpower the personal enchantment was "
   "cast at. Put in Battler instead of Player as we may use this for monster "
   "buffs one day."
   {
      local lEnch;

      if what = $
      {
         Debug("GetCastPower called with $ spell!");

         return 0;
      }

      lEnch = GetListNode(plEnchantments, 2, what);
      if lEnch <> $
      {
         if Length(lEnch) > ENCHANTMENT_LIST_NO_STATE
         {
            return Nth(lEnch,4);
         }
         else
         {
            return Nth(lEnch,3);
         }
      }

      Debug("GetCastPower couldn't find enchantment ",what);

      return 0;
   }

   %%% Mana related stuff common to players and mobs.

   GetMaxMana()
   {
      return piMax_mana;
   }

   GetMana()
   {
      return piMana;
   }

   ManaTimer()
   {
      ptMana = $;

      if piMana < piMax_mana
      {
         if IsClass(self,&Player)
            AND Send(self,@IsResting)
            AND Send(self,@HasSkill,#num=SKID_SIRSASANA)
         {
            Send(self,@GainMana,#amount=Send(Send(SYS,@FindSkillByNum,#num=SKID_SIRSASANA),@ModifyRejuvenation,#who=self,#iAmount=1),#bCapped=TRUE);
            return;
         }
         Send(self,@GainMana,#amount=1);
      }
      else
      {
         Send(self,@LoseMana,#amount=1);
      }

      return;
   }

   LoseMana(amount = 0)
   {
      local iManaLost;

      if IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode)
      {
         Send(self,@NewMana);

         return 0;
      }

      piMana = piMana - amount;
      if piMana < 0
      {
         iManaLost = amount - abs(piMana);
      }
      else
      {
         iManaLost = amount;
      }

      Send(self,@NewMana);

      return iManaLost;
   }

   GainMana(amount=0, bCapped=FALSE, bRespectMax=FALSE)
   {
      local iManaGained;

      iManaGained = amount;

      if IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode)
      {
         Send(self,@NewMana);

         return 0;
      }

      if bRespectMax
         AND piMana + amount > piMax_mana
      {
         return 0;
      }

      piMana = piMana + amount;

      if bCapped AND piMana > piMax_Mana
      {
         iManaGained = amount - (piMana - piMax_Mana);
         piMana = piMax_Mana;
      }

      Send(self,@NewMana);

      return iManaGained;
   }

   NewMana()
   {
      if piMana < 0
      {
         piMana = 0;
      }

      if piMana <> piMax_mana AND ptMana = $
      {
         ptMana = CreateTimer(self,@ManaTimer,Send(self,@CalculateManaTime));
      }

      if piMana = piMax_mana AND ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if IsClass(self,&Player)
      {
         Send(self,@DrawMana);
      }

      return;
   }

   %%% Combat functionality.

   % All conditions have been checked at this point and the battler is eligible
   % to attack his target. TryAttack figures out whether he hits the target
   % based on his offense and the target's defense and passes this information
   % on to AssessDamage, AssessHit/AssessMiss etc.
   %
   % NOTES on settings: piEqualChanceToHit, piBaseRating and piDamageScaling can
   % be adjusted in settings.kod to tweak the calculations.
   % piEqualChanceToHit: This is the chance for an attacker to hit his target if
   % his defense equals the target's offense. A setting of 500 is equivalent to 
   % a 50 percent chance to hit.
   % piBaseRating: This is a flat number that serves as a base value for defense
   % and offense, softening the effect of any modifiers and avoiding
   % pathological ratios when one of the two battler's rating is extremely low.
   % piDamageScaling: This allows damage to scale when chance to hit exceeds 100
   % percent, allowing offense to be useful even when the target has very low
   % defense and we hit with every attack. People are less and less likely to 
   % run into this cap as piBaseRating is increased though.
   %
   % NOTE: For a monster, the stroke_obj is the monster itself for now.
   TryAttack(what = $,stroke_obj=$)
   {
      local iOffense, iDefense, iChanceToHit, iDamage, iScalefactor, oWeapon,
            iBackstabDamage, bDoingBackstab, iBeatThisCheck, iIncreasedEvadeChance,
            iIncreasedHitChance;
      
      Send(what,@MarkLastTimeInCombat);
      Send(self,@MarkLastTimeInCombat);

      oWeapon = Send(self,@GetWeapon);

      iOffense = Send(self,@GetOffense,#what=what,#stroke_obj=stroke_obj) 
         + Send(SETTINGS_OBJECT,@GetBaseRating);
      iDefense = Send(what,@GetDefense,#what=self,#stroke_obj=stroke_obj) 
         + Send(SETTINGS_OBJECT,@GetBaseRating);
      iChanceToHit = iOffense * Send(SETTINGS_OBJECT,@GetEqualChanceToHit) / iDefense;
      iChanceToHit = bound(iChanceToHit,125,2000);

      if IsClass(what,&Player)
         AND NOT Send(what,@IsResting)
         AND Send(what,@GetStance) <> $
         AND (IsClass(Send(what,@GetStance),&ActiveBlockingStance)
            OR IsClass(Send(what,@GetStance),&ActiveParryingStance))
      {
         if Send(Send(what,@GetStance),@AttemptActiveBlock,#who=what,#what=self)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(self,@GetActiveBlockSound));
            return FALSE;
         }
         else if Send(Send(what,@GetStance),@AttemptActiveParry,#who=what,#what=self,#stroke_obj=stroke_obj)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(self,@GetActiveBlockSound));
            return FALSE;
         }
         else
         {
            % Guaranteed hit if player fails active blocking and parrying.
            % Defense + active blocking would be way too strong.
            % However, tumbling will still allow a chance to not get hit.
            iChanceToHit = 1000;
         }
      }
      
      iIncreasedEvadeChance = Send(Send(SYS,@FindSkillByNum,#num=SKID_TUMBLE),@GetTumblePercentage,#who=what,#what=self)
                              + (Send(what,@GetAgility)*Send(SETTINGS_OBJECT,@GetAgilityEvadeNumerator))/Send(SETTINGS_OBJECT,@GetAgilityEvadeDivisor);
      iIncreasedHitChance = Send(Send(SYS,@FindSkillByNum,#num=SKID_WEAPONMASTER),@GetWeaponmasterPercentage,#who=self,#what=what)
                            + (Send(self,@GetAim)*Send(SETTINGS_OBJECT,@GetAimHitNumerator))/Send(SETTINGS_OBJECT,@GetAimHitDivisor);

      iChanceToHit = iChanceToHit + iIncreasedHitChance;

      iBeatThisCheck = Random(1,1000);
      if iChanceToHit >= iBeatThisCheck
         AND iChanceToHit - iIncreasedEvadeChance < iBeatThisCheck
      {
         % This attack would have worked if not for our tumble percentage
         if IsClass(what,&Player)
         {
            Send(what,@MsgSendUser,#message_rsc=tumble_success,#parm1=Send(self,@GetDef),#parm2=Send(self,@GetName));
            Send(Send(SYS,@FindSkillByNum,#num=SKID_TUMBLE),@ImproveAbility,#who=what);
         }
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetTumbleSound));
         if IsClass(self,&Player)
         {
            Send(self,@MsgSendUser,#message_rsc=enemy_tumbled,#parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
         return FALSE;
      }

      if iChanceToHit >= iBeatThisCheck
         OR (IsClass(self,&Player)
             AND Send(Send(SYS,@FindSkillByNum,#num=SKID_SNEAK),
                       @IsSneaking,#who=self)
             AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),
                       @IsHiding,#who=self)
             AND Send(self,@GetSkillAbility,#skill_num=SKID_BACKSTAB) > 0
             AND Send(Send(SYS,@FindSkillByNum,#num=SKID_BACKSTAB),
                       @TryAutomaticHit,#who=self,#what=what))
         OR (IsClass(what,&Player) AND Send(what,@IsResting))
      {
         % We hit!
         iDamage = Send(self,@GetDamage,#what=what,#stroke_obj=stroke_obj);
         iScalefactor = 1000;
         
         % Scale damage with chance to hit beyond 100 percent.
         if iChanceToHit > 1000 AND Send(SETTINGS_OBJECT,@GetDamageScaling)
         {
            iScalefactor = iChanceToHit;
         }

         bDoingBackstab = FALSE;
         if IsClass(self,&Player)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_BACKSTAB) > 0
            AND Send(Send(SYS,@FindSkillByNum,#num=SKID_SNEAK),
                      @IsSneaking,#who=self)
            AND Send(Send(SYS,@FindSkillByNum,#num=SKID_HIDE),
                      @IsHiding,#who=self)
         {
            iDamage = Send(self,@GetDamage,#what=what,#stroke_obj=stroke_obj,#bDoingBackstab=TRUE);
            iBackstabDamage = Send(Send(SYS,@FindSkillByNum,
                                    #num=SKID_BACKSTAB),
                                    @LastPriorityModifyDamage,#who=self,
                                    #what=what,#damage=iDamage);
            if iBackstabDamage > 0
            {
               iDamage = iBackstabDamage;
               bDoingBackstab = TRUE;
               
               if IsClass(self,&Player)
               {
                  Send(poOwner,@SomethingWaveRoom,#what=what,
                        #wave_rsc=backstab_sound);
               }
            }
         }

         iDamage = Send(what,@AssessDamage,#what=self,#damage=iDamage,
            #atype=Send(self,@GetDamageType,#stroke_obj=stroke_obj),
            #aspell=Send(self,@GetSpellType,#stroke_obj=stroke_obj,#damaging_now=TRUE),
            #scalefactor=iScalefactor,#precision=TRUE,
            #damaging_now=TRUE,#bDoingBackstab=bDoingBackstab);

         Send(self,@AssessHit,#what=what,#stroke_obj=stroke_obj,#damage=iDamage);

         if iDamage = $
         {
            Send(self,@KilledSomething,#what=what,#use_weapon=oWeapon,#stroke_obj=stroke_obj,#bDoingBackstab=bDoingBackstab);
         }
         else
         {
            Send(self,@DidDamage,#amount=iDamage,#what=what,#stroke_obj=stroke_obj);
         }
      }
      else
      {
         % Oops, a miss.  See if something happens.
         Send(self,@AssessMiss,#what=what,#stroke_obj=stroke_obj);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
              #use_weapon=oWeapon);
      }

      return TRUE;
   }

   GetLevel()
   {
      return 65;
   }

   GetOffense(what = $, stroke_obj=$)
   "Returns the battler's ability to-hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDefense(what = $, stroke_obj=$)
   "Returns the battler's ability to avoid being hit.  Ranges from 1 to 3000."
   {
      return 1;
   }

   GetDamage(what = $, stroke_obj=$, bDoingBackstab=FALSE)
   "Returns the damage done to target 'what'."
   {
      return 0;
   }

   GetDamageType(what = $)
   "Returns the weapon type of damage done."
   {
      % Default type for the stub function.
      return ATCK_WEAP_HIT;
   }

   GetSpellType(what = $)
   "This is the magical type of damage done."
   {
      % Default, no spells
      return 0;
   }

   AssessDamage(what = $,damage = $,atype = $, aspell = $)
   "This applies damage to the battler, calculating appropriate resistances.  "
   "Return $ if we were killed."
   {
      return 0;
   }

   GetDamageDesc(damage=0, type=0)
   "This returns the severity of damage by type.  Gives a verb descriptor."
   {
      % For each type, Send unique words to describe the damage
      if type < 0
      {
         type = -type;
         if (type & ATCK_SPELL_FIRE)
         {
            if damage = $
            {
               return battler_fire_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_fire_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_fire_wound;
            }

            if damage > 99
            {
               return battler_fire_nick;
            }

            return battler_fire_fail;
         }

         if (type & ATCK_SPELL_SHOCK)
         {
            if damage = $
            {
               return battler_shock_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_shock_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_shock_wound;
            }

            if damage > 99
            {
               return battler_shock_nick;
            }

            return battler_shock_fail;
         }

         if (type & ATCK_SPELL_COLD)
         {
            if damage = $
            {
               return battler_cold_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_cold_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_cold_wound;
            }

            if damage > 99
            {
               return battler_cold_nick;
            }

            return battler_cold_fail;
         }

         if (type & ATCK_SPELL_ACID)
         {
            if damage = $
            {
               return battler_acid_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_acid_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_acid_wound;
            }

            if damage > 99
            {
               return battler_acid_nick;
            }

            return battler_acid_fail;
         }

         if (type & ATCK_SPELL_HOLY)
         {
            if damage = $
            {
               return battler_holy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_holy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_holy_wound;
            }

            if damage > 99
            {
               return battler_holy_nick;
            }

            return battler_holy_fail;
         }

         if (type & ATCK_SPELL_UNHOLY)
         {
            if damage = $
            {
               return battler_unholy_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_unholy_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_unholy_wound;
            }

            if damage > 99
            {
               return battler_unholy_nick;
            }

            return battler_unholy_fail;
         }

         if (type & ATCK_SPELL_QUAKE)
         {
            if damage = $
            {
               return battler_quake_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_quake_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_quake_wound;
            }

            if damage > 99
            {
               return battler_quake_nick;
            }

            return battler_quake_fail;
         }

         if (type & ATCK_SPELL_ILLUSION)
         {
            if damage = $
            {
               return battler_illusion_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_illusion_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_illusion_wound;
            }

            if damage > 99
            {
               return battler_illusion_nick;
            }

            return battler_illusion_fail;
         }

         if (type & ATCK_SPELL_CHARM)
         {
            if damage = $
            {
               return battler_charm_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_charm_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_charm_wound;
            }

            if damage > 99
            {
               return battler_charm_nick;
            }

            return battler_charm_fail;
         }
      }
      else
      {
         if (type & ATCK_WEAP_BITE)
         {
            if damage = $
            {
               return battler_bite_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bite_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bite_wound;
            }

            if damage > 99
            {
               return battler_bite_nick;
            }

               return battler_bite_fail;
         }

         if (type & ATCK_WEAP_CLAW)
         {
            if damage = $
            {
               return battler_claw_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_claw_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_claw_wound;
            }

            if damage > 99
            {
               return battler_claw_nick;
            }

            return battler_claw_fail;
         }

         if (type & ATCK_WEAP_STING)
         {
            if damage = $
            {
               return battler_sting_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_sting_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_sting_wound;
            }

            if damage > 99
            {
               return battler_sting_nick;
            }

            return battler_sting_fail;
         }

         % Repeat the acid spell words here
         if (type & ATCK_WEAP_ACID)
         {
            if damage = $
            {
               return battler_acid_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_acid_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_acid_wound;
            }

            if damage > 99
            {
               return battler_acid_nick;
            }

            return battler_acid_fail;
         }

         if (type & ATCK_WEAP_PUNCH)
         {
            if damage = $
            {
               return battler_punch_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_punch_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_punch_wound;
            }

            if damage > 99
            {
               return battler_punch_nick;
            }

            return battler_punch_fail;
         }

         if (type & ATCK_WEAP_SLASH)
         {
            if damage = $
            {
               return battler_slash_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_slash_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_slash_wound;
            }

            if damage > 99
            {
               return battler_slash_nick;
            }

            return battler_slash_fail;
         }

         if (type & ATCK_WEAP_BLUDGEON)
         {
            if damage = $
            {
               return battler_bludgeon_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_bludgeon_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_bludgeon_wound;
            }

            if damage > 99
            {
               return battler_bludgeon_nick;
            }   

            return battler_bludgeon_fail;
         }

         if (type & ATCK_WEAP_THRUST)
         {
            if damage = $
            {
               return battler_thrust_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_thrust_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_thrust_wound;
            }

            if damage > 99
            {
               return battler_thrust_nick;
            } 

            return battler_thrust_fail;
         }

         if (type & ATCK_WEAP_PIERCE)
         {
            if damage = $
            {
               return battler_pierce_slay;
            }

            if damage > DAMAGE_THRESHOLD_DAMAGE
            {
               return battler_pierce_damage;
            }

            if damage > DAMAGE_THRESHOLD_WOUND
            {
               return battler_pierce_wound;
            }

            if damage > 99
            {
               return battler_pierce_nick;
            }
            
            return battler_pierce_fail;
         }
      }
      
      % Use these as the "default"
      if damage = $
      {
         return battler_slay;
      }

      if damage > DAMAGE_THRESHOLD_DAMAGE
      {
         return battler_damage;
      }

      if damage > DAMAGE_THRESHOLD_WOUND
      {
         return battler_wound;
      }

            if damage > 99
      {
         return battler_nick;
      }

      return battler_fail;
   }

   % This returns defense reason of why opponent missed this battler.
   GetDefenseDesc(stroke_obj=$)
   {
      local iRandom, iParry, iBlock, iDodge;
      
      iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);
      iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);
      iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);
      iRandom = iParry + iBlock + iDodge + BATTLER_AVOID_CHANCE;
      iRandom = random(0,iRandom);

      if iRandom < iParry
      {
         return battler_parried;
      }

      if iRandom < (iParry + iBlock)
      {
         return battler_blocked;
      }

      if iRandom < (iParry + iBlock + iDodge)
      {
         return battler_dodged;
      }
      
      return battler_misses;
   }

   % The next three messages deal with the three defense skills.  These
   %  messages return the relative values of the three skills.  Used in
   %  player for defense, used in battler for defense messages.

   GetParryAbility(stroke_obj=$)
   {
      return 0;
   }

   GetBlockAbility(stroke_obj=$)
   {
      return 0;
   }

   GetDodgeAbility(stroke_obj=$)
   {
      return 0;
   }

   AssessHit(what = $, stroke_obj = $, damage = $, use_weapon=$)
   "This does the fallout of a hit, gives appropriate message, etc.  "
   "Called on self when hit opponent."
   {
      local rColor, oWeapon, rWeaponName, iDmg, rDamageDesc, iType;

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         rWeaponName = battler_punch;
      }
      else
      {
         % This returns the name of a melee weapon, the ammo of a ranged
         %  weapon, or the attack name for a monster.
         rWeaponName = Send(oWeapon,@GetAttackName);
      }
      
      if stroke_obj <> $
         AND IsClass(stroke_obj,&Throw)
      {
         rWeaponName = Send(stroke_obj,@GetAttackName);
      }

      % Spell types are usually represented by negative values, to
      %  differentiate between physical and spell damage.
      if IsClass(self,&Monster)
      {
         if use_weapon <> $
         {
            % Might be a spell.
            iType = Send(use_weapon,@GetAttackSpell);
         }
         else
         {
            % Use ourselves as default.
            iType = Send(self,@GetSpellType);
         }
      }
      else
      {
         iType = Send(self,@GetSpellType,#use_weapon=use_weapon,#stroke_obj=stroke_obj);
      }

      % We only want to use a unique word if the spell damage is NOT generic
      %  or Hunter sword damage.  Otherwise, use the physical damage type.
      if (iType & (~ATCK_SPELL_HUNTERSWORD | ~ATCK_SPELL_ALL)) = 0
      {
         iType = Send(self,@GetDamageType,#use_weapon=use_weapon,#stroke_obj=stroke_obj);
      }
      else
      {
         % Make it negative to distinguish between physical types.
         iType = -iType;
      }

      if IsClass(what,&Player)
         AND damage <> $
         AND damage >= (Send(what,@GetMaxHealth)*33)
      {
         % If we did at least 1/3 a player's hps in damage, then give
         %  the best damage message.
         iDmg = (DAMAGE_THRESHOLD_DAMAGE + 1);
      }
      else
      {
         iDmg = damage;
      }

      rDamageDesc = Send(self,@GetDamageDesc,#damage=iDmg,#type=iType);      
      rColor = battler_blue_text;

      if IsClass(self,&Player)
      {
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            % Don't use "punch" if we're morphed, use a more generic term.
            if oWeapon = $
            {
               rWeaponName = battler_attack;
            }
         }


         if IsClass(what,&Player)
            AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }

         if what <> self
         {
            if damage = $
            {
               Send(self,@MsgSendUser,#message_rsc=battler_attacker_slay,
               #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
               #parm4=Send(what,@GetDef),#parm5=Send(what,@GetChampString),
               #parm6=Send(what,@GetName));
            }
            else
            {
               if damage > 99
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_hit,
                  #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
                  #parm4=Send(what,@GetDef),#parm5=Send(what,@GetChampString),
                  #parm6=Send(what,@GetName),
                  #parm7=damage/100,#parm8=rColor);
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=battler_attacker_fail,
                  #parm1=rColor,#parm2=rWeaponName,#parm3=rDamageDesc,
                  #parm4=Send(what,@GetDef),#parm5=Send(what,@GetChampString),
                  #parm6=Send(what,@GetName));
               }
            }
         }
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player)
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }

         if damage = $
         {
            Send(what,@MsgSendUser,#message_rsc=battler_defender_slay,
              #parm1=rColor,#parm2=Send(self,@GetCapDef),
              #parm3=Send(self,@GetChampString),
              #parm4=Send(self,@GetName),#parm5=rWeaponName,
              #parm6=rDamageDesc);
         }
         else
         {
            if damage > 99
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_hit,
                 #parm1=rColor,#parm2=Send(self,@GetCapDef),
                 #parm3=Send(self,@GetChampString),
                 #parm4=Send(self,@GetName),#parm5=rWeaponName,
                 #parm6=rDamageDesc,#parm7=damage/100,#parm8=rColor);
            }
            else
            {
               Send(what,@MsgSendUser,#message_rsc=battler_defender_fail,
                 #parm1=rColor,#parm2=Send(self,@GetCapDef),
                 #parm3=Send(self,@GetChampString),
                 #parm4=Send(self,@GetName),#parm5=rWeaponName,
                 #parm6=rDamageDesc);
            }
         }
      }

      return;
   }

   AssessMiss(what = $, stroke_obj = $)
   "This does the fallout of a miss, gives appropriate message, etc. "
   "Called on self when missing."
   {
      local rColor;

      % This is kinda kludgy, should call messages in subclasses instead.
      if IsClass(self,&Player)
      {
         Send(self,@SetLeapKnockback,#value=FALSE);

         if IsClass(what,&Player) AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED) 
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }

         Send(self,@MsgSendUser,#message_rsc=battler_attacker_miss,
              #parm1=rColor,
              #parm2=Send(what,@GetDefenseDesc,#stroke_obj=stroke_obj),
              #parm3=Send(what,@GetDef),
              #parm4=Send(what,@GetChampString),
              #parm5=Send(what,@GetName));
         Send(stroke_obj,@SendMissMessageToAttacker,#who=self,#victim=what,
              #color_rsc=rColor,#weapon_used=Send(self,@LookupPlayerWeapon),
              #bText=FALSE);
      }

      if IsClass(what,&Player)
      {
         if IsClass(self,&Player)
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
         {
            rColor = battler_plain_text;
         }
         else
         {
            rColor = battler_blue_text;
         }
      
         Send(what,@MsgSendUser,#message_rsc=battler_defender_miss,
              #parm1=rColor,
              #parm2=Send(self,@GetCapDef),
              #parm3=Send(self,@GetChampString),
              #parm4=Send(self,@GetName),
              #parm5=Send(what,@GetDefenseDesc,#stroke_obj=stroke_obj));
         % Flag them as "dodging", so they can potentially improve.
         Send(what,@SetPlayerFlag,#flag=PFLAG_DODGED,#value=TRUE);
      }

      return;
   }

   % This function handles when damage is done by attacker.
   DidDamage(what=$, amount=0)
   {
      return;
   }

   % This function is called when we killed something.
   KilledSomething(what=$,use_weapon=$,stroke_obj=$)
   {
      return;
   }

   % This returns the wielded weapon
   GetWeapon()
   {
      return self;
   }

   % Oo, 'e died
   Killed(what = $)
   {
      return;
   }

   MsgPlayerHitResisted()
   {
      return;
   }

   GetResistances()
   {
      return Send(self,@GetCurrentResistances);
   }

   GetResistanceValueByType(type=$)
   {
      local lResist;

      lResist = GetListNode(Send(self,@GetCurrentResistances), 1, type);
      if lResist <> $
      {
         return Nth(lResist,2);
      }

      return 0;
   }

   % This section deals with minion control code.
   % Player and Monster both have a copy of CommandMinionAttack.

   NewControlledMinion(minion=$)
   {
      if ptMinionControlCheck = $
      {
         ptMinionControlCheck = CreateTimer(self,@MinionControlCheck,2000);
      }

      plControlledMinions = Cons(minion,plControlledMinions);
      
      if IsClass(self,&Player)
      {
         Post(self,@DrawLeadership);
      }

      return;
   }

   RemoveControlledMinion(what=$)
   {
      if plControlledMinions <> $
      {
         % Use FindListElem; there are rare cases where we have
         % a valid minion that doesn't go on our control list.
         if FindListElem(plControlledMinions,what)
         {
            plControlledMinions = DelListElem(plControlledMinions,what);
         }
      }
      
      if IsClass(self,&Player)
      {
         Post(self,@DrawLeadership);
      }

      return;
   }

   RemoveAllMinions()
   {
      local i;

      foreach i in plControlledMinions
      {
         if IsClass(i,&Monster)
         {
            Send(i,@Delete);
         }
      }

      plControlledMinions = $;
      
      if IsClass(self,&Player)
      {
         Post(self,@DrawLeadership);
      }

      return;
   }

   GetControlledMinions()
   {
      return plControlledMinions;
   }

   CheckBattlerMinionCount()
   {
      local i,iMinionCount;

      iMinionCount = 0;

      foreach i in plControlledMinions
      {
         if NOT IsClass(i,&Reflection)
         {
            iMinionCount = iMinionCount + 1;
         }
      }

      return iMinionCount;
   }

   MinionControlCheck()
   {
      local i;
      
      ptMinionControlCheck = $;

      if Length(plControlledMinions) > 0
      {
         foreach i in plControlledMinions
         {
            if Send(i,@GetMaster) <> self
            {
               Send(self,@RemoveControlledMinion,#what=i);

               continue;
            }

            if Send(i,@GetTarget) = $
            {
               Send(i,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,
                     #value=TRUE);
            }
         }
         ptMinionControlCheck = CreateTimer(self,@MinionControlCheck,2000);
      }
      else
      {
         if ptMinionControlCheck <> $
         {
            DeleteTimer(ptMinionControlCheck);
         }
         ptMinionControlCheck = $;
      }

      return;
   }

   % This section deals with illusions cast by/on the battler

   AddEvilTwin(what=$)
   "If something casts evil twin on us, we store it here."
   {
      if poEvilTwin = $
      {
         poEvilTwin = what;

         return TRUE;
      }

      return FALSE;
   }

   ClearEvilTwin()
   "Clears the poEvilTwin property, called when ET is deleted."
   {
      if poEvilTwin <> $
      {
         poEvilTwin = $;

         return TRUE;
      }

      return FALSE;
   }

   HasEvilTwin()
   {
      return poEvilTwin <> $;
   }

   EvilTwinsCreated(what=$)
   "If we cast evil twin on something, we add the ET to our "
   "list of created evil twins."
   {
      if what <> $
      {
         plEvilTwins = Cons(what,plEvilTwins);
      }

      return;
   }

   RemoveCreatedEvilTwin(what=$)
   "Remove an evil twin from our list of created evil twins."
   {
      local i;

      if plEvilTwins <> $
         AND FindListElem(plEvilTwins,what)
      {
         plEvilTwins = DelListElem(plEvilTwins,what);
      }

      return;
   }

   % If Apparition is cast on the monster, this list keeps track of it.
   AddApparition(what=$)
   {
      if what <> $
      {
         plApparitionList = Cons(what,plApparitionList);
      }

      return;
   }

   % If this monster is an Apparition, this keeps track of the original target.
   AddApparitionOriginal(what=$)
   {
      poApparitionOriginal = what;

      return;
   }

   % If an Apparition targeting this monster is deleted, remove it from list.
   RemoveApparition(what=$)
   {
      local i;

      foreach i in plApparitionList
      {
         if i = what
         {
            plApparitionList = DelListElem(plApparitionList,i);
         }
      }

      if Length(plApparitionList) = 0
         {
            plApparitionList = $;
         }

      return;
   }

   GetActiveBlockSound()
   {
      local iRandom;
      
      iRandom = Random(1,3);
      
      if iRandom = 1
      {
         return rActiveBlockSoundOne;
      }
      
      if iRandom = 2
      {
         return rActiveBlockSoundTwo;
      }
      
      if iRandom = 3
      {
         return rActiveBlockSoundThree;
      }
      
      return rActiveBlockSoundFour;
   }

   GetTumbleSound()
   {
      local iRandom;
      
      iRandom = Random(1,4);
      
      if iRandom = 1
      {
         return rTumbleSoundOne;
      }
      
      if iRandom = 2
      {
         return rTumbleSoundTwo;
      }
      
      if iRandom = 3
      {
         return rTumbleSoundThree;
      }
      
      return rTumbleSoundFour;
   }

   ApplyElementalStatusEffects(damage=1,bSecondary=FALSE,aspell=0,what=$,absolute=FALSE)
   {
      local iIllusionDamage, iDrainDamage, iCharmDamage;

      if absolute
      {
         % Special damage doesn't apply status effects.
         return 0;
      }

      % Illusion damage is not altered by Sorcery.
      iIllusionDamage = damage;
      % Drain damage is not altered by Sorcery.
      iDrainDamage = damage;
      % Charm damage is resisted by all creatures somewhat.
      iCharmDamage = Bound(damage - ((damage * Send(self,@GetCharmResistance))/100),0,$);

      if what <> $
         AND (IsClass(what,&Player) OR IsClass(what,&AlchemyBomb))
         AND Send(SETTINGS_OBJECT,@GetSorcerySchoolExpansion)
         AND Send(what,@GetSkillAbility,#skill_num=SKID_EMPOWERMENT) > 0
         AND NOT bSecondary
      {
         % Is a master Sorcerer applying these effects? Boost them.
         damage = (damage * Send(Send(SYS,@FindSkillByNum,
                                  #num=SKID_EMPOWERMENT),
                                  @GetEmpowermentMultiplier,#who=what))/100;
      }

      if IsClass(self,&Player)
         AND Send(SETTINGS_OBJECT,@GetSorcerySchoolExpansion)
         AND Send(self,@GetSkillAbility,#skill_num=SKID_INERT_FORM) > 0
      {
         % Is a master Sorcerer taking this damage? Reduce effects.
         damage = (damage * (100-Send(Send(SYS,@FindSkillByNum,#num=SKID_INERT_FORM),@GetInertFormPercentage,#who=self)))/100;
      }

      if damage <= 0
      {
         return 0;
      }

      if aspell & ATCK_SPELL_SHOCK
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_SHOCKED);
      }
      if aspell & ATCK_SPELL_COLD
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_CHILLED);
      }
      if aspell & ATCK_SPELL_FIRE
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_BURNING);
      }
      if aspell & ATCK_SPELL_ACID
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_CORRODE);
      }
      if aspell & ATCK_SPELL_HOLY
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_HUMBLED);
      }
      if aspell & ATCK_SPELL_UNHOLY
      {
         Send(self,@AddStatusEffect,#value=damage,#type=STATUS_MANTLED);
      }
      if aspell & ATCK_SPELL_ILLUSION
      {
         if what <> $
            AND IsClass(what,&Player)
            AND Send(what,@IsUsingA,#class=&RiijaCrest)
         {
            % No healing back for riija crest user.
         }
         else
         {
            Send(self,@AddStatusEffect,#value=iIllusionDamage,#type=STATUS_TRICKED);
         }
      }
      if aspell & ATCK_SPELL_DRAIN
      {
         Send(self,@AddStatusEffect,#value=iDrainDamage,#type=STATUS_DRAINED);
      }
      if aspell & ATCK_SPELL_CHARM
      {
         Send(self,@AddStatusEffect,#value=iCharmDamage,#type=STATUS_CHARMED);
      }
      return damage;
   }

   AddStatusEffect(value=10,type=STATUS_SHOCKED)
   {
      local i;
      
      if NOT Send(SETTINGS_OBJECT,@GetEnableElementalStatusEffects)
      {
         % This server doesn't use elemental status effects.
         return;
      }
      
      if ptStatusEffectTimer = $
      {
         ptStatusEffectTimer = CreateTimer(self,@StatusEffectTimer,
                                           Send(SETTINGS_OBJECT,
                                           @GetStatusEffectReductionTime));
      }

      if type=STATUS_SHOCKED
         AND IsClass(self,&Player)
      {
         Post(self,@DrawDefense);
      }
      
      if type=STATUS_CHILLED
         AND IsClass(self,&Player)
      {
         Post(self,@DrawOffense);
      }
      
      if type=STATUS_CORRODE
         AND IsClass(self,&Player)
      {
         if Send(SETTINGS_OBJECT,@GetDirectArmorEnabled)
         {
            Post(self,@DrawArmor);
         }
         Post(self,@DrawResistances);
      }
      
      if type=STATUS_HUMBLED
         AND IsClass(self,&Player)
      {
         Post(self,@DrawResistances);
      }
      
      if type=STATUS_DRAINED
         AND IsClass(self,&Player)
      {
         Post(self,@NewHealth);
      }
      
      foreach i in plStatusEffects
      {
         if Nth(i,2) = type
         {
            SetNth(i,1,Nth(i,1)+value);
            return;
         }
      }

      plStatusEffects = Cons([value,type],plStatusEffects);
      return;
   }
   
   GetStatusEffect(type=STATUS_SHOCKED)
   {
      local i;

      foreach i in plStatusEffects
      {
         if Nth(i,2) = type
         {
            return Nth(i,1);
         }
      }
      return 0;
   }
   
   ClearStatusEffect(type=STATUS_SHOCKED)
   {
      local i;
      
      foreach i in plStatusEffects
      {
         if Nth(i,2) = type
         {
            SetNth(i,1,0);
            plStatusEffects = DelListElem(plStatusEffects,i);
         }
      }
      
      if plStatusEffects = $
      {
         if ptStatusEffectTimer <> $
         {
            DeleteTimer(ptStatusEffectTimer);
            ptStatusEffectTimer = $;
         }
      }
      
      return;
   }
   
   ClearAllStatusEffects()
   {
      plStatusEffects = $;
      if ptStatusEffectTimer <> $
      {
         DeleteTimer(ptStatusEffectTimer);
         ptStatusEffectTimer = $;
      }
      return;
   }

   StatusEffectTimer(timer=$)
   {
      local i, iBurningDamage, iIllusionHeal, oOpponent, iDrainRegain, iCharmedWearOff;
      
      ptStatusEffectTimer = $;
      
      foreach i in plStatusEffects
      {
         if Nth(i,2) = STATUS_SHOCKED
            AND IsClass(self,&Player)
         {
            Post(self,@DrawDefense);
         }
         if Nth(i,2) = STATUS_CHILLED
            AND IsClass(self,&Player)
         {
            Post(self,@DrawOffense);
         }
         if Nth(i,2) = STATUS_CORRODE
            AND IsClass(self,&Player)
         {
            if Send(SETTINGS_OBJECT,@GetDirectArmorEnabled)
            {
               Post(self,@DrawArmor);
            }
            Post(self,@DrawResistances);
         }
         if Nth(i,2) = STATUS_HUMBLED
            AND IsClass(self,&Player)
         {
            Post(self,@DrawResistances);
         }

         if Nth(i,2) = STATUS_BURNING
         {
            iBurningDamage = (Nth(i,1) / Send(SETTINGS_OBJECT,
                              @GetElementalMultiple,#type=STATUS_BURNING));
            SetNth(i,1,0);
            if iBurningDamage >= 1
               AND Send(self,@GetOwner) <> $
               AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
               AND NOT (IsClass(self,&Player) AND NOT Send(self,@IsLoggedOn))
               AND NOT (IsClass(self,&Player) AND Send(self,@IsInCannotInteractMode))
            {
               oOpponent = Send(self,@GetHighestHurtMeRecentlyBattler);
               
               if oOpponent = $
               {
                  oOpponent = self;
               }
               if Send(self,@AssessDamage,#what=oOpponent,
                              #damage=iBurningDamage,
                              #bSecondary=TRUE,
                              #aspell=ATCK_SPELL_FIRE,
                              #report=FALSE,
                              #report_resistance=FALSE) = $
               {
                  Post(oOpponent,@KilledSomething,#what=self);
               }
            }
         }
         else if Nth(i,2) = STATUS_TRICKED
         {
            if NOT (IsClass(self,&Player) AND Send(self,@IsInCannotInteractMode))
            {
               iIllusionHeal = Send(SETTINGS_OBJECT,
                                     @GetStatusEffectReductionAmount,
                                     #type=STATUS_TRICKED);
               iIllusionHeal = Bound(iIllusionHeal,0,Nth(i,1));
               Send(self,@GainHealthNormal,#amount=iIllusionHeal);
               if IsClass(self,&Player)
                  AND Send(self,@IsLoggedOn)
               {
                  Send(self,@MsgSendUser,#message_rsc=illusion_damage_heal_msg);
               }
               SetNth(i,1,Nth(i,1) - iIllusionHeal);
            }
         }
         else if Nth(i,2) = STATUS_DRAINED
         {
            if NOT (IsClass(self,&Player) AND Send(self,@IsInCannotInteractMode))
               AND NOT (IsClass(self,&Player) AND NOT Send(self,@IsLoggedOn))
            {
               iDrainRegain = Send(SETTINGS_OBJECT,
                                    @GetStatusEffectReductionAmount,
                                    #type=STATUS_DRAINED);
               iDrainRegain = Bound(iDrainRegain,0,Nth(i,1));
               SetNth(i,1,Nth(i,1) - iDrainRegain);
               if IsClass(self,&Player)
                  AND Send(self,@IsLoggedOn)
               {
                  Post(self,@NewHealth);
               }
            }
         }
         else if Nth(i,2) = STATUS_CHARMED
         {
            if NOT (IsClass(self,&Player) AND Send(self,@IsInCannotInteractMode))
               AND NOT (IsClass(self,&Player) AND NOT Send(self,@IsLoggedOn))
            {
               iCharmedWearOff = Send(SETTINGS_OBJECT,
                                    @GetStatusEffectReductionAmount,
                                    #type=STATUS_CHARMED);
               iCharmedWearOff = Bound(iCharmedWearOff,0,Nth(i,1));
               SetNth(i,1,Nth(i,1) - iCharmedWearOff);
            }
         }
         else
         {
            SetNth(i,1,Nth(i,1) - Send(SETTINGS_OBJECT,
                                  @GetStatusEffectReductionAmount,
                                  #type=Nth(i,2)));
         }

         if Nth(i,1) <= 0
         {
            if plStatusEffects <> $
            {
               plStatusEffects = DelListElem(plStatusEffects,i);
            }
         }
      }
      
      if plStatusEffects <> $
         AND ptStatusEffectTimer = $
      {
         ptStatusEffectTimer = CreateTimer(self,@StatusEffectTimer,
                                           Send(SETTINGS_OBJECT,
                                           @GetStatusEffectReductionTime));
      }
      
      return;
   }

   GetBoostedLevel()
   {
      return 0;
   }
   
   GetChaosLevel()
   {
      return 0;
   }

   GetChampString()
   {
      return battler_champion_none;
   }

   GetChampStatus()
   {
      return 0;
   }

   GetChampionRewardMultiplier()
   {
      return 1;
   }

   CreateReputationHash()
   {
      phReputation = CreateTable();

      return phReputation;
   }

   GetReputationHash()
   {
      return phReputation;
   }

   GetReputation(faction=$)
   {
      if (faction <> $)
      {
         return GetTableEntry(phReputation,faction);
      }

      return;
   }

   SetReputation(faction=$,value=$)
   {
      if (faction <> $ AND value <> $)
      {
         AddTableEntry(phReputation,faction,value);
      }

      return;
   }

   GetHighestHurtMeRecentlyBattler()
   {
      local i, iHighestAmount, iHighestBattler;

      iHighestAmount = 0;
      iHighestBattler = $;
      foreach i in plHurtMeRecently
      {
         if Nth(i,2) > iHighestAmount
         {
            iHighestAmount = Nth(i,2);
            iHighestBattler = Nth(i,1);
         }
      }

      return iHighestBattler;
   }

   GetHurtMeRecentlyAmount(who=$)
   {
      local i;

      foreach i in plHurtMeRecently
      {
         if First(i) = who
         {
            return Nth(i,2);
         }
      }

      return 0;
   }

   AddHurtMeRecently(who=$,amount=0)
   {
      local i;

      foreach i in plHurtMeRecently
      {
         if First(i) = who
         {
            if Nth(i,2) + amount > 100000
            {
               % Somebody is doing something stupid. Let's return this.
               % Catch for players botting attacks on alts, shenanigans.
               return;
            }
            SetNth(i,2,Nth(i,2)+amount);
            DeleteTimer(Nth(i,3));
            
            if IsClass(who,&User)
               AND IsClass(self,&User)
            {
               % Keep longer track of pvp
               SetNth(i,3,CreateTimer(self,@RemoveHurtMeRecently,piHurtMeTime*35));
            }
            else
            {
               SetNth(i,3,CreateTimer(self,@RemoveHurtMeRecently,piHurtMeTime));
            }

            return;
         }
      }

      if IsClass(who,&User)
        AND IsClass(self,&User)
      {
         plHurtMeRecently = Cons([who,amount,CreateTimer(self,
                                  @RemoveHurtMeRecently,piHurtMeTime*35)],
                                  plHurtMeRecently);
      }
      else
      {
         plHurtMeRecently = Cons([who,amount,CreateTimer(self,
                                  @RemoveHurtMeRecently,piHurtMeTime)],
                                  plHurtMeRecently);
      }

      return;
   }

   RemoveHurtMeRecently(timer=$)
   {
      local i;

      foreach i in plHurtMeRecently
      {
         if Nth(i,3) = timer
         {
            SetFirst(i,$);
            SetNth(i,2,$);
            SetNth(i,3,$);
            plHurtMeRecently = DelListElem(plHurtMeRecently,i);

            return;
         }
      }

      return;
   }
   
   IsDrainImmune()
   {
      return FALSE;
   }

   GetHexes()
   {
      local oEnch, lHexes;

      lHexes = $;
      foreach oEnch in plEnchantments
      {
         if Send(Nth(oEnch,2),@UseHexBehavior)
         {
            lHexes = Cons(Nth(oEnch,2),lHexes);
         }
      }

      return lHexes;
   }

   GetNumHexes()
   {
      local oEnch, iNumHexes;

      iNumHexes = 0;
      foreach oEnch in plEnchantments
      {
         if Send(Nth(oEnch,2),@UseHexBehavior)
         {
            iNumHexes = iNumHexes + 1;
         }
      }

      return iNumHexes;
   }

   RemoveRandomHex(exempt=$)
   {
      local lHexes;

      lHexes = Send(self,@GetHexes);
      if exempt <> $
         AND lHexes <> $
         AND FindListElem(lHexes,exempt) <> 0
      {
         lHexes = DelListElem(lHexes,exempt);
      }

      if lHexes <> $
         AND Length(lHexes) > 0
      {
         Send(self,@RemoveEnchantment,
              #what=Nth(lHexes,Random(1,Length(lHexes))));
      }

      return;
   }

   GetHexIncEffect(iSpellPower=0,oTarget=$)
   {
      local lBindingSongState, iBindingSongInc;

      iBindingSongInc = 0;
      lBindingSongState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&BindingSong);
      if lBindingSongState <> $
      {
         iBindingSongInc = Send(Nth(lBindingSongState,1),@GetHexIncEffect,#iSongPower=Nth(lBindingSongState,2));
      }

      return iSpellPower + 1 + iBindingSongInc;
   }

   GetHexResistance()
   {
      local lBindingSongState, iBindingSongRes;

      iBindingSongRes = 0;
      lBindingSongState = Send(self,@GetMostPowerfulRadiusEnchantmentState,#byClass=&BindingSong);
      if lBindingSongState <> $
      {
         iBindingSongRes = Send(Nth(lBindingSongState,1),@GetHexResistance,#iSongPower=Nth(lBindingSongState,2));
      }

      return bound(piHexResistance+iBindingSongRes,-200,200);
   }

   GetCasterMaxHexes()
   {
      return Send(SETTINGS_OBJECT,@GetHexesMax);
   }

   GetBaseEmpowerments()
   {
      return $;
   }

   GetCurrentEmpowerments()
   "Boost dealt damage of certain types."
   {
      local oObjectAttribute, lCurrentEmpowerments, oEquipment, oEnchantment;

      lCurrentEmpowerments = ListCopy(Send(self,@GetBaseEmpowerments));
      
      foreach oObjectAttribute in plObject_attributes
      {
         lCurrentEmpowerments = Send(oObjectAttribute,@ModifyEmpowerment,
                                  #empowerment_list=lCurrentEmpowerments);
      }
      
      foreach oEquipment in Send(self,@GetEquippedItems)
      {
         lCurrentEmpowerments = Send(oEquipment,@ModifyEmpowerment,
                                     #empowerment_list=lCurrentEmpowerments);
      }
      
      If IsClass(self,&User)
      {
         foreach oEnchantment in Send(self,@GetEnchantmentList)
         {
            if Length(oEnchantment) > 2
            {
               lCurrentEmpowerments = Send(Nth(oEnchantment,2),
                  @ModifyEmpowerment,
                  #empowerment_list=lCurrentEmpowerments,
                  #iState=Nth(oEnchantment,3));
            }
            else
            {
               lCurrentEmpowerments = Send(Nth(oEnchantment,2),
                  @ModifyEmpowerment,
                  #empowerment_list=lCurrentEmpowerments);
            }
         }

         foreach oEnchantment in Send(self,@GetReservedSpells)
         {
            lCurrentEmpowerments = Send(Nth(oEnchantment,1),@ModifyEmpowerment,#empowerment_list=lCurrentEmpowerments,#iState=Nth(oEnchantment,3));
         }
      }
      
      return lCurrentEmpowerments;
   }

   GetBaseSlayers()
   {
      return $;
   }

   GetCurrentSlayers()
   "Boost dealt damage to certain creature types."
   {
      local oObjectAttribute, lCurrentSlayers, oEquipment, oEnchantment;

      lCurrentSlayers = ListCopy(Send(self,@GetBaseSlayers));
      
      foreach oObjectAttribute in plObject_attributes
      {
         lCurrentSlayers = Send(oObjectAttribute,@ModifySlayer,#slayer_list=lCurrentSlayers);
      }
      
      foreach oEquipment in Send(self,@GetEquippedItems)
      {
         lCurrentSlayers = Send(oEquipment,@ModifySlayer,#slayer_list=lCurrentSlayers);
      }
      
      If IsClass(self,&User)
      {
         foreach oEnchantment in Send(self,@GetEnchantmentList)
         {
            if Length(oEnchantment) > 2
            {
               lCurrentSlayers = Send(Nth(oEnchantment,2),
                  @ModifySlayer,
                  #slayer_list=lCurrentSlayers,
                  #iState=Nth(oEnchantment,3));
            }
            else
            {
               lCurrentSlayers = Send(Nth(oEnchantment,2),
                  @ModifySlayer,
                  #slayer_list=lCurrentSlayers);
            }
         }

         foreach oEnchantment in Send(self,@GetReservedSpells)
         {
            lCurrentSlayers = Send(Nth(oEnchantment,1),@ModifySlayer,#slayer_list=lCurrentSlayers,#iState=Nth(oEnchantment,3));
         }
      }
      
      return lCurrentSlayers;
   }

   GetBonusBaseTP()
   {
      return 0;
   }

   GetAlwaysShareXP()
   {
      return FALSE;
   }

   GetBaseSize()
   {
      return viBaseSize;
   }

   GetSize()
   {
      return Send(self,@GetBaseSize);
   }

   GetKnockbackPercentage()
   {
      return viBaseKnockbackPercentage;
   }

   GetStunPercentage()
   {
      return viBaseStunPercentage;
   }
   
   GetBleedPercentage()
   {
      return viBaseBleedPercentage;
   }

   GetCriticalPercentage()
   {
      return 100;
   }

   ApplyKnockback(what=$, iRow=0, iCol=0, iFineRow=0, iFineCol=0, knockback_power=0, knockback_angle=0)
   {
      local oRoom, iKnockbackDistance, iAngle, i, lSteps, oElement, iIncDuration;
      
      if knockback_angle = 0
      {
         if what <> $
         {
            % Use attacker's angle for knockback if none sent
            iAngle = Send(what,@GetAngle);
         }
         else
         {
            % Use the reverse of our own angle otherwise.
            iAngle = Abs(Send(self,@GetAngle)-2048);
         }
      }
      else
      {
         iAngle = knockback_angle;
      }

      % knockback_power is the attacker's GetKnockbackPower if from an attacker
      % if from an effect like a trap, have the trap directly send knockback_power and coords
      
      if what <> $
      {
         iRow = Send(what,@GetRow);
         iCol = Send(what,@GetCol);
         iFineRow = Send(what,@GetFineRow);
         iFineCol = Send(what,@GetFineCol);
      }

      oRoom = Send(self,@GetOwner);
      if oRoom = $
         OR NOT IsClass(oRoom,&Room)
      {
         return FALSE;
      }

      if Send(oRoom,@IsArena)
      {
         % No knockback in arena, causes too many issues.
         return FALSE;
      }

      % Let's calculate.
      % Start with a standard knockback, which is default 5 units (320 fine).
      iKnockbackDistance = Send(SETTINGS_OBJECT,@GetStandardKnockbackDistance);
      
      % Modify by knockback_power vs our size.
      iKnockbackDistance = (iKnockbackDistance*knockback_power)/Bound(Send(self,@GetSize),1,$);
      
      % Modify by our knockback percentage. This can make us less or more vulnerable.
      iKnockbackDistance = (iKnockbackDistance*Send(self,@GetKnockbackPercentage))/100;

      % Let's not attempt knockbacks under one square, they get inaccurate
      % They're also not very useful
      if iKnockbackDistance < 64
      {
         return FALSE;
      }

      if IsClass(self,&User)
      {
         Send(self,@EffectSendUserDuration,#effect=EFFECT_SHAKE,#duration=Bound(iKnockbackDistance*2,500,2000));
      }
      
      if IsClass(what,&Player)
      {
         Send(what,@MsgSendUser,#message_rsc=knockback_message,
                                #parm1=Send(self,@GetDef),
                                #parm2=Send(self,@GetName));
      }

      if IsClass(self,&Player)
         AND what <> $
      {
         Send(self,@MsgSendUser,#message_rsc=knocked_back_message,
                                  #parm1=Send(what,@GetCapDef),
                                  #parm2=Send(what,@GetName));
      }

      lSteps = Send(oRoom,@IntraTeleport,#what=self,
                                   #distance=iKnockbackDistance,
                                   #type=INTRA_TELEPORT_AWAY_FROM_DESTINATION,
                                   #new_row=iRow,
                                   #new_col=iCol,
                                   #fine_row=iFineRow,
                                   #fine_col=iFineCol,
                                   #new_angle=iAngle);

      if lSteps <> $
      {
         iIncDuration = 100 * Length(lSteps);
         foreach i in lSteps
         {
            oElement = Create(&DustCloud,#Caster=what,#duration=iIncDuration,#bMS=TRUE);
            Send(oRoom,@NewHold,#what=oElement,
                 #new_row=Nth(i,1),#new_col=Nth(i,2),
                 #fine_row=Nth(i,3),#fine_col=Nth(i,4));
            iIncDuration = Bound(iIncDuration - 100, 100, $);
         }
      }
      return TRUE;
   }

   ApplyStun(what=$, stun_power=0)
   {
      local oSpell, iStunDuration, oRoom;
      
      if Send(self,@IsEnchanted,#byClass=&Stun)
      {
         % No multi stunning
         return FALSE;
      }

      oRoom = Send(self,@GetOwner);
      if oRoom = $
         OR NOT IsClass(oRoom,&Room)
      {
         % Dead things don't get stunned
         return FALSE;
      }

      iStunDuration = Send(SETTINGS_OBJECT,@GetStandardStunDuration);

      % Modify stun duration by difference in sizes
      iStunDuration = (iStunDuration*stun_power)/Bound(Send(self,@GetSize),1,$);

      % Modify by our stun percentage. This can make us less or more vulnerable.
      iStunDuration = (iStunDuration*Send(self,@GetStunPercentage))/100;
      
      % No stuns under one second, because that just causes object update jumpiness
      if iStunDuration < 1000
      {
         return FALSE;
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_STUN);
      if oSpell <> $
      {
         if what <> $
            AND IsClass(what,&Player)
         {
            Send(what,@MsgSendUser,#message_rsc=stun_message,
                                   #parm1=Send(self,@GetDef),
                                   #parm2=Send(self,@GetName));
         }
%         if IsClass(self,&Player)
%            AND what <> $
%         {
%            Send(self,@MsgSendUser,#message_rsc=stunned_message,
%                                   #parm1=Send(what,@GetCapDef),
%                                   #parm2=Send(what,@GetName));
%         }
         Send(oSpell,@DoSpell,#oTarget=self,#iDuration=iStunDuration);
      }

      return TRUE;
   }

   ApplyBleed(what=$, bleed_power = 0)
   {
      local oSpell, iBleedDuration, oRoom;

      oRoom = Send(self,@GetOwner);
      if oRoom = $
         OR NOT IsClass(oRoom,&Room)
      {
         % No bleeds on dead things
         return FALSE;
      }

      iBleedDuration = Send(SETTINGS_OBJECT,@GetStandardBleedDuration);

      % Modify bleed duration by difference in sizes
      iBleedDuration = (iBleedDuration*bleed_power)/Bound(Send(self,@GetSize),1,$);

      % Modify by our bleed percentage. This can make us less or more vulnerable.
      iBleedDuration = (iBleedDuration*Send(self,@GetBleedPercentage))/100;
      
      % No bleeds under five seconds, because that's not even one damage
      if iBleedDuration < 5000
      {
         return FALSE;
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_BLEED);
      if oSpell <> $
      {
         if what <> $
            AND IsClass(what,&Player)
         {
            Send(what,@MsgSendUser,#message_rsc=bleed_message,
                                   #parm1=Send(self,@GetDef),
                                   #parm2=Send(self,@GetName));
            if Send(what,@HasSkill,#num=SKID_BLEED_MASTERY)
            {
               Send(Send(SYS,@FindSkillByNum,#num=SKID_BLEED_MASTERY),@ImproveAbility,#who=what);
            }
         }
%         if IsClass(self,&Player)
%            AND what <> $
%         {
%            Send(self,@MsgSendUser,#message_rsc=bleeded_message,
%                                   #parm1=Send(what,@GetCapDef),
%                                   #parm2=Send(what,@GetName));
%         }
         Send(oSpell,@DoSpell,#oTarget=self,#iDuration=iBleedDuration,#bleed_applier=what);
      }

      return TRUE;
   }

   StartBleedTimer()
   {
      if ptBleedTimer = $
      {
         ptBleedTimer = CreateTimer(self,@DoBleed,BLEED_TIME);
      }
      return;
   }

   EndBleedTimer()
   {
      if ptBleedTimer <> $
      {
         DeleteTimer(ptBleedTimer);
         ptBleedTimer = $;
      }
      return;
   }

   DoBleed()
   {
      local i, iBleedCount;

      ptBleedTimer = $;
      
      if (IsClass(self,&Player)
         AND Send(self,@IsInCannotInteractMode))
         OR NOT Send(self,@IsEnchanted,#byClass=&Bleed)
      {
         return;
      }

      iBleedCount = 0;
      foreach i in Send(self,@GetEnchantmentsByClass,#enchClass=&Bleed)
      {
         iBleedCount++;
      }
      Send(self,@LoseHealth,#amount=iBleedCount,#decay=TRUE);
      
      ptBleedTimer = CreateTimer(self,@DoBleed,BLEED_TIME);
      return;
   }

   GetKnockbackPower()
   {
      return Send(self,@GetSize);
   }
   
   GetStunPower()
   {
      return Send(self,@GetSize);
   }

   GetBleedPower()
   {
      return Send(self,@GetSize);
   }

   IsBleeding()
   {
      return Send(self,@IsEnchanted,#byClass=&Bleed);
   }

   IsStunned()
   {
      return Send(self,@IsEnchanted,#byClass=&Stun);
   }

   GetDamageShare(who=$)
   {
      local i, iTotalDamageTaken, iRequesterDamage;

      if who <> $
         AND plHurtMeRecently <> $
      {
         iTotalDamageTaken = 0;
         iRequesterDamage = 0;
         foreach i in plHurtMeRecently
         {
            iTotalDamageTaken = iTotalDamageTaken + Nth(i,2);
            if First(i) = who
            {
               iRequesterDamage = Nth(i,2);
            }
         }
         
         if iTotalDamageTaken = 0
         {
            return 0;
         }

         return (iRequesterDamage * 100) / iTotalDamageTaken;
      }
      return 0;
   }

   PlayerHealedSomeone(caster=$, oTarget=$, iHealAmount=0)
   {
      return;
   }

   IsShadow()
   {
      % This is a type like Undead, except representing shadows and darkness.
      return FALSE;
   }

   ClearElementalImbalance()
   {
      if ptElementalImbalanceTimer <> $
      {
         DeleteTimer(ptElementalImbalanceTimer);
      }
      Send(self,@EndElementalImbalance);
      return;
   }

   EndElementalImbalance()
   {
      ptElementalImbalanceTimer = $;

      if plElementalImbalance <> $
      {
         plElementalImbalance = $;
         if IsClass(self,&User)
         {
            Post(self,@DrawResistances);
         }
      }

      return;
   }

   ApplyElementalImbalance(aspell=0, power=0)
   {
      local iFire, iShock, iCold, iAcid, iResType, lElements, bFound;

      if power <= 0
      {
         return;
      }

      lElements = [ATCK_SPELL_FIRE,
                   ATCK_SPELL_SHOCK,
                   ATCK_SPELL_COLD,
                   ATCK_SPELL_ACID];

      bFound = FALSE;
      foreach iResType in lElements
      {
         if (aspell & iResType) <> 0
         {
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         return;
      }

      Send(self,@ClearElementalImbalance);

      % If we are being dealt damage of a type, gain resistance.
      % If we aren't, lose resistance.
      foreach iResType in lElements
      {
         if (aspell & iResType) <> 0
         {
            plElementalImbalance = Cons([-iResType,power],plElementalImbalance);
         }
         else
         {
            plElementalImbalance = Cons([-iResType,-power],plElementalImbalance);
         }
      }

      ptElementalImbalanceTimer = CreateTimer(self,@EndElementalImbalance,4000);

      if IsClass(self,&User)
      {
         Post(self,@DrawResistances);
      }
      return;
   }

   GetElementalImbalance()
   {
      return plElementalImbalance;
   }

   GetEnemyRangeBonus()
   {
      return viEnemyRangeBonus;
   }

   GetBonusXPGain()
   {
      return 0;
   }

   GetCreatureTypes()
   {
      return plCreatureTypes;
   }

   HasCreatureType(type=CREATURE_TYPE_MONSTER)
   {
      local i;
      
      if plCreatureTypes <> $
         AND FindListElem(plCreatureTypes,type) <> 0
      {
         return TRUE;
      }
      return FALSE;
   }
   
   GetCharmResistance()
   {
      % This is a percentage value
      return 0;
   }
   
   GetLadderID()
   {
      return piLadderID;
   }
   
   SetLadderID(value=0)
   {
      piLadderID = value;
      return;
   }

   ClearBombs()
   {
      local i;
      
      foreach i in plBombs
      {
         Send(First(i),@Delete);
      }
      
      plBombs = $;
      
      return;
   }
   
   GetBombs()
   {
      return plBombs;
   }
   
   GetBombLimit()
   {
      return Send(SETTINGS_OBJECT,@GetBombLimit);
   }

   RemoveOldestBomb()
   {
      local i, iTimeOldest, oOldestBomb;
      
      oOldestBomb = $;
      iTimeOldest = GetTime();
      foreach i in plBombs
      {
         if Nth(i,2) < iTimeOldest
         {
            oOldestBomb = First(i);
         }
      }
      
      if oOldestBomb <> $
      {
         Send(self,@RemoveBomb,#oBomb=oOldestBomb);
         Send(oOldestBomb,@Delete);
      }
      return;
   }

   DetonateBombs()
   {
      local i;
      
      foreach i in plBombs
      {
         Send(First(i),@Detonate);
      }

      return;
   }
   
   AddBomb(oBomb=$)
   {
      if plBombs <> $
         AND Length(plBombs) >= Send(self,@GetBombLimit)
      {
         Send(self,@RemoveOldestBomb);
      }
      plBombs = Cons([oBomb,GetTime()],plBombs);
      return;
   }
   
   RemoveBomb(oBomb=$)
   {
      local i;
      
      foreach i in plBombs
      {
         if First(i) = oBomb
         {
            plBombs = DelListElem(plBombs,i);
         }
      }
      return;
   }
   
   ConvokeMinions()
   {
      local i;

      if poOwner <> $
      {
         foreach i in plControlledMinions
         {
            Send(Send(SYS,@FindRoomByNum,#num=RID_JAS_AB1),@NewHold,#what=i);
            Send(poOwner,@NewHold,#what=i,
                                  #new_row=Send(self,@GetRow),
                                  #new_col=Send(self,@GetCol),
                                  #fine_row=Send(self,@GetFineRow),
                                  #fine_col=Send(self,@GetFineCol));
         }
      }
      return;
   }
   
   ConvokeMinion(oMinion=$)
   {
      local i;

      if poOwner <> $
      {
         foreach i in plControlledMinions
         {
            if i = oMinion
            {
               Send(Send(SYS,@FindRoomByNum,#num=RID_JAS_AB1),@NewHold,#what=i);
               Send(poOwner,@NewHold,#what=i,
                                     #new_row=Send(self,@GetRow),
                                     #new_col=Send(self,@GetCol),
                                     #fine_row=Send(self,@GetFineRow),
                                     #fine_col=Send(self,@GetFineCol));
               return TRUE;
            }
         }
      }
      return FALSE;
   }
   
   ClearMinionPatrolLocations()
   {
      local i;
      
      foreach i in plControlledMinions
      {
         Send(i,@ClearPatrolLocation);
      }
      return;
   }
   
   GiveMinionsPatrolLocation(lPos=$)
   {
      local i;
      
      if lPos = $
      {
         return;
      }
      
      foreach i in plControlledMinions
      {
         Send(i,@GotoCoords,#iRow=Nth(lPos,1),#iCol=Nth(lPos,2),#iFineRow=Nth(lPos,3),#iFineCol=Nth(lPos,4));
      }
      return;
   }

   MarkLastTimeInCombat()
   {
      piLastTimeInCombat = GetTime();
      return;
   }

   GetLastTimeInCombat()
   {
      return piLastTimeInCombat;
   }
   
   GetRend(victim=$, resistance_list=$)
   {
      local oHex, lResistanceTest, lRend, iRendType, iRendAmount;

      if IsClass(self,&Monster)
      {
         iRendType = piRendType;
         iRendAmount = piRendAmount;
         
         % Rend can never reduce below zero
         iRendAmount = Send(self,@CapRendToResist,#iRendType=iRendType,#iRendAmount=iRendAmount,#resistance_list=resistance_list);
         
         foreach oHex in Send(victim,@GetEnchantmentsByClass,#enchClass=&AntiResistanceHex)
         {
            if Send(Nth(oHex,2),@GetResistanceType) = iRendType
            {
               lResistanceTest = Send(Nth(oHex,2),@ModifyResistance,#resistance_list=[[iRendType,0]],#iState=Nth(oHex,3));
               
               if iRendAmount > abs(Nth(Nth(lResistanceTest,1),2))
               {
                  % Rends and hexes are mutually exclusive. If the rend is greater, use the difference.
                  return [iRendType, iRendAmount - Nth(Nth(lResistanceTest,1),2)];
               }
               else
               {
                  return [0,0];
               }
            }
         }
         return [iRendType,iRendAmount];
      }
      else if IsClass(self,&Player)
      {
         lRend = [0,0];
         if Send(self,@GetWeapon) <> $
         {
            lRend = Send(Send(self,@GetWeapon),@GetRend,#victim=victim);
         }

         iRendType = Nth(lRend,1);
         iRendAmount = Nth(lRend,2);
         
         % Rend can never reduce below zero
         iRendAmount = Send(self,@CapRendToResist,#iRendType=iRendType,#iRendAmount=iRendAmount,#resistance_list=resistance_list);

         foreach oHex in Send(victim,@GetEnchantmentsByClass,#enchClass=&AntiResistanceHex)
         {
            if Send(Nth(oHex,2),@GetResistanceType) = iRendType
            {
               lResistanceTest = Send(Nth(oHex,2),@ModifyResistance,#resistance_list=[[iRendType,0]],#iState=Nth(oHex,3));
               
               if iRendAmount > abs(Nth(Nth(lResistanceTest,1),2))
               {
                  % Rends and hexes are mutually exclusive. If the rend is greater, use the difference.
                  return [iRendType, iRendAmount - Nth(Nth(lResistanceTest,1),2)];
               }
               else
               {
                  return [0,0];
               }
            }
         }
         return [iRendType,iRendAmount];
      }
      return [0,0];
   }
   
   CapRendToResist(iRendType=0, iRendAmount=0, resistance_list=$)
   {
      local lResist;
      
      foreach lResist in resistance_list
      {
         if Nth(lResist,1) = iRendType
         {
            if iRendAmount > Nth(lResist,2)
            {
               return Nth(lResist,2);
            }
            else
            {
               return iRendAmount;
            }
         }
      }
      
      return iRendAmount;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
