% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
MinotaurMazeRoom is Room

% The Maze of the Minotaur changes each day.
% You have until your Elemental Torch runs out.
% Night vision, light, firewall, glow, etc do not work. Your only light is the torch.


% Musical attributions:
% https://freesound.org/people/Lalks/sounds/316830/
% Lalks Ferambie
% No changes made
%
% https://freesound.org/people/knarmahfox/sounds/72146/
% Through the Caves
% knarmahfox
% no changes made
% 


constants:

   include blakston.khd

resources:

   room_minotaurmazeroom = mazepieces.roo
   room_name_minotaurmazeroom = "Maze of the Minotaur"
   
   maze_music1 = ferambie.mp3
   maze_music2 = acidsounds.mp3
   maze_music3 = bossfight.mp3

   maze_lift_sound = stoneup2.wav
   maze_click_sound = mechanical1.wav
   maze_trap_slam = trapslam.wav
   maze_spike_rise = spiketrap.wav
   maze_sawblade_rise = sawbladerise.wav
   
   trap_damages_you = \
      "Crushing pain radiates through your bones!"
   
   spikes_damage_you = \
      "Spikes stab up from beneath you!"

   lava_applying_burn = \
      "You are being set on fire!"

classvars:

   vrName = room_name_minotaurmazeroom

   viTeleport_row = 5
   viTeleport_col = 3

   %%%%%%%%%%%%%%%%%%%% CRUSHERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   % How do crusher traps function in this room?
   TRAP_TRIGGERED_DELAY = 50
   TRAP_ACTING_DELAY = 500
   TRAP_HIT_DELAY = 2000
   TRAP_RETREATING_DELAY = 10000
   TRAP_DAMAGE = 50

   %%%%%%%%%%%%%%%%%%%% LEVERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   LEVER_ONE_ROW = 3
   LEVER_ONE_TYPE = ANIMATE_CEILING_LIFT
   LEVER_ONE_ACTIVATES_SECTOR = 1
   LEVER_ONE_DOWN_HEIGHT = 1160
   LEVER_ONE_DOWN_SPEED = 50
   LEVER_ONE_UP_HEIGHT = 1035
   LEVER_ONE_UP_SPEED = 50
   
   LEVER_TWO_ROW = 25
   LEVER_TWO_TYPE = ANIMATE_FLOOR_LIFT
   LEVER_TWO_ACTIVATES_SECTOR = 6
   LEVER_TWO_DOWN_HEIGHT = 0
   LEVER_TWO_DOWN_SPEED = 50
   LEVER_TWO_UP_HEIGHT = 1000
   LEVER_TWO_UP_SPEED = 0
   
   %%%%%%%%%%%%%%%%%%%% SPIKES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   % How do spikes function in this room?
   SPIKES_DORMANT_TIME = 5000
   SPIKES_ACTIVE_TIME = 2000
   SPIKES_DELAY_IF_SEQUENCE = 500
   SPIKES_SOUND_RADIUS = 10
   SPIKES_DAMAGE = 40
   
   %%%%%%%%%%%%%%%%%%%% TOTEMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   % Totem respawn time in this room
   TOTEM_RESPAWN_TIME = 7000
   
   %%%%%%%%%%%%%%%%%%%% LAVA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   % Lava settings in this room
   LAVA_BURN_TIME = 200
   LAVA_DAMAGE = 500
   LAVA_BURN_APPLIED = 500

   %%%%%%%%%%%%%%%%%%%% SAWBLADES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   % Sawblade settings
   SAWBLADE_FULL_CYCLE_TIME = 3900
   SAWBLADE_DAMAGE_TIME = 30
   SAWBLADE_DORMANT_TIME = 2000
   SAWBLADE_DAMAGE = 1
   SAWBLADE_SPEED = 10

properties:

   prMusic = maze_music1

   piBaseLight = LIGHT_MIN
   piOutside_factor = OUTDOORS_NONE 

   prRoom = room_minotaurmazeroom
   piRoom_num = RID_MINOTAURMAZEROOM
   
   % of the format [[trigger sectors], [crusher sectors], timer, state, type, down height, down speed, up height, up speed, wall ID]
   plCrusherStates = $

   % of the format [[trigger sectors], [open sectors], type, height, speed, repeatable type]
   plSecretDoors = $
   
   % of the format [[pain sectors], down wall id, up wall id, timer, state, behavior, sound row, sound col]
   plSpikeStates = $
   
   % Totems that cast curses and bolts on players in sight/range
   % of the format [totem object, spell ID, respawn timer, row, col]
   plTotems = $

   % These areas inflict burning status effects
   % of the format [[pain sectors]]
   plLavaSectors = $
   ptLavaBurnTimer = $
   
   % Two invisible objects, SomethingShot between them
   plDartTraps = $
   
   % Cross this line and it damages you
   % of the format [[trigger sectors], [damage sectors], wall id, nopass id, cycle timer, damage timer, nonpassable wall ID]
   plSawbladeStates = $

   piOverridesDeathFunction = TRUE

messages:

   CreateStandardObjects()
   {
      Send(self,@CreateMazeRoomObjects);

      propagate;
   }

   CreateMazeRoomObjects()
   {
      local i;

      Send(self,@NewHold,#what=Create(&Lever),
            #new_row=3,#new_col=12,#fine_row=35,#fine_col=46);

      Send(self,@NewHold,#what=Create(&Lever),
            #new_row=25,#new_col=30,#fine_row=7,#fine_col=43);

      plCrusherStates = Cons([[2],                          % Trigger sectors
                           [3],                             % Crusher sectors
                           $,
                           TRAP_READY,
                           ANIMATE_CEILING_LIFT,
                           1050,                            % down height
                           220,                             % down speed
                           1160,                            % up height
                           11,                              % up speed
                           4                               % nopass Wall ID for Crusher
                           ],plCrusherStates);
      
      plSecretDoors = Cons([[4],                          % Trigger sectors
                            [5],                          % Door sector
                            ANIMATE_FLOOR_LIFT,
                            1000,                         % Height
                            50,                           % Speed
                            SECRET_DOOR_ONLY_ONCE],plSecretDoors);
      
      plSpikeStates = Cons([[8],                            % Pain sectors
                            9,                              % down wall ID
                            10,                             % Up wall ID
                            $,
                            SPIKES_DORMANT,
                            SPIKES_SIMULTANEOUS,
                            8,                              % sound row
                            52                              % sound col
                            ],plSpikeStates);

      plLavaSectors = Cons(50,plLavaSectors);               % Lava pain sectors
                             

      plSawbladeStates = Cons([[68],                              % Trigger sectors
                               [69],                              % Damage sectors
                               70,                                % Sawblade walls ID
                               71,                                % Sawblade no pass ID
                               $,
                               $,
                               8,                                 % Sound row
                               32                                 % Sound col
                               ],plSawbladeStates);

      plTotems = Cons([SID_LIGHTNING_BOLT,                   % Spell ID
                       $,
                       $,
                       12,                                   % Row
                       34,                                   % Col
                       8,                                    % Fine Row
                       15                                    % Fine Col
                       ],plTotems);

      return;
   }

   Delete()
   {
      local i, oThing;

      foreach i in Send(self,@GetHolderPassive)
      {
         oThing = Send(self,@HolderExtractObject,#data=i);
         if IsClass(oThing,&DeadBody)
            AND NOT Send(oThing,@GetPbMob)
         {
            % is a player corpse! Let's move it.
            Send(Send(SYS,@FindRoomByNum,#num=RID_DESERTDUNES),@Teleport,#what=oThing);
         }
      }
      
      foreach i in plCrusherStates
      {
         if Nth(i,3) <> $
            AND IsTimer(Nth(i,3))
         {
            DeleteTimer(Nth(i,3));
         }
         SetNth(i,3,$);
         plCrusherStates = DelListElem(plCrusherStates,i);
      }

      foreach i in plSawbladeStates
      {
         if Nth(i,5) <> $
            AND IsTimer(Nth(i,5))
         {
            DeleteTimer(Nth(i,5));
         }
         SetNth(i,5,$);

         if Nth(i,6) <> $
            AND IsTimer(Nth(i,6))
         {
            DeleteTimer(Nth(i,6));
         }
         SetNth(i,6,$);
      }

      propagate;
   }

% ============
% SOUNDS
% ============

   SetMusic(music_choice=1)
   {
      local i, each_obj;

      switch(music_choice)
      {
         case 1:
            prMusic = maze_music1;
            break;
         case 2:
            prMusic = maze_music2;
            break;
         case 3:
            prMusic = maze_music3;
            break;
      }

      foreach i in Send(self,@GetHolderActive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Player)
         {
            Send(each_obj,@SendRoomMusic,#music_rsc=prMusic);
         }
      }
      return;
   }

   PlayLiftSound(row=$,col=$,cutoff_radius=10)
   {
      if row = $
         OR col = $
      {
         Send(self,@SomethingWaveRoom,#wave_rsc=maze_lift_sound);
      }
      else
      {
         Send(self,@SomethingWaveRoomCoords,#wave_rsc=maze_lift_sound,#row=row,#col=col,#cutoff_radius=cutoff_radius);
      }
      return;
   }
   
   PlayClickSound(row=$,col=$,cutoff_radius=10)
   {
      if row = $
         OR col = $
      {
         Send(self,@SomethingWaveRoom,#wave_rsc=maze_click_sound);
      }
      else
      {
         Send(self,@SomethingWaveRoomCoords,#wave_rsc=maze_click_sound,#row=row,#col=col,#cutoff_radius=cutoff_radius);
      }
      return;
   }
   
   PlayTrapSlamSound(row=$,col=$,cutoff_radius=10)
   {
      if row = $
         OR col = $
      {
         Send(self,@SomethingWaveRoom,#wave_rsc=maze_trap_slam);
      }
      else
      {
         Send(self,@SomethingWaveRoomCoords,#wave_rsc=maze_trap_slam,#row=row,#col=col,#cutoff_radius=cutoff_radius);
      }
      return;
   }
   
   PlaySpikeSound(row=-1,col=-1,cutoff_radius=10)
   {
      if row = $
         OR col = $
      {
         return;
      }

      if row = -1
         OR col = -1
      {
         Send(self,@SomethingWaveRoom,#wave_rsc=maze_spike_rise);
      }
      else
      {
         Send(self,@SomethingWaveRoomCoords,#wave_rsc=maze_spike_rise,#row=row,#col=col,#cutoff_radius=cutoff_radius);
      }
      return;
   }

   PlaySawbladeSound(row=-1,col=-1,cutoff_radius=10)
   {
      if row = -1
         OR col = -1
      {
         Send(self,@SomethingWaveRoom,#wave_rsc=maze_sawblade_rise);
      }
      else
      {
         Send(self,@SomethingWaveRoomCoords,#wave_rsc=maze_sawblade_rise,#row=row,#col=col,#cutoff_radius=cutoff_radius);
      }
      return;
   }

% ============
% MOVEMENT EVALUATION
% ============

   FirstUserEntered()
   {
      Send(self,@StartSpikeCycle);
      Send(self,@PlaceTotems);
      Send(self,@StartLava);

      propagate;
   }

   LastUserLeft()
   {
      Send(self,@EndSpikeCycle);
      Send(self,@RemoveTotems);
      Send(self,@EndLava);

      propagate;
   }

   SomethingMoved(what = $,new_row = $, new_col = $)
   {
      if NOT IsClass(what,&Player)
      {
         propagate;
      }

      Send(self,@EvaluateMovement,#who=what,#section=Send(self,@GetSection,#who=what));

      propagate;
   }
   
   EvaluateMovement(who=$,section=0)
   {
      local i;

      foreach i in plSawbladeStates
      {
         if FindListElem(Nth(i,1),section) <> 0
         {
            Send(self,@TriggerSawblade,#trap_data=i);
         }
      }
      
      foreach i in plCrusherStates
      {
         if FindListElem(Nth(i,1),section) <> 0
            AND Nth(i,4) = TRAP_READY
         {
            SetNth(i,4,TRAP_TRIGGERED);
            Send(self,@PlayClickSound);
            SetNth(i,3,CreateTimer(self,@TriggerCrusher,TRAP_TRIGGERED_DELAY));
         }
      }
      
      foreach i in plSecretDoors
      {
         if FindListElem(Nth(i,1),section) <> 0
         {
            Send(self,@LowerSecretDoor,#trap_data=i);
            
            if Nth(i,6) = SECRET_DOOR_ONLY_ONCE
            {
               % Don't keep track of this anymore, it's been opened.
               plSecretDoors = DelListElem(plSecretDoors,i);
            }
         }
      }

      return;
   }

   GetSection(who=$,iRow=$,iCol=$,iFineRow=$,iFineCol=$,bCheckForPool=FALSE)
   {
      local iQflags, iRflags, iHeightF, iHeightFWD, iHeightC, iServerID;
      
      if iRow = $
         OR iCol = $
         OR iFineRow = $
         OR iFineCol = $
      {
         if who <> $
         {
            iRow = Send(who,@GetRow);
            iCol = Send(who,@GetCol);
            iFineRow = Send(who,@GetFineRow);
            iFineCol = Send(who,@GetFineCol);
         }
         else
         {
            return 0;
         }
         if iRow = $
            OR iCol = $
            OR iFineRow = $
            OR iFineCol = $
         {
            % Who gave us some nil coords.
            return 0;
         }
      }

      iQflags = LIQ_GET_SECTORINFO;

      if GetLocationInfoBSP(
                      prmRoom, iQflags, iRow, iCol, iFineRow, iFineCol,
                      *iRflags, *iHeightF, *iHeightFWD, *iHeightC, *iServerID)
      {
         return iServerID;
      }

      return 0;
   }

   % This function can tell us the height of sectors that have been altered.
   % If no alteration over starting conditions, returns $.
   % Send ANIMATE_FLOOR_LIFT or ANIMATE_CEILING_LIFT to check floor or ceiling.
   GetChangedHeightOfSector(sector_id=-1,type=ANIMATE_FLOOR_LIFT)
   {
      local i;
      
      foreach i in Send(self,@GetSectorChanges)
      {
         if sector_id = Nth(i,1)
            AND type = Nth(i,2)
         {
            return Nth(i,3);
         }
      }

      return $;
   }

% ============
% LEVERS
% ============

   SomethingChanged(what=$)
   {
      if what <> $
         AND IsClass(what,&Lever)
      {
         Send(self,@LeverPulled,#lever_object=what);
      }

      propagate;
   }

   LeverPulled(lever_object=$)
   {
      if lever_object <> $
      {
         if Send(lever_object,@GetRow) = LEVER_ONE_ROW
         {
            if Send(lever_object,@GetState) = LEVER_DOWN
            {
               Send(self,@SetSector,#sector=LEVER_ONE_ACTIVATES_SECTOR,
                                    #animation=LEVER_ONE_TYPE,
                                    #height=LEVER_ONE_DOWN_HEIGHT,
                                    #speed=LEVER_ONE_DOWN_SPEED);
            }
            else
            {
               Send(self,@SetSector,#sector=LEVER_ONE_ACTIVATES_SECTOR,
                                    #animation=LEVER_ONE_TYPE,
                                    #height=LEVER_ONE_UP_HEIGHT,
                                    #speed=LEVER_ONE_UP_SPEED);
            }
         }

         if Send(lever_object,@GetRow) = LEVER_TWO_ROW
         {
            if Send(lever_object,@GetState) = LEVER_DOWN
            {
               Send(self,@SetSector,#sector=LEVER_TWO_ACTIVATES_SECTOR,
                                    #animation=LEVER_TWO_TYPE,
                                    #height=LEVER_TWO_DOWN_HEIGHT,
                                    #speed=LEVER_TWO_DOWN_SPEED);
            }
            else
            {
               Send(self,@SetSector,#sector=LEVER_TWO_ACTIVATES_SECTOR,
                                    #animation=LEVER_TWO_TYPE,
                                    #height=LEVER_TWO_UP_HEIGHT,
                                    #speed=LEVER_TWO_UP_SPEED);
            }
         }
      }
      Send(self,@PlayLiftSound);
      return;
   }

% ============
% CRUSHERS
% ============

   TriggerCrusher(timer=$)
   {
      local i, n;
      
      foreach i in plCrusherStates
      {
         if timer = Nth(i,3)
         {
            SetNth(i,3,$);
            SetNth(i,4,TRAP_ACTING);
            Send(self,@PlayTrapSlamSound);
            SetNth(i,3,CreateTimer(self,@HitCrusher,TRAP_ACTING_DELAY));
            
            foreach n in Nth(i,2)
            {
               Send(self,@SetSector,#sector=n,
                                    #animation=Nth(i,5),
                                    #height=Nth(i,6),
                                    #speed=Nth(i,7));
            }
         }
      }
      return;
   }

   HitCrusher(timer=$)
   {
      local i, n, each_obj;
      
      foreach i in plCrusherStates
      {
         if timer = Nth(i,3)
         {
            SetNth(i,3,$);
            SetNth(i,4,TRAP_HIT);
            SetNth(i,3,CreateTimer(self,@RetreatCrusher,TRAP_HIT_DELAY));
            Send(self,@AnimateWall,#wall=Nth(i,10),#animation=ANIMATE_NONE,#first_group=1,#passable=FALSE);
      
            foreach n in Send(self,@GetHolderActive)
            {
               each_obj = Send(self,@HolderExtractObject,#data=n);
               if IsClass(each_obj,&Player)
                  AND FindListElem(Nth(i,2),Send(self,@GetSection,#who=each_obj)) <> 0
               {
                  Send(each_obj,@MsgSendUser,#message_rsc=trap_damages_you);
                  Send(each_obj,@LoseHealth,#amount=TRAP_DAMAGE);
                  Send(Send(SYS,@FindSpellByNum,#num=SID_EVENT_HOLD),@DoSpell,
                        #what=self,#oTarget=each_obj,#iDuration=TRAP_HIT_DELAY,#report=FALSE);
                  Send(each_obj,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=TRAP_HIT_DELAY);
               }
            }
         }
      }

      return;
   }
   
   RetreatCrusher(timer=$)
   {
      local i, n;
      
      foreach i in plCrusherStates
      {
         if timer = Nth(i,3)
         {
            SetNth(i,3,$);
            SetNth(i,4,TRAP_RETREATING);
            Send(self,@AnimateWall,#wall=Nth(i,10),#animation=ANIMATE_NONE,#first_group=1,#passable=TRUE);
            SetNth(i,3,CreateTimer(self,@ResetCrusher,TRAP_RETREATING_DELAY));
            
            foreach n in Nth(i,2)
            {
               Send(self,@SetSector,#sector=n,#animation=Nth(i,5),#height=Nth(i,8),#speed=Nth(i,9));
            }
         }
      }
      return;
   }
   
   ResetCrusher(timer=$)
   {
      local i;
      
      foreach i in plCrusherStates
      {
         if timer = Nth(i,3)
         {
            SetNth(i,3,$);
            SetNth(i,4,TRAP_READY);
         }
      }
      return;
   }

% ============
% SECRET DOORS
% ============
   
   LowerSecretDoor(trap_data=$)
   {
      local i;

      if Send(self,@GetChangedHeightOfSector,#sector_id=First(Nth(trap_data,2)),#type=Nth(trap_data,3)) <> Nth(trap_data,4)
      {
         Send(self,@PlayLiftSound);
         
         foreach i in Nth(trap_data,2)
         {
            Send(self,@SetSector,#sector=i,
                                 #animation=Nth(trap_data,3),
                                 #height=Nth(trap_data,4),
                                 #speed=Nth(trap_data,5));
         }
      }

      return;
   }

% ============
% SPIKES
% ============
   
   StartSpikeCycle()
   {
      local i, iSequenceDelay;
      
      iSequenceDelay = 0;
      foreach i in plSpikeStates
      {
         % Make dormant spikes visible
         Send(self,@ChangeTexture,#id=Nth(i,2),#new_texture=spikes_texture,#flags=CTF_NORMALWALL);

         switch(Nth(i,6))
         {
            case SPIKES_SIMULTANEOUS:
               SetNth(i,4,CreateTimer(self,@RaiseSpikes,SPIKES_DORMANT_TIME));
               break;
            case SPIKES_IN_SEQUENCE:
               SetNth(i,4,CreateTimer(self,@RaiseSpikes,SPIKES_DORMANT_TIME+iSequenceDelay*SPIKES_DELAY_IF_SEQUENCE));
               iSequenceDelay++;
               break;
         }
            
      }
      return;
   }

   EndSpikeCycle()
   {
      local i;

      foreach i in plSpikeStates
      {
         if IsTimer(Nth(i,4))
         {
            DeleteTimer(Nth(i,4));
         }
         SetNth(i,4,$);
         SetNth(i,5,SPIKES_DORMANT);
            
         Send(self,@ChangeTexture,#id=Nth(i,2),#new_texture=blank_texture,#flags=CTF_NORMALWALL);
         Send(self,@ChangeTexture,#id=Nth(i,3),#new_texture=blank_texture,#flags=CTF_NORMALWALL);
         Send(self,@AnimateWall,#wall=Nth(i,2),#animation=ANIMATE_NONE,#first_group=2,#passable=TRUE);
         Send(self,@AnimateWall,#wall=Nth(i,3),#animation=ANIMATE_NONE,#first_group=2,#passable=TRUE);
      }

      return;
   }

   RaiseSpikes(timer=$)
   {
      local i, n, each_obj;

      foreach i in plSpikeStates
      {
         if timer = Nth(i,4)
         {
            SetNth(i,4,$);
            SetNth(i,5,SPIKES_ACTIVE);

            Send(self,@PlaySpikeSound,#row=Nth(i,7),#col=Nth(i,8),#cutoff_radius=SPIKES_SOUND_RADIUS);
            
            Send(self,@ChangeTexture,#id=Nth(i,2),#new_texture=blank_texture,#flags=CTF_NORMALWALL);
            Send(self,@ChangeTexture,#id=Nth(i,3),#new_texture=spikes_texture,#flags=CTF_NORMALWALL);
            Send(self,@AnimateWall,#wall=Nth(i,2),#animation=ANIMATE_NONE,#first_group=2,#passable=FALSE);
            Send(self,@AnimateWall,#wall=Nth(i,3),#animation=ANIMATE_NONE,#first_group=2,#passable=FALSE);

            foreach n in Send(self,@GetHolderActive)
            {
               each_obj = Send(self,@HolderExtractObject,#data=n);
               if IsClass(each_obj,&Player)
                  AND FindListElem(Nth(i,1),Send(self,@GetSection,#who=each_obj)) <> 0
               {
                  Send(each_obj,@MsgSendUser,#message_rsc=spikes_damage_you);
      
                  Send(each_obj,@LoseHealth,#amount=SPIKES_DAMAGE);
                  Send(each_obj,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=SPIKES_PAIN_TIME);
               }
            }
            
            SetNth(i,4,CreateTimer(self,@LowerSpikes,SPIKES_ACTIVE_TIME));
         }
      }

      return;
   }
   
   LowerSpikes(timer=$)
   {
      local i;

      foreach i in plSpikeStates
      {
         if timer = Nth(i,4)
         {
            SetNth(i,4,$);
            SetNth(i,5,SPIKES_DORMANT);
            
            Send(self,@ChangeTexture,#id=Nth(i,2),#new_texture=spikes_texture,#flags=CTF_NORMALWALL);
            Send(self,@ChangeTexture,#id=Nth(i,3),#new_texture=blank_texture,#flags=CTF_NORMALWALL);
            Send(self,@AnimateWall,#wall=Nth(i,2),#animation=ANIMATE_NONE,#first_group=2,#passable=TRUE);
            Send(self,@AnimateWall,#wall=Nth(i,3),#animation=ANIMATE_NONE,#first_group=2,#passable=TRUE);
            
            SetNth(i,4,CreateTimer(self,@RaiseSpikes,SPIKES_DORMANT_TIME));
         }
      }
      return;
   }

% ============
% TOTEMS
% ============

   PlaceTotems()
   {
      local i;
      
      foreach i in plTotems
      {
         if Nth(i,2) <> $
         {
            continue;
         }

         SetNth(i,2,Create(&MazeTotem,#iSpellID=Nth(i,1)));
         Send(self,@NewHold,#what=Nth(i,2),
                            #new_row=Nth(i,4),
                            #new_col=Nth(i,5),
                            #fine_row=Nth(i,6),
                            #fine_col=Nth(i,7));
      }

      return;
   }

   TotemKilled(totem_object=$)
   {
      local i;
      
      foreach i in plTotems
      {
         if totem_object = Nth(i,2)
         {
            SetNth(i,2,$);
            SetNth(i,3,CreateTimer(self,@RespawnTotem,TOTEM_RESPAWN_TIME));
         }
      }

      return;
   }

   RespawnTotem(timer=$)
   {
      local i;
      
      foreach i in plTotems
      {
         if timer = Nth(i,3)
         {
            SetNth(i,3,$);
            SetNth(i,2,Create(&MazeTotem,#iSpellID=Nth(i,1)));
            Send(self,@NewHold,#what=Nth(i,2),
                               #new_row=Nth(i,4),
                               #new_col=Nth(i,5),
                               #fine_row=Nth(i,6),
                               #fine_col=Nth(i,7));
         }
      }

      return;
   }
   
   RemoveTotems()
   {
      local i;
      
      foreach i in plTotems
      {
         if Nth(i,2) <> $
         {
            Send(Nth(i,2),@Delete);
            SetNth(i,2,$);
         }
         if Nth(i,3) <> $
         {
            if IsTimer(Nth(i,3))
            {
               DeleteTimer(Nth(i,3));
            }
            SetNth(i,3,$);
         }
      }

      return;
   }

% ============
% LAVA
% ============

   StartLava()
   {
      local i;

      foreach i in plLavaSectors
      {
         % Set up the lava
         Send(self,@SetSector,#sector=i,#animation=ANIMATE_FLOOR_LIFT,#height=995,#speed=0);
         Send(self,@ChangeTexture,#id=i,#new_texture=maze_lava_texture,#flags=CTF_FLOOR);
      }

      if plLavaSectors <> $
      {
         ptLavaBurnTimer = CreateTimer(self,@DoLava,LAVA_BURN_TIME);
      }

      return;
   }

   DoLava(timer=$)
   {
      local i, each_obj;

      ptLavaBurnTimer = $;

      foreach i in Send(self,@GetHolderActive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Player)
            AND FindListElem(plLavaSectors,Send(self,@GetSection,#who=each_obj)) <> 0
         {
            Send(each_obj,@MsgSendUser,#message_rsc=lava_applying_burn);
            Send(each_obj,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,#duration=100,#xlat=81);
            Send(each_obj,@ApplyElementalStatusEffects,#damage=LAVA_BURN_APPLIED,#aspell=ATCK_SPELL_FIRE);
         }
      }

      ptLavaBurnTimer = CreateTimer(self,@DoLava,LAVA_BURN_TIME);
      return;
   }

   EndLava()
   {
      local i;

      foreach i in plLavaSectors
      {
         % Remove the lava
         Send(self,@SetSector,#sector=i,#animation=ANIMATE_FLOOR_LIFT,#height=1000,#speed=0);
         Send(self,@RemoveTextureChange,#id=i);
      }

      if ptLavaBurnTimer <> $
      {
         DeleteTimer(ptLavaBurnTimer);
      }
      ptLavaBurnTimer = $;
      return;
   }

% ============
% SAWBLADES
% ============

   TriggerSawblade(trap_data=$)
   {
      local i;
      
      % Ensure we are ready aka no activated or deactivated timer
      if Nth(trap_data,5) = $
      {
         Send(self,@ChangeTexture,#id=Nth(trap_data,3),#new_texture=sawblade_trap_texture,#flags=CTF_NORMALWALL);
         Send(self,@AnimateWall,#wall=Nth(trap_data,3),
                                #animation=ANIMATE_CYCLE,
                                #first_group=1,
                                #second_group=241,
                                #end_group=241,
                                #speed=SAWBLADE_SPEED);
         Send(self,@AnimateWall,#wall=Nth(trap_data,4),#animation=ANIMATE_NONE,#first_group=1,#passable=FALSE);
         Send(self,@PlaySawbladeSound,#row=Nth(trap_data,7),#col=Nth(trap_data,8));

         SetNth(trap_data,5,CreateTimer(self,@DeactivateSawblade,SAWBLADE_FULL_CYCLE_TIME));
         SetNth(trap_data,6,CreateTimer(self,@DealSawbladeDamage,SAWBLADE_DAMAGE_TIME));
      }

      return;
   }

   DeactivateSawblade(timer=$)
   {
      local i;
      
      foreach i in plSawbladeStates
      {
         if timer = Nth(i,5)
         {
            SetNth(i,5,$);

            Send(self,@ChangeTexture,#id=Nth(i,3),#new_texture=blank_texture,#flags=CTF_NORMALWALL);
            Send(self,@AnimateWall,#wall=Nth(i,3),
                                   #animation=ANIMATE_NONE,
                                   #first_group=1,
                                   #second_group=1,
                                   #end_group=1);
            Send(self,@AnimateWall,#wall=Nth(i,4),#animation=ANIMATE_NONE,#first_group=1,#passable=TRUE);
            
            % Turn off damage timer
            if Nth(i,6) <> $
               AND IsTimer(Nth(i,6))
            {
               DeleteTimer(Nth(i,6));
            }
            SetNth(i,6,$);
            
            SetNth(i,5,CreateTimer(self,@ReactivateSawblade,SAWBLADE_DORMANT_TIME));
         }
      }

      return;
   }

   DealSawbladeDamage(timer=$)
   {
      local i, n, each_obj;

      foreach i in plSawbladeStates
      {
         if timer = Nth(i,6)
         {
            SetNth(i,6,$);
            foreach n in Send(self,@GetHolderActive)
            {
               each_obj = Send(self,@HolderExtractObject,#data=n);
               if IsClass(each_obj,&Player)
                  AND FindListElem(Nth(i,2), Send(self,@GetSection,#who=each_obj)) <> 0
               {
                  Send(each_obj,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=1000);
                  Send(each_obj,@LoseHealth,#amount=SAWBLADE_DAMAGE);
               }
            }
            SetNth(i,6,CreateTimer(self,@DealSawbladeDamage,SAWBLADE_DAMAGE_TIME));
         }
      }
      return;
   }
   
   ReactivateSawblade(timer=$)
   {
      local i;
      
      foreach i in plSawbladeStates
      {
         if timer = Nth(i,5)
         {
            SetNth(i,5,$);
         }
      }

      return;
   }

% ============
% GENERAL
% ============

   CanHavePlayerPortal()
   {
      return FALSE;
   }

   CanTokenEnterRoom()
   {
      return FALSE;
   }

   GetRegion()
   {
      return RID_DESERT;
   }
   
   OverrideDeathFunction(who=$,what=$,stroke_obj=$)
   {
      local oAfterlife, bDrop, oRoom, iRow, iCol, iFine_Row, iFine_Col, iAngle, iRoom,
            oBody, lReagentBagContents, lInventoryContents, lItems, i, oSoldierShield;

      Send(who,@ClearStance);
      % Stop any rescue attempts that were going on.
      Send(who,@CancelRescue);
      Send(who,@RemoveAllEnchantments,#report=FALSE);
      
      Send(who,@SetDeathTime,#iTime=GetTime());

      % Grab the location of the deceased.
      % Might need to grab the old location if logged off.

      if Send(who,@IsLoggedOn)
      {
         oRoom = Send(who,@GetOwner);
         iRow = Send(who,@GetRow);
         iCol = Send(who,@GetCol);
         iFine_Row = Send(who,@GetFineRow);
         iFine_Col = Send(who,@GetFineCol);
         iAngle = Send(who,@GetAngle);
         iRoom = Send(Send(who,@GetOwner),@GetRoomNum);
      }
      else
      {
         iRoom = Send(who,@GetSaveRoom);
         oRoom = Send(SYS,@FindRoomByNum,#num=iRoom);
         iRow = Send(who,@GetSaveRow);
         iCol = Send(who,@GetSaveCol);
         iFine_Row = Send(who,@GetSaveFineRow);
         iFine_Col = Send(who,@GetSaveFineCol);
         iAngle = Send(who,@GetSaveAngle);
      }

      % Record-keeping. Keep this before the token check,
      % so we can give proper message.
      Send(SYS,@UserKilled,#what=who,#killer=what,#oRoom=oRoom,#stroke_obj=stroke_obj);
      Send(Send(SYS,@GetStatistics),@PlayerDiedCounter);

      % Create the corpse.
      if what <> $
         AND IsClass(what,&User)
      {
         oBody = Send(who,@CreateCorpse,#oPlayerKiller=what);
      }
      else
      {
         oBody = Send(who,@CreateCorpse);
      }
      Send(who,@SetCorpse,#corpse=oBody);

      Send(oRoom,@NewHold,#what=oBody,#new_row=iRow,#new_col=iCol,
            #fine_row=iFine_Row,#fine_col=iFine_Col,#new_angle=iAngle);

      bDrop = TRUE;
      % Start losing stuff if applicable.
      if bDrop
      {
         lReagentBagContents = Send(who,@GetReagentBagContents);
         if lReagentBagContents <> $
         {
            lInventoryContents = [Send(who,@GetHolderActive),Send(who,@GetHolderPassive),lReagentBagContents];
         }
         else
         {
            lInventoryContents = [Send(who,@GetHolderActive),Send(who,@GetHolderPassive)];
         }

         foreach lItems in lInventoryContents
         {
            foreach i in lItems
            {
               % Let the item know we died, in case it does something special.
               Send(i,@OwnerKilled);

               if Send(i,@DropOnDeath)
               {
                  if Send(oRoom,@ReqNewHold,#what=i,#new_row=iRow,#new_col=iCol)
                  {
                     Send(oBody,@NewHold,#what=i);
                  }
               }
            }
         }

         Post(who,@EvaluatePKStatus);

         % Let SoldierShields know we died. It handles itself as appropriate.
         oSoldierShield = Send(who,@FindUsing,#what=&SoldierShield);
         if oSoldierShield <> $
         {
            Send(oSoldierShield,@OwnerDied,#what=what);
         }
      }

      % Give out your dying scream.
      if Send(who,@GetGender) = GENDER_FEMALE
      {
         i = Send(who,@GetFemaleDeathWav);
      }
      else
      {
         i = Send(who,@GetMaleDeathWav);
      }

      Send(oRoom,@SomethingWaveRoom,#what=oBody,#wave_rsc=i);
      if Send(who,@IsLoggedOn)
      {
         Send(who,@WaveSendUser,#what=who,#wave_rsc=i);
      }

      Send(who,@SetHealth,#amount=1);

      Send(who,@NewHealth);
      Send(who,@NewMana);
      Send(who,@NewVigor);
      
      Send(who,@SetDeathCost,#DeathCost=Send(Send(SYS,@GetDesertRoomMaintenance),@GetDeathCost),#bOverride=TRUE);
      Send(who,@ApplyDeathPenalties);

      % Refresh the client with what's really going on.
      if Send(who,@IsLoggedOn)
      {
         Send(who,@ToCliStats,#group=1);
         Send(who,@ToCliStats,#group=2);
         Send(who,@ToCliStats,#group=3);
         Send(who,@ToCliStats,#group=4);

         % Wake up with red foggy hangover.
         Send(who,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=5000);
      }
      
      oAfterlife = Send(SYS,@FindRoomByNum,#num=RID_DESERTALDUNES);
      
      if IsClass(self,&DesertDunesRoom)
      {
         Send(SYS,@UtilGoNearSquare,#what=who,
                                    #where=oAfterlife,
                                    #new_row=iRow,
                                    #new_col=iCol,
                                    #fine_row=iFine_Row,
                                    #fine_col=iFine_Col,
                                    #new_angle=iAngle);
      }
      else
      {
         Send(oAfterlife,@Teleport,#what=who);
      }
      return;
   }

   ReqSpellCast(who = $, oSpell = $, lItems = $)
   {
      if IsClass(oSpell,&DeathRift)
         OR IsClass(oSpell,&PortalOfLife)
      {
         Send(who,@MsgSendUser,#message_rsc=cannot_death_rift_or_pol);
         return FALSE;
      }

      propagate;
   }

   OverridesDeathAllowPhasing()
   {
      return TRUE;
   }

% ==================================================================================================================
% ==================================================================================================================
% SPECIFIC FUNCTIONS
% ==================================================================================================================
% ==================================================================================================================

% ============
% OTHER
% ============

   SendPlayersToNextRoom()
   {
      local i, each_obj;

%      ptNextRoomTimer = $;
      
      foreach i in Send(self,@GetHolderActive)
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Player)
            AND Send(self,@GetSection,#who=each_obj) = LEVER_TWO_ACTIVATES_SECTOR
         {
            Send(Send(SYS,@FindRoomByNum,#num=RID_MAZE1),@Teleport,#what=each_obj);
         }
      }
      Send(self,@SetSector,#sector=LEVER_TWO_ACTIVATES_SECTOR,
                           #animation=LEVER_TWO_TYPE,
                           #height=LEVER_TWO_UP_HEIGHT,
                           #speed=LEVER_TWO_UP_SPEED);
      
      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
