% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
UnderseaChamber is Room

constants:

   include blakston.khd

resources:

   room_Undersea_Chamber = underseachamberdeath.roo
   
   Undersea_Chamber_name = "Chamber in the Sea Palace"
   Undersea_Chamber_music = aamusic2.mp3
   
   Undersea_Chamber_next_locked = \
      "The gate to the next chamber is locked!"
   door_to_next_undersea_chamber_opens = \
      "The gears behind the walls go silent."

classvars:

   vrName = Undersea_Chamber_name

   viTeleport_row = 13
   viTeleport_col = 7
   
   viLongitude = 5000
   viLatitude = 5000

properties:

   prMusic = Undersea_Chamber_music
   prRoom = room_Undersea_Chamber
   
   plMonsterTypes = $
   
   % Of the form [CLASS, #] [CLASS, #]
   plChamberSpawns = $
   plSpawnPoints = $
   
   ptSpawnTimer = $
   
   pbNextDoorOpen = FALSE
   
   piMonsterLevel = 20
   
   piRuneNum = 0

messages:

   Constructor(iRID=RID_UNDERSEA_PALACE_START,oRune=$)
   {
      piRoom_num = iRID;
      
      if oRune <> $
      {
         piMonsterLevel = Send(oRune,@GetItemLevel);
         piRuneNum = Send(oRune,@GetRuneNumber);
      }

      Send(self,@RecalcLightAndWeather);
      
      Send(self,@BuildSpawnList,#oRune=oRune);

      propagate;
   }

   CanHavePlayerPortal()
   {
      return FALSE;
   }

   GetNextDoorOpen()
   {
      return pbNextDoorOpen;
   }

   BuildSpawnList(oRune=$)
   {
      local i, iSpawnRate, iRuneNumber;
      
      iRuneNumber = Send(oRune,@GetRuneNumber);
      plMonsterTypes = $;
      
      Switch(iRuneNumber)
      {
         case OCEANIC_RUNE_DEATH:
            plMonsterTypes = Cons(&DaemonSkeleton,plMonsterTypes);
            plMonsterTypes = Cons(&Zombie,plMonsterTypes);
            plMonsterTypes = Cons(&ShadowMummy,plMonsterTypes);
            break;
         case OCEANIC_RUNE_CHAINED:
            plMonsterTypes = Cons(&DaemonSkeleton,plMonsterTypes);
            plMonsterTypes = Cons(&Zombie,plMonsterTypes);
            plMonsterTypes = Cons(&SpectralMummy,plMonsterTypes);
            break;
         case OCEANIC_RUNE_SKY:
            plMonsterTypes = Cons(&AvarChieftain,plMonsterTypes);
            plMonsterTypes = Cons(&AirElemental,plMonsterTypes);
            plMonsterTypes = Cons(&XeoAir,plMonsterTypes);
            break;
         case OCEANIC_RUNE_FRACTURED:
            plMonsterTypes = Cons(&XeoNeru,plMonsterTypes);
            plMonsterTypes = Cons(&XeoIll,plMonsterTypes);
            plMonsterTypes = Cons(&XeoHoly,plMonsterTypes);
            break;
         case OCEANIC_RUNE_HAMMER:
            plMonsterTypes = Cons(&Slime,plMonsterTypes);
            plMonsterTypes = Cons(&Scorpion,plMonsterTypes);
            plMonsterTypes = Cons(&RedAnt,plMonsterTypes);
            break;
         case OCEANIC_RUNE_HEXED:
            plMonsterTypes = Cons(&Shadowbeast,plMonsterTypes);
            plMonsterTypes = Cons(&Zombie,plMonsterTypes);
            plMonsterTypes = Cons(&ShadowMummy,plMonsterTypes);
            break;
         case OCEANIC_RUNE_JUNGLE:
            plMonsterTypes = Cons(&AvarChieftain,plMonsterTypes);
            plMonsterTypes = Cons(&Kriipa,plMonsterTypes);
            plMonsterTypes = Cons(&DragonFly,plMonsterTypes);
            break;
         case OCEANIC_RUNE_MOUNTAIN:
            plMonsterTypes = Cons(&Troll,plMonsterTypes);
            plMonsterTypes = Cons(&SnowRat,plMonsterTypes);
            plMonsterTypes = Cons(&OrcWizard,plMonsterTypes);
            break;
         case OCEANIC_RUNE_SCALED:
            plMonsterTypes = Cons(&Lupogg,plMonsterTypes);
            plMonsterTypes = Cons(&NeruElemental,plMonsterTypes);
            plMonsterTypes = Cons(&GroundWormQueen,plMonsterTypes);
            break;
         case OCEANIC_RUNE_SEA:
            plMonsterTypes = Cons(&WaterCentipede,plMonsterTypes);
            plMonsterTypes = Cons(&WaterCentipede,plMonsterTypes);
            plMonsterTypes = Cons(&WaterCentipede,plMonsterTypes);
            %plMonsterTypes = Cons(&Slime,plMonsterTypes);
            %plMonsterTypes = Cons(&FungusBeast,plMonsterTypes);
            pbRoomHasAir = FALSE;
            pbIsUnderwater = TRUE;
            break;
         case OCEANIC_RUNE_SERPENT:
            plMonsterTypes = Cons(&NarthylWorm,plMonsterTypes);
            plMonsterTypes = Cons(&Chupacabra,plMonsterTypes);
            plMonsterTypes = Cons(&EarthElemental,plMonsterTypes);
            break;
         case OCEANIC_RUNE_SWORD:
            plMonsterTypes = Cons(&DaemonSkeleton,plMonsterTypes);
            plMonsterTypes = Cons(&Orc,plMonsterTypes);
            plMonsterTypes = Cons(&Thrasher,plMonsterTypes);
            break;
      }

      iSpawnRate = 100;
      %iSpawnRate = Send(Send(SYS,@FindRoomByNum,#num=RID_UNDERSEA_PALACE),@GetSpawnBoost);
      
      foreach i in plMonsterTypes
      {
         plChamberSpawns = Cons([i,(Random(1500,4000)*iSpawnRate)/10000],plChamberSpawns);
      }
      
      %foreach i in Send(Send(SYS,@FindRoomByNum,#num=RID_UNDERSEA_PALACE),@GetChamberSpawnAdds)
      %{
      %   plChamberSpawns = Cons([i,(Random(1500,4000)*iSpawnRate)/10000],plChamberSpawns);
      %}

      return;
   }
   
   GetPhaseThreats()
   {
      switch(piRuneNum)
      {
%         case OCEANIC_RUNE_DEATH:
%            return [&DeathPrismThreat];
         case OCEANIC_RUNE_MOUNTAIN:
            return [&HeatThreat];
         case OCEANIC_RUNE_SWORD:
            return [&VigorThreat];
         case OCEANIC_RUNE_SEA:
            return [&UnderwaterThreat];
      }
      return $;
   }
   
   FirstUserEntered()
   {
      ptSpawnTimer = CreateTimer(self,@SpawnMobs,500);
      propagate;
   }

   LastUserLeft()
   {
      if ptSpawnTimer <> $
      {
         DeleteTimer(ptSpawnTimer);
         ptSpawnTimer = $;
      }
      propagate;
   }

   SpawnMobs()
   {
      local i, oMonster, iChoice;
      
      ptSpawnTimer = $;
      
      if plChamberSpawns = $
      {
         return;
      }
      
      iChoice = Random(1,Length(plChamberSpawns));
      Send(self,@NewHold,#what=Create(Nth(Nth(plChamberSpawns,iChoice),1),#iSeaPalaceLevel=piMonsterLevel),
                         #new_row=Random(2,Send(self,@GetRoomRows)-2),
                         #new_col=Random(2,Send(self,@GetRoomCols)-2),
                         #fine_row=Random(1,63),#fine_col=Random(1,63));
      SetNth(Nth(plChamberSpawns,iChoice),2,Nth(Nth(plChamberSpawns,iChoice),2)-1);
      
      if Nth(Nth(plChamberSpawns,iChoice),2) <= 0
      {
         plChamberSpawns = DelListElem(plChamberSpawns,Nth(plChamberSpawns,iChoice));
      }
      
      if plChamberSpawns = $
      {
         return;
      }
      
      ptSpawnTimer = CreateTimer(self,@SpawnMobs,500);
      
      return;
   }

   SomethingTryGo(what=$, row=$, col=$)
   {
      local oRoom;

      if what <> $
         AND IsClass(what,&Player)
         AND row < 2
         AND col >= 6
         AND col <= 8
      {
         if NOT pbNextDoorOpen
         {
            Send(what,@MsgSendUser,#message_rsc=Undersea_Chamber_next_locked);
            return TRUE;
         }

         oRoom = Send(Send(SYS,@FindRoomByNum,#num=RID_UNDERSEA_PALACE),@GetCurrentUnfinishedRoom);
            
         if oRoom <> $
         {
            Send(oRoom,@NewHold,#what=what,#new_row=13,#new_col=7,#new_angle=Send(what,@GetAngle));
            return TRUE;
         }
      }

      if what <> $
         AND IsClass(what,&Player)
         AND row > 13
         AND col >= 6
         AND col <= 8
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=RID_UNDERSEA_PALACE);
            
         if oRoom <> $
         {
            Send(oRoom,@NewHold,#what=what,#new_row=2,#new_col=7,#new_angle=Send(what,@GetAngle));
            return TRUE;
         }
      }

      propagate;
   }

   SomethingKilled(what=$,victim=$)
   {
      if NOT pbNextDoorOpen
         AND IsClass(victim,&Monster)
         AND plChamberSpawns = $
      {
         Post(self,@CheckMonstersCleared);
      }
      propagate;
   }
   
   CheckMonstersCleared()
   {
      local oBattler;

      if NOT Send(self,@IsHostileMonsterInRoom)
         AND NOT pbNextDoorOpen
      {
         foreach oBattler in Send(self,@GetPlayersInRoom)
         {
            Send(oBattler,@MsgSendUser,#message_rsc=door_to_next_undersea_chamber_opens);
         }
         pbNextDoorOpen = TRUE;
      }

      return;
   }

   Delete()
   {
      if ptSpawnTimer <> $
      {
         DeleteTimer(ptSpawnTimer);
         ptSpawnTimer = $;
      }
      propagate;
   }

   GetMonsterLevel()
   {
      return piMonsterLevel;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
