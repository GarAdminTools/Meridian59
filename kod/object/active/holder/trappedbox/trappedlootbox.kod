% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TrappedLootBox is TrappedBox

%
% ID trap spell
% minor magical unlock
% major magical unlock
%
%
%
% Trap types:
%
%  * Purge - remove buffs of thief
%  * Fate - randomize hp / mana
%  * Petrifying - turn to stone
%  * Life Drain - lose a max HP
%  * Enfeeble - enfeeble
%  * Disease - dement
%  * Fright - aoe weaken minion loyalty
%  * Siren - all monsters in room aggro on thief
%  * Explosion - aoe fire damage + brief firewalls
%  * Discharge - high shock damage to one
%  * Poison Gas - poison gas
%  * Cold Blast - apply large amounts of chilled
%  * Teleporter - Send player to a random room in the same region
%  * Shattering Blast - destroy a random item on thief
%  * Guardian - summon a stronger monster
%  * Hex - random Raumlar hex

constants:

   LOOT_BOX_ITEMS_MAX = 150
   
   TRAP_NONE = 0
   TRAP_FATE = 1
   TRAP_PURGE = 2
   TRAP_LIFE_DRAIN = 3
   TRAP_PETRIFY = 4
   TRAP_DISEASE = 5
   TRAP_ENFEEBLE = 6
   TRAP_FRIGHT = 7
   TRAP_SIREN = 8
   TRAP_EXPLOSION = 9
   TRAP_DISCHARGE = 10
   TRAP_POISON_GAS = 11
   TRAP_COLD_BLAST = 12
   TRAP_TELEPORTER = 13
   TRAP_SHATTERING_BLAST = 14
   TRAP_GUARDIAN = 15
   TRAP_HEX = 16
   
   TRAP_MAX = 16

   include blakston.khd

resources:

   loot_box_name_rsc = "treasure chest"
   loot_box_icon_small_rsc = lootbox3.bgf
   loot_box_icon_medium_rsc = lootbox2.bgf
   loot_box_icon_large_rsc = lootbox1.bgf
   loot_box_icon_chest_small = lootbox6.bgf
   loot_box_icon_chest_medium = lootbox5.bgf
   loot_box_icon_chest_large = lootbox4.bgf

   loot_box_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster.\n\n%r"
   loot_box_open_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster."
   
   loot_box_not_trapped_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster.\n\n"
      "This chest does not appear trapped."
   loot_box_magically_locked_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster.\n\n"
      "This chest appears to be magically locked."
   loot_box_trap_string_rsc = \
      "This chest appears to be protected by a %s trap of difficulty %i.\n\n"
      "You estimate you have a %i%% chance to safely disarm it."

   loot_box_fate_trap_desc_rsc = \
      "Fate"
   loot_box_purge_trap_desc_rsc = \
      "Purge"
   loot_box_life_drain_trap_desc_rsc = \
      "Life Drain"
   loot_box_petrify_trap_desc_rsc = \
      "Petrification"
   loot_box_enfeeble_trap_desc_rsc = \
      "Enfeeble"
   loot_box_disease_trap_desc_rsc = \
      "Disease"
   loot_box_fright_trap_desc_rsc = \
      "Fright"
   loot_box_siren_trap_desc_rsc = \
      "Siren"
   loot_box_explosion_trap_desc_rsc = \
      "Explosion"
   loot_box_discharge_trap_desc_rsc = \
      "Discharge"
   loot_box_poison_gas_trap_desc_rsc = \
      "Poison Gas"
   loot_box_cold_blast_trap_desc_rsc = \
      "Cold Blast"
   loot_box_teleport_trap_desc_rsc = \
      "Teleporter"
   loot_box_shattering_blast_trap_desc_rsc = \
      "Shattering Blast"
   loot_box_guardian_trap_desc_rsc = \
      "Guardian"
   loot_box_hex_trap_desc_rsc = \
      "Hex"

   shattering_blast_trap_msg_rsc = \
      "A blast of rupturing energy shatters your %s!"
   siren_trap_msg_rsc = \
      "An unheard note of alarm pierces the air. You cannot hear it, but the monsters in the area certainly do!"
   fright_trap_msg_rsc = \
      "A blast of illusory magic frightens your minions, weakening their loyalty!"
   fate_trap_msg_rsc = \
      "The gods are fickle indeed..."
   purge_trap_msg_rsc = \
      "A wave of purging magic erupts!"
   petrifying_trap_msg_rsc = \
      "You gasp as your flesh turns rapidly into stone, locking your "
      "face in an aspect of horror for all time!"
   life_drain_trap_msg_rsc = \
      "Your nerves burn with draining enervation!"
   teleport_trap_msg_rsc = \
      "A wave of verdant energy carries you to a distant location!"
   guardian_trap_msg_rsc = \
      "An enraged guardian appears to protect the treasure!"

   trap_roar_sound = 195568jacobalcookcreatureroar1.wav
   trap_drain_sound = qvtouch.wav
   trap_explosion_sound = fflame.wav
   trap_fate_sound = slitherboltwand.wav
   trap_discharge_sound = fbolt.wav
   trap_poison_gas_sound = poisoned.wav
   trap_teleporter_sound = riluswnd.wav

classvars:

   vrName = loot_box_name_rsc
   vrDesc = loot_box_desc_rsc

   viBulk_hold_max = $
   viWeight_hold_max = $
   
   viMagicallyLockedLightColor = LIGHT_BBLUE

properties:

   vrIcon = loot_box_icon_small_rsc
   
   % What level was the monster? Some monsters have special values for this
   piBoxPower = 20
   
   piTrapNum = TRAP_NONE
   
   pbLocked = FALSE
   pbMagicallyLocked = FALSE
   
   poKiller = $
   
   piExpireChecks = 12
   ptExpireTimer = $
   
   piLadderID = 0

messages:

   Constructor(iLootSize=0,iBoxPower=20,killer=$)
   {
      local lPossibleTraps;

      poKiller = killer;
      piLadderID = Send(killer,@GetLadderID);
      piBoxPower = Bound((iBoxPower * Random(80,150))/100,20,$);
      
      if Random(1,1000) <= piBoxPower
      {
         pbMagicallyLocked = TRUE;
      }

      if iLootSize = 0
      {
         iLootSize = Random(1,6);
      }
      switch(iLootSize)
      {
         case 1:
            vrIcon = loot_box_icon_small_rsc;
            break;
         case 2:
            vrIcon = loot_box_icon_medium_rsc;
            break;
         case 3:
            vrIcon = loot_box_icon_large_rsc;
            break;
         case 4:
            vrIcon = loot_box_icon_chest_small;
            break;
         case 5:
            vrIcon = loot_box_icon_chest_medium;
            break;
         case 6:
            vrIcon = loot_box_icon_chest_large;
            break;
      }
      
      piExpireChecks = piExpireChecks + iLootSize*6;
      
      % Always a chance of no trap.
      lPossibleTraps = [TRAP_NONE];

      lPossibleTraps = Cons(TRAP_FATE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_DISEASE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_ENFEEBLE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_GUARDIAN,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_FRIGHT,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_SIREN,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_TELEPORTER,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_SHATTERING_BLAST,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_EXPLOSION,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_DISCHARGE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_POISON_GAS,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_COLD_BLAST,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_PURGE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_HEX,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_LIFE_DRAIN,lPossibleTraps);

      % Petrify trap is too brutal to subject newbies to it
      if piBoxPower >= 200
      {
         lPossibleTraps = Cons(TRAP_PETRIFY,lPossibleTraps);
      }

      if Random(1,100) <= piBoxPower/3
      {
         piTrapNum = Nth(lPossibleTraps,Random(1,Length(lPossibleTraps)));
      }
      else
      {
         piTrapNum = [TRAP_NONE];
      }
      
      Post(self,@LockChest,#bLocked=TRUE);
      
      ptExpireTimer = CreateTimer(self,@CheckExpire,10000);

      propagate;
   }
   
   CheckExpire(timer=$)
   {
      ptExpireTimer = $;
      
      piExpireChecks--;
      
      if piExpireChecks <= 0
         OR (plActive = $ and plPassive = $)
      {
         Send(self,@Delete);
      }
      else
      {
         ptExpireTimer = CreateTimer(self,@CheckExpire,10000);
      }
      
      return;
   }

   ReqNewHold(what = $, who = $)
   {
      return FALSE;
   }

   TryActivate(who=$)
   {
      Post(self,@SpringTrap,#who=who);
      Post(self,@LockChest,#bLocked=FALSE);
      return TRUE;
   }

   ShowDesc(who=$)
   {
      local rTrapDesc;
      
      if NOT pbLocked
      {
         AddPacket(4,loot_box_open_desc_rsc);
         return;
      }

      rTrapDesc = loot_box_not_trapped_desc_rsc;
      
      if pbMagicallyLocked
      {
         AddPacket(4,loot_box_magically_locked_desc_rsc);
         return;
      }
      
      switch(piTrapNum)
      {
         case TRAP_NONE:
            AddPacket(4,loot_box_not_trapped_desc_rsc);
            return;
         case TRAP_FATE:
            rTrapDesc = loot_box_fate_trap_desc_rsc;
            break;
         case TRAP_PURGE:
            rTrapDesc = loot_box_purge_trap_desc_rsc;
            break;
         case TRAP_LIFE_DRAIN:
            rTrapDesc = loot_box_life_drain_trap_desc_rsc;
            break;
         case TRAP_PETRIFY:
            rTrapDesc = loot_box_petrify_trap_desc_rsc;
            break;
         case TRAP_DISEASE:
            rTrapDesc = loot_box_disease_trap_desc_rsc;
            break;
         case TRAP_ENFEEBLE:
            rTrapDesc = loot_box_enfeeble_trap_desc_rsc;
            break;
         case TRAP_FRIGHT:
            rTrapDesc = loot_box_fright_trap_desc_rsc;
            break;
         case TRAP_SIREN:
            rTrapDesc = loot_box_siren_trap_desc_rsc;
            break;
         case TRAP_EXPLOSION:
            rTrapDesc = loot_box_explosion_trap_desc_rsc;
            break;
         case TRAP_DISCHARGE:
            rTrapDesc = loot_box_discharge_trap_desc_rsc;
            break;
         case TRAP_POISON_GAS:
            rTrapDesc = loot_box_poison_gas_trap_desc_rsc;
            break;
         case TRAP_COLD_BLAST:
            rTrapDesc = loot_box_cold_blast_trap_desc_rsc;
            break;
         case TRAP_TELEPORTER:
            rTrapDesc = loot_box_teleport_trap_desc_rsc;
            break;
         case TRAP_SHATTERING_BLAST:
            rTrapDesc = loot_box_shattering_blast_trap_desc_rsc;
            break;
         case TRAP_GUARDIAN:
            rTrapDesc = loot_box_guardian_trap_desc_rsc;
            break;
         case TRAP_HEX:
            rTrapDesc = loot_box_hex_trap_desc_rsc;
            break;
      }
      
      AddPacket(4,vrDesc, 4,loot_box_trap_string_rsc, 4,rTrapDesc, 4,piBoxPower, 4,Send(self,@GetDisarmEstimate,#who=who));

      return;
   }
   
   GetDisarmEstimate(who=$)
   {
      local iDisarmChance, iStatScore;

      iDisarmChance = ((Send(who,@GetAgility) + Send(who,@GetAim)) * 50) / Bound(piBoxPower,20,$);
      
      return iDisarmChance;
   }
   
   SpringTrap(who=$)
   {
      switch(piTrapNum)
      {
         case TRAP_FATE:
            Send(self,@DoFateTrap,#who=who);
            break;
         case TRAP_PURGE:
            Send(self,@DoPurgeTrap,#who=who);
            break;
         case TRAP_LIFE_DRAIN:
            Send(self,@DoLifeDrainTrap,#who=who);
            break;
         case TRAP_PETRIFY:
            Send(self,@DoPetrifyingTrap,#who=who);
            break;
         case TRAP_ENFEEBLE:
            Send(self,@DoEnfeebleTrap,#who=who);
            break;
         case TRAP_DISEASE:
            Send(self,@DoDiseaseTrap,#who=who);
            break;
         case TRAP_FRIGHT:
            Send(self,@DoFrightTrap,#who=who);
            break;
         case TRAP_SIREN:
            Send(self,@DoSirenTrap,#who=who);
            break;
         case TRAP_EXPLOSION:
            Send(self,@DoExplosionTrap,#who=who);
            break;
         case TRAP_DISCHARGE:
            Send(self,@DoDischargeTrap,#who=who);
            break;
         case TRAP_POISON_GAS:
            Send(self,@DoPoisonGasTrap,#who=who);
            break;
         case TRAP_COLD_BLAST:
            Send(self,@DoColdBlastTrap,#who=who);
            break;
         case TRAP_TELEPORTER:
            Send(self,@DoTeleporterTrap,#who=who);
            break;
         case TRAP_SHATTERING_BLAST:
            Send(self,@DoShatteringBlastTrap,#who=who);
            break;
         case TRAP_GUARDIAN:
            Send(self,@DoGuardianTrap,#who=who);
            break;
         case TRAP_HEX:
            Send(self,@DoHexTrap,#who=who);
            break;
      }
      return;
   }

   DoGuardianTrap(who=$)
   {
      local cMonster, oMonster;
      if poOwner <> $
      {
         if piBoxPower < 60
         {
            cMonster = &TuskedSkeleton;
         }
         else if piBoxPower < 100
         {
            cMonster = &DaemonSkeleton;
         }
         else if piBoxPower < 130
         {
            cMonster = &Thrasher;
         }
         else if piBoxPower < 180
         {
            cMonster = &Shadowbeast;
         }
         else if piBoxPower < 240
         {
            cMonster = &Ghost;
         }
         else
         {
            cMonster = &DarkAngel;
         }
         oMonster = Create(cMonster);
         Send(poOwner,@NewHold,#what=oMonster,#new_row=Send(self,@GetRow),#new_col=Send(self,@GetCol),#fine_row=Send(self,@GetFineRow),#fine_col=Send(self,@GetFineCol));
         Send(who,@MsgSendUser,#message_rsc=guardian_trap_msg_rsc);
         Post(oMonster,@TargetSwitch,#what=who,#iHatred=100);
         Post(oMonster,@EnterStateChase,#target=who,#actnow=TRUE);
      }
      return;
   }

   DoHexTrap(who=$)
   {
      switch(Random(1,3))
      {
         case 1:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
         case 2:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
         case 3:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
      }
      return;
   }
   
   GetHexIncEffect()
   {
      return piBoxPower;
   }

   DoShatteringBlastTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=shattering_blast_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_SHATTER),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   DoTeleporterTrap(who=$)
   {
      local i, n, lRooms, iRID;
      
      if poOwner <> $
      {
         lRooms = $;
         
         foreach i in Send(poOwner,@GetYellZone)
         {
            foreach n in Send(Send(SYS,@FindRoomByNum,#num=i),@GetYellZone)
            {
               if n <> Send(poOwner,@GetRoomNum)
               {
                  if lRooms = $
                     OR FindListElem(lRooms,n) = 0
                  {
                     lRooms = Cons(n,lRooms);
                  }
               }
            }
         }

         if lRooms = $
            OR Length(lRooms) <= 1
         {
            iRID = Send(who,@GetHomeRoom);
         }
         else
         {
            iRID = Nth(lRooms,Random(1,Length(lRooms)));
            Send(Send(SYS,@FindRoomByNum,#num=iRID),@Teleport,#what=who);
            Send(who,@MsgSendUser,#message_rsc=teleport_trap_msg_rsc);
            Post(Send(SYS,@FindRoomByNum,#num=iRID),@SomethingWaveRoom,#what=who,#wave_rsc=trap_teleporter_sound);
         }
         
      }
      return;
   }

   DoColdBlastTrap(who=$)
   {
      local drow, dcol, iAngle;

      % build face towards (in fine-units)
      drow = (Send(who,@GetRow) * FINENESS) + Send(who,@GetFineRow);
      dcol = (Send(who,@GetCol) * FINENESS) + Send(who,@GetFineCol);
      drow = drow - ((Send(self,@GetRow) * FINENESS) + Send(self,@GetFineRow));
      dcol = dcol - ((Send(self,@GetCol) * FINENESS) + Send(self,@GetFineCol));

      if poOwner <> $
      {
         iAngle = Send(SYS,@UtilGetAngleTowards,#row=drow,#col=dcol);
         Send(poOwner,@SomethingTurned,#what=self,#new_angle=iAngle);
      }
      Send(Send(SYS,@FindSpellByNum,#num=SID_FROST_BREATH),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   DoPoisonGasTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oGasElement, iGasElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random poison gas.
      
      iGasElements = Random(3,6);
      
      while iGasElements > 0
      {
         oGasElement = Create(&OrangeFogCloud,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE,#Odds=100);
         Send(oOwner,@NewHold,#what=oGasElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iGasElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_POISON),@MakePoisoned,#who=who,#lossrate=piBoxPower*100,#duration=piBoxPower*100);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_ACID,
                                   #what=oCreator);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_poison_gas_sound);
      return;
   }
   
   DoDischargeTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oFireElement, iFireElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random fire.
      
      iFireElements = Random(3,6);
      
      while iFireElements > 0
      {
         oFireElement = Create(&WallofLightning,#MaxDamage=piBoxPower/6,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE);
         Send(oOwner,@NewHold,#what=oFireElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iFireElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_SHOCKING_FURY),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_SHOCK,
                                   #what=oCreator);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_discharge_sound);
      return;
   }
   
   DoExplosionTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oFireElement, iFireElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random fire.
      
      iFireElements = Random(3,6);
      
      while iFireElements > 0
      {
         oFireElement = Create(&WallOfFire,#MaxDamage=piBoxPower/6,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE);
         Send(oOwner,@NewHold,#what=oFireElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iFireElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_BLAST_OF_FIRE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_FIRE,
                                   #what=oCreator);
            Send(i,@AddHurtMeRecently,#who=oCreator,#amount=iBurningDealt);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_explosion_sound);
      return;
   }

   DoSirenTrap(who=$)
   {
      local i, each_obj;
      Send(who,@MsgSendUser,#message_rsc=siren_trap_msg_rsc);
      
      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&Monster)
            {
               Send(each_obj,@TargetSwitch,#what=who,#iHatred=100);
               Send(each_obj,@EnterStateChase,#target=who,#actnow=TRUE);
            }
         }
      }
      
      return;
   }

   DoFrightTrap(who=$)
   {
      local oMinion;
      Send(who,@MsgSendUser,#message_rsc=fright_trap_msg_rsc);
      
      foreach oMinion in Send(who,@GetControlledMinions)
      {
         Send(oMinion,@AddLoyalty,#amount=-piBoxPower);
      }
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_roar_sound);
      }
      
      return;
   }

   DoEnfeebleTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoDiseaseTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_DEMENT))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_DEMENT),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoLifeDrainTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=life_drain_trap_msg_rsc);
      Send(who,@GainBaseMaxHealth,#amount=-1);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_drain_sound);
      }

      return;
   }

   DoFateTrap(who=$)
   {
      local iHealthLoss, iManaLoss;
      
      iHealthLoss = Random(0,Bound(Send(who,@GetExactHealth)-100,0,$));
      iHealthLoss = Bound(Random(iHealthLoss,iHealthLoss + piBoxPower),0,Bound(Send(who,@GetExactHealth)-100,0,$));
      
      iManaLoss = Random(0,Send(who,@GetMaxMana));
      iManaLoss = Bound(Random(iManaLoss,iManaLoss + piBoxPower),0,Send(who,@GetMaxMana));
   
      Send(who,@LoseHealth,#amount=iHealthLoss,#precision=TRUE);
      Send(who,@LoseMana,#amount=iManaLoss);
      
      Send(who,@MsgSendUser,#message_rsc=fate_trap_msg_rsc);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_fate_sound);
      }

      return;
   }

   DoPurgeTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=purge_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PURGE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      return;
   }
   
   DoPetrifyingTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=petrifying_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PETRIFIED),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   ReqTaker(what=$,taker=$)
   {
      local oTakerOwner;

      oTakerOwner = Send(taker,@GetOwner);

      if (NOT Send(oTakerOwner,@LineOfSight,#obj1=taker,#obj2=self))
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from a chest they cannot see! ");

         return FALSE;
      }

      if IsClass(taker,&User)
         AND NOT IsClass(taker,&Admin)
         AND IsClass(oTakerOwner,&Room) AND IsClass(poOwner,&Room)
         AND oTakerOwner <> poOwner
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from distant chest in RID ",
               Send(poOwner,@GetRoomNum));

         return FALSE;
      }

      if IsClass(oTakerOwner,&GuildHall)
      {
         return Send(oTakerOwner,@ReqUseGuildChest,#who=taker,#oBox=self);
      }

      propagate;
   }
   
   Delete()
   {
      if ptExpireTimer <> $
      {
         DeleteTimer(ptExpireTimer);
         ptExpireTimer = $;
      }
      propagate;
   }

   SendLightingInformation()
   {
      local iLightColor;

      if pbMagicallyLocked
      {
         iLightColor = viMagicallyLockedLightColor;
         if poOwner <> $
         {
            if Send(poOwner,@LightingColorOverride)
            {
               iLightColor = Send(poOwner,@GetLightingColorOverride);
            }
         }
         AddPacket(2,LIGHT_FLAG_ON);
         AddPacket(1,100);
         AddPacket(2,iLightColor);
      }
      else
      {
         % Default: No lighting
         AddPacket(2,0);
      }

      return;
   }
   
   GetLadderID()
   {
      return piLadderID;
   }
   
   GetCasterMaxHexes()
   {
      return 10;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
