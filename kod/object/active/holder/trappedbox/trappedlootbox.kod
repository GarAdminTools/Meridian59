% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TrappedLootBox is TrappedBox

%
% ID trap spell
% minor magical unlock
% major magical unlock
%
%
%
% Trap types:
%  * Explosion - aoe fire damage + brief firewalls
%  * Discharge - high shock damage to one
%  * Blast of Frost - apply large amounts of chilled
%  * Teleporter - Send player to a random room in the same region
%  * Poison Gas - poison gas
%  * Guardian - summon a stronger monster
%  * Shattering Blast - destroy a random item on thief
%  * Curse - random Raumlar hex
%
%  * Purge - remove buffs of thief
%  * Fate - randomize hp / mana
%  * Petrifying - turn to stone
%  * Life Drain - lose a max HP
%  * Enfeeble - enfeeble
%  * Disease - dement
%  * Fright - aoe weaken minion loyalty
%  * Siren - all monsters in room aggro on thief

constants:

   LOOT_BOX_ITEMS_MAX = 150
   
   TRAP_NONE = 0
   TRAP_FATE = 1
   TRAP_PURGE = 2
   TRAP_LIFE_DRAIN = 3
   TRAP_PETRIFY = 4
   TRAP_DISEASE = 5
   TRAP_ENFEEBLE = 6
   TRAP_FRIGHT = 7
   TRAP_SIREN = 8
   
   TRAP_MAX = 8

   include blakston.khd

resources:

   loot_box_name_rsc = "treasure chest"
   loot_box_icon_small_rsc = lootbox3.bgf
   loot_box_icon_medium_rsc = lootbox2.bgf
   loot_box_icon_large_rsc = lootbox1.bgf
   loot_box_icon_chest_small = lootbox6.bgf
   loot_box_icon_chest_medium = lootbox5.bgf
   loot_box_icon_chest_large = lootbox4.bgf

   loot_box_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster.\n\n%r"
   loot_box_open_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster."
   
   loot_box_not_trapped_desc_rsc = \
      "This treasure chest was used to store the valuables of a fallen monster.\n\n"
      "This chest does not appear trapped."
   loot_box_trap_string_rsc = \
      "This chest appears to be protected by a %s trap of difficulty %i.\n\n"
      "You estimate you have a %i%% chance to safely disarm it."

   loot_box_fate_trap_desc_rsc = \
      "Fate"
   loot_box_purge_trap_desc_rsc = \
      "Purge"
   loot_box_life_drain_trap_desc_rsc = \
      "Life Drain"
   loot_box_petrify_trap_desc_rsc = \
      "Petrification"
   loot_box_enfeeble_trap_desc_rsc = \
      "Enfeeble"
   loot_box_disease_trap_desc_rsc = \
      "Disease"
   loot_box_fright_trap_desc_rsc = \
      "Fright"
   loot_box_siren_trap_desc_rsc = \
      "Siren"

   siren_trap_msg_rsc = \
      "An unheard note of alarm pierces the air. You cannot hear it, but the monsters in the area certainly do!"
   fright_trap_msg_rsc = \
      "A blast of illusory magic frightens your minions, weakening their loyalty!"
   fate_trap_msg_rsc = \
      "The gods are fickle indeed..."
   purge_trap_msg_rsc = \
      "A wave of purging magic erupts!"
   petrifying_trap_msg_rsc = \
      "You gasp as your flesh turns rapidly into stone, locking your "
      "face in an aspect of horror for all time!"
   life_drain_trap_msg_rsc = \
      "Your nerves burn with draining enervation!"

   trap_roar_sound = 195568jacobalcookcreatureroar1.wav
   trap_drain_sound = qvtouch.wav
   trap_fate_sound = slitherboltwand.wav

classvars:

   vrName = loot_box_name_rsc
   vrDesc = loot_box_desc_rsc

   viBulk_hold_max = $
   viWeight_hold_max = $

properties:

   vrIcon = loot_box_icon_small_rsc
   
   % What level was the monster? Some monsters have special values for this
   piBoxPower = 20
   
   piTrapNum = TRAP_NONE
   
   pbLocked = FALSE
   
   poKiller = $
   
   piExpireChecks = 12
   ptExpireTimer = $

messages:

   Constructor(iLootSize=0,iBoxPower=20,killer=$)
   {
      poKiller = killer;
      piBoxPower = Bound((iBoxPower * Random(80,150))/100,20,$);

      if iLootSize = 0
      {
         iLootSize = Random(1,6);
      }
      switch(iLootSize)
      {
         case 1:
            vrIcon = loot_box_icon_small_rsc;
            break;
         case 2:
            vrIcon = loot_box_icon_medium_rsc;
            break;
         case 3:
            vrIcon = loot_box_icon_large_rsc;
            break;
         case 4:
            vrIcon = loot_box_icon_chest_small;
            break;
         case 5:
            vrIcon = loot_box_icon_chest_medium;
            break;
         case 6:
            vrIcon = loot_box_icon_chest_large;
            break;
      }
      
      piExpireChecks = piExpireChecks + iLootSize*6;
      
      piTrapNum = Random(TRAP_NONE,TRAP_MAX);
      
      Post(self,@LockChest,#bLocked=TRUE);
      
      ptExpireTimer = CreateTimer(self,@CheckExpire,10000);

      propagate;
   }
   
   CheckExpire(timer=$)
   {
      ptExpireTimer = $;
      
      piExpireChecks--;
      
      if piExpireChecks <= 0
         OR (plActive = $ and plPassive = $)
      {
         Send(self,@Delete);
      }
      else
      {
         ptExpireTimer = CreateTimer(self,@CheckExpire,10000);
      }
      
      return;
   }

   ReqNewHold(what = $, who = $)
   {
      return FALSE;
   }

   TryActivate(who=$)
   {
      Post(self,@SpringTrap,#who=who);
      Post(self,@LockChest,#bLocked=FALSE);
      return TRUE;
   }

   ShowDesc(who=$)
   {
      local rTrapDesc;
      
      if NOT pbLocked
      {
         AddPacket(4,loot_box_open_desc_rsc);
         return;
      }

      rTrapDesc = loot_box_not_trapped_desc_rsc;
      switch(piTrapNum)
      {
         case TRAP_NONE:
            AddPacket(4,loot_box_not_trapped_desc_rsc);
            return;
         case TRAP_FATE:
            rTrapDesc = loot_box_fate_trap_desc_rsc;
            break;
         case TRAP_PURGE:
            rTrapDesc = loot_box_purge_trap_desc_rsc;
            break;
         case TRAP_LIFE_DRAIN:
            rTrapDesc = loot_box_life_drain_trap_desc_rsc;
            break;
         case TRAP_PETRIFY:
            rTrapDesc = loot_box_petrify_trap_desc_rsc;
            break;
         case TRAP_DISEASE:
            rTrapDesc = loot_box_disease_trap_desc_rsc;
            break;
         case TRAP_ENFEEBLE:
            rTrapDesc = loot_box_enfeeble_trap_desc_rsc;
            break;
         case TRAP_FRIGHT:
            rTrapDesc = loot_box_fright_trap_desc_rsc;
            break;
         case TRAP_SIREN:
            rTrapDesc = loot_box_siren_trap_desc_rsc;
            break;
      }
      
      AddPacket(4,vrDesc, 4,loot_box_trap_string_rsc, 4,rTrapDesc, 4,piBoxPower, 4,Send(self,@GetDisarmEstimate,#who=who));

      return;
   }
   
   GetDisarmEstimate(who=$)
   {
      local iDisarmChance, iStatScore;

      iDisarmChance = ((Send(who,@GetAgility) + Send(who,@GetAim)) * 50) / Bound(piBoxPower,20,$);
      
      return iDisarmChance;
   }
   
   SpringTrap(who=$)
   {
      switch(piTrapNum)
      {
         case TRAP_FATE:
            Send(self,@DoFateTrap,#who=who);
            break;
         case TRAP_PURGE:
            Send(self,@DoPurgeTrap,#who=who);
            break;
         case TRAP_LIFE_DRAIN:
            Send(self,@DoLifeDrainTrap,#who=who);
            break;
         case TRAP_PETRIFY:
            Send(self,@DoPetrifyingTrap,#who=who);
            break;
         case TRAP_ENFEEBLE:
            Send(self,@DoEnfeebleTrap,#who=who);
            break;
         case TRAP_DISEASE:
            Send(self,@DoDiseaseTrap,#who=who);
            break;
         case TRAP_FRIGHT:
            Send(self,@DoFrightTrap,#who=who);
            break;
         case TRAP_SIREN:
            Send(self,@DoSirenTrap,#who=who);
            break;
      }
      return;
   }

   DoSirenTrap(who=$)
   {
      local i, each_obj;
      Send(who,@MsgSendUser,#message_rsc=siren_trap_msg_rsc);
      
      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&Monster)
            {
               Send(each_obj,@TargetSwitch,#what=who,#iHatred=100);
               Send(each_obj,@EnterStateChase,#target=who,#actnow=TRUE);
            }
         }
      }
      
      return;
   }

   DoFrightTrap(who=$)
   {
      local oMinion;
      Send(who,@MsgSendUser,#message_rsc=fright_trap_msg_rsc);
      
      foreach oMinion in Send(who,@GetControlledMinions)
      {
         Send(oMinion,@AddLoyalty,#amount=-piBoxPower);
      }
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_roar_sound);
      }
      
      return;
   }

   DoEnfeebleTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoDiseaseTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_DEMENT))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_DEMENT),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoLifeDrainTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=life_drain_trap_msg_rsc);
      Send(who,@GainBaseMaxHealth,#amount=-1);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_drain_sound);
      }

      return;
   }

   DoFateTrap(who=$)
   {
      local iHealthLoss, iManaLoss;
      
      iHealthLoss = Random(0,Bound(Send(who,@GetExactHealth)-100,0,$));
      iHealthLoss = Bound(Random(iHealthLoss,iHealthLoss + piBoxPower),0,Bound(Send(who,@GetExactHealth)-100,0,$));
      
      iManaLoss = Random(0,Send(who,@GetMaxMana));
      iManaLoss = Bound(Random(iManaLoss,iManaLoss + piBoxPower),0,Send(who,@GetMaxMana));
   
      Send(who,@LoseHealth,#amount=iHealthLoss,#precision=TRUE);
      Send(who,@LoseMana,#amount=iManaLoss);
      
      Send(who,@MsgSendUser,#message_rsc=fate_trap_msg_rsc);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_fate_sound);
      }

      return;
   }

   DoPurgeTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=purge_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PURGE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      return;
   }
   
   DoPetrifyingTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=petrifying_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PETRIFIED),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   ReqTaker(what=$,taker=$)
   {
      local oTakerOwner;

      oTakerOwner = Send(taker,@GetOwner);

      if (NOT Send(oTakerOwner,@LineOfSight,#obj1=taker,#obj2=self))
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from a chest they cannot see! ");

         return FALSE;
      }

      if IsClass(taker,&User)
         AND NOT IsClass(taker,&Admin)
         AND IsClass(oTakerOwner,&Room) AND IsClass(poOwner,&Room)
         AND oTakerOwner <> poOwner
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from distant chest in RID ",
               Send(poOwner,@GetRoomNum));

         return FALSE;
      }

      if IsClass(oTakerOwner,&GuildHall)
      {
         return Send(oTakerOwner,@ReqUseGuildChest,#who=taker,#oBox=self);
      }

      propagate;
   }
   
   Delete()
   {
      if ptExpireTimer <> $
      {
         DeleteTimer(ptExpireTimer);
         ptExpireTimer = $;
      }
      propagate;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
