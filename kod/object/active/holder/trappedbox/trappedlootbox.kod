% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TrappedLootBox is TrappedBox

%
% ID trap spell
% minor magical unlock
% major magical unlock
%
%
%
% Trap types:
%
%  * Purge - remove buffs of thief
%  * Fate - randomize hp / mana
%  * Petrifying - turn to stone
%  * Life Drain - lose a max HP
%  * Enfeeble - enfeeble
%  * Disease - dement
%  * Fright - aoe weaken minion loyalty
%  * Siren - all monsters in room aggro on thief
%  * Explosion - aoe fire damage + brief firewalls
%  * Discharge - high shock damage to one
%  * Poison Gas - poison gas
%  * Cold Blast - apply large amounts of chilled
%  * Teleporter - Send player to a random room in the same region
%  * Shattering Blast - destroy a random item on thief
%  * Guardian - summon a stronger monster
%  * Hex - random Raumlar hex

constants:

   LOOT_BOX_ITEMS_MAX = 150
   
   TRAP_NONE = 0
   TRAP_FATE = 1
   TRAP_PURGE = 2
   TRAP_LIFE_DRAIN = 3
   TRAP_PETRIFY = 4
   TRAP_DISEASE = 5
   TRAP_ENFEEBLE = 6
   TRAP_FRIGHT = 7
   TRAP_SIREN = 8
   TRAP_EXPLOSION = 9
   TRAP_DISCHARGE = 10
   TRAP_POISON_GAS = 11
   TRAP_COLD_BLAST = 12
   TRAP_TELEPORTER = 13
   TRAP_SHATTERING_BLAST = 14
   TRAP_GUARDIAN = 15
   TRAP_HEX = 16
   
   TRAP_MAX = 16

   include blakston.khd

resources:

   loot_box_name_rsc = "small treasure box"
   loot_box_name2_rsc = "treasure box"
   loot_box_name3_rsc = "large treasure box"
   loot_chest_name1_rsc = "small treasure chest"
   loot_chest_name2_rsc = "treasure chest"
   loot_chest_name3_rsc = "large treasure chest"
   loot_chest_name_super_rsc = "ancient treasure chest"
   loot_box_icon_small_rsc = lootbox3.bgf
   loot_box_icon_medium_rsc = lootbox2.bgf
   loot_box_icon_large_rsc = lootbox1.bgf
   loot_box_icon_chest_small = lootbox6.bgf
   loot_box_icon_chest_medium = lootbox5.bgf
   loot_box_icon_chest_large = lootbox4.bgf

   loot_box_desc_rsc = \
      "This %s was used to store the valuables of a now %s.\n\n%r"
   loot_box_open_desc_rsc = \
      "This %s was used to store the valuables of a now %s."
      
   
   loot_box_not_trapped_desc_rsc = \
      "This %s was used to store the valuables of a now %s.\n\n"
      "You %s this chest does not contain a trap."
   loot_box_magically_locked_desc_rsc = \
      "This %s was used to store the valuables of a now %s.\n\n"
      "This chest is magically locked."
   loot_box_trap_string_rsc = \
      "You %s this chest is protected by a %s trap.\n\n"
      "You estimate your chance to safely disarm it is %i%%."

   loot_box_cloaked_desc_rsc = \
      "This chest has been Cloaked by foul magics, making assessment of its trap impossible."

   loot_box_shrouded_resists_rsc = \
      "This chest has been Shrouded by protective magic, making casting directly upon it impossible!"

   disarm_trapped_loot_box_success_msg = \
      "You successfully disarm the %s trap and open the chest."
   open_non_trapped_loot_box_msg = \
      "You open the chest without incident."

   loot_box_fate_trap_desc_rsc = \
      "Fate"
   loot_box_purge_trap_desc_rsc = \
      "Purge"
   loot_box_life_drain_trap_desc_rsc = \
      "Life Drain"
   loot_box_petrify_trap_desc_rsc = \
      "Petrification"
   loot_box_enfeeble_trap_desc_rsc = \
      "Enfeeble"
   loot_box_disease_trap_desc_rsc = \
      "Disease"
   loot_box_fright_trap_desc_rsc = \
      "Fright"
   loot_box_siren_trap_desc_rsc = \
      "Siren"
   loot_box_explosion_trap_desc_rsc = \
      "Explosion"
   loot_box_discharge_trap_desc_rsc = \
      "Discharge"
   loot_box_poison_gas_trap_desc_rsc = \
      "Poison Gas"
   loot_box_cold_blast_trap_desc_rsc = \
      "Cold Blast"
   loot_box_teleport_trap_desc_rsc = \
      "Teleporter"
   loot_box_shattering_blast_trap_desc_rsc = \
      "Shattering Blast"
   loot_box_guardian_trap_desc_rsc = \
      "Guardian"
   loot_box_hex_trap_desc_rsc = \
      "Hex"
   loot_box_unknown_trap_desc_rsc = \
      "Unknown"

   shattering_blast_trap_msg_rsc = \
      "A blast of rupturing energy shatters your %s!"
   siren_trap_msg_rsc = \
      "An unheard note of alarm pierces the air. You cannot hear it, but the monsters in the area certainly do!"
   fright_trap_msg_rsc = \
      "A blast of illusory magic frightens your minions, weakening their loyalty!"
   fate_trap_msg_rsc = \
      "The gods are fickle indeed..."
   purge_trap_msg_rsc = \
      "A wave of purging magic erupts!"
   petrifying_trap_msg_rsc = \
      "You gasp as your flesh turns rapidly into stone, locking your "
      "face in an aspect of horror for all time!"
   life_drain_trap_msg_rsc = \
      "Your nerves burn with draining enervation!"
   teleport_trap_msg_rsc = \
      "A wave of verdant energy carries you to a distant location!"
   guardian_trap_msg_rsc = \
      "An enraged guardian appears to protect the treasure!"

   trap_assessment_level_none = \
      "have no idea, but your wild guess is that"
   trap_assessment_level_1 = \
      "have only the barest idea, but you guess that"
   trap_assessment_level_2 = \
      "are largely uncertain, but you suppose"
   trap_assessment_level_3 = \
      "are somewhat uncertain, but you suppose"
   trap_assessment_level_4 = \
      "are vaguely certain"
   trap_assessment_level_5 = \
      "are somewhat certain"
   trap_assessment_level_all = \
      "are absolutely certain"

   trap_roar_sound = 195568jacobalcookcreatureroar1.wav
   trap_drain_sound = qvtouch.wav
   trap_explosion_sound = fflame.wav
   trap_fate_sound = slitherboltwand.wav
   trap_discharge_sound = fbolt.wav
   trap_poison_gas_sound = poisoned.wav
   trap_teleporter_sound = riluswnd.wav
   
   purged_magical_lock_completely = \
      "You completely purge the magical lock!"
   purged_magical_lock = \
      "You purge %i points of mana from the magical lock."
   
   artificing_enchantment_fades_rsc = \
      "The artificing enchantment is stripped away!"

classvars:

   viBulk_hold_max = $
   viWeight_hold_max = $
   
   viMagicallyLockedLightColor = LIGHT_BBLUE

properties:

   vrName = loot_box_name_rsc
   vrDesc = loot_box_desc_rsc
   vrIcon = loot_box_icon_small_rsc
   
   % What level was the monster? Some monsters have special values for this
   piBoxPower = 20
   
   piTrapNum = TRAP_NONE
   piApparentTrapNum = -1
   
   pbLocked = FALSE
   pbMagicallyLocked = FALSE
   piMagicalLockStrength = 0
   
   pbShrouded = FALSE
   pbCloaked = FALSE
   pbArtificed = FALSE
   
   poKiller = $
   
   piExpireChecks = 12
   ptExpireTimer = $
   
   piLadderID = 0
   
   piLootSize = 0
   
   % The monster corpse we reveal once chest has been looted / expires
   poCorpse = $

messages:

   Constructor(iLootSize=0,iBoxPower=20,killer=$,oCorpse=$,victim=$,iChampStatus=0)
   {
      local lPossibleTraps, iBonusShards, oBonusShard;

      poKiller = killer;
      piLadderID = Send(killer,@GetLadderID);
      piBoxPower = Bound((iBoxPower * Random(80,150))/100,20,$);
      poCorpse = oCorpse;
      
      if oCorpse <> $
      {
         if Send(victim,@HasCreatureType,#type=CREATURE_TYPE_UNHOLY)
            OR Random(1,5) = 1
         {
            if Random(1,100) <= piBoxPower/50
            {
               pbCloaked = TRUE;
            }
         }
         if Send(victim,@HasCreatureType,#type=CREATURE_TYPE_INTELLIGENT)
            OR Random(1,3) = 1
         {
            if Random(1,100) <= piBoxPower/25
            {
               pbShrouded = TRUE;
            }
         }
         if Send(victim,@HasCreatureType,#type=CREATURE_TYPE_ENIGMATIC)
            OR Random(1,5) = 1
         {
            if Random(1,100) <= piBoxPower/50
            {
               pbArtificed = TRUE;
            }
         }
      }
      
      if Random(1,1000) <= piBoxPower
      {
         Post(self,@LockChest,#bLocked=TRUE,#bMagicalLock=TRUE);
         piMagicalLockStrength = (piBoxPower * Random(50,200))/100;
      }
      else
      {
         Post(self,@LockChest,#bLocked=TRUE,#bMagicalLock=FALSE);
      }

      if iLootSize = 0
      {
         iLootSize = Bound(Random(1,Bound(piBoxPower/50,1,$)),1,7);
      }
      switch(iLootSize)
      {
         case 1:
            vrName = loot_box_name_rsc;
            vrIcon = loot_box_icon_small_rsc;
            break;
         case 2:
            vrName = loot_box_name2_rsc;
            vrIcon = loot_box_icon_medium_rsc;
            break;
         case 3:
            vrName = loot_box_name3_rsc;
            vrIcon = loot_box_icon_large_rsc;
            break;
         case 4:
            vrName = loot_chest_name1_rsc;
            vrIcon = loot_box_icon_chest_small;
            break;
         case 5:
            vrName = loot_chest_name2_rsc;
            vrIcon = loot_box_icon_chest_medium;
            break;
         case 6:
            vrName = loot_chest_name3_rsc;
            vrIcon = loot_box_icon_chest_large;
            break;
         case 7:
            vrName = loot_chest_name_super_rsc;
            vrIcon = loot_box_icon_chest_large;
            break;
      }
      
      piExpireChecks = piExpireChecks + iLootSize*6;

      piLootSize = iLootSize;
      
      % Add bonus shards to high level chests
      iBonusShards = 0;
      if piBoxPower >= 150
      {
         iBonusShards = ((piBoxPower/50)) * piLootSize;

         if iChampStatus = CHAMPION_INDOMITABLE
         {
            iBonusShards = iBonusShards * 5;
         }
         else if iChampStatus = CHAMPION_LEGENDARY
         {
            iBonusShards = iBonusShards * 20;
         }
      }

      while iBonusShards > 0
      {
         if Random(1,2) = 1
         {
            oBonusShard = Create(&ShardReImbueMinor);
         }
         else if Random(1,2) = 1
         {
            oBonusShard = Create(&ShardReImbueMajor);
         }
         else if Random(1,2) = 1
         {
            oBonusShard = Create(&ShardRemove);
         }
         else if Random(1,2) = 1
         {
            oBonusShard = Create(&ShardReroll);
         }
         else
         {
            oBonusShard = Create(&ShardEmpowerment);
         }
         Send(self,@NewHold,#what=oBonusShard);
         iBonusShards--;
      }
      
      % Always a chance of no trap.
      lPossibleTraps = [TRAP_NONE];

      lPossibleTraps = Cons(TRAP_FATE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_DISEASE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_ENFEEBLE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_GUARDIAN,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_FRIGHT,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_SIREN,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_TELEPORTER,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_SHATTERING_BLAST,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_EXPLOSION,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_DISCHARGE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_POISON_GAS,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_COLD_BLAST,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_PURGE,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_HEX,lPossibleTraps);
      lPossibleTraps = Cons(TRAP_LIFE_DRAIN,lPossibleTraps);

      % Petrify trap is too brutal to subject newbies to it
      if piBoxPower >= 200
      {
         lPossibleTraps = Cons(TRAP_PETRIFY,lPossibleTraps);
      }

      if Random(1,100) <= piBoxPower/3
      {
         piTrapNum = Nth(lPossibleTraps,Random(1,Length(lPossibleTraps)));
      }
      else
      {
         piTrapNum = TRAP_NONE;
      }
      
      ptExpireTimer = CreateTimer(self,@CheckExpire,10000);

      propagate;
   }

   LockChest(bLocked=FALSE, bMagicalLock=FALSE)
   {
      pbLocked = bLocked;
      pbMagicallyLocked = bMagicalLock;

      if pbLocked
      {
         viObject_Flags = viObject_Flags & ~OF_CONTAINER;
         
         if pbMagicallyLocked
         {
            viObject_Flags = viObject_Flags & ~OF_ACTIVATABLE;
         }
         else
         {
            viObject_Flags = viObject_Flags | OF_ACTIVATABLE;
         }
      }

      if NOT pbLocked
      {
         pbMagicallyLocked = FALSE;
         viObject_Flags = viObject_Flags | OF_CONTAINER;
         viObject_Flags = viObject_Flags & ~OF_ACTIVATABLE;
      }
      
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   LeaveHold(what=$)
   {
      Post(self,@CheckEmpty);
      propagate;
   }

   CheckEmpty()
   {
      if plActive = $ AND plPassive = $
      {
         if ptExpireTimer <> $
         {
            DeleteTimer(ptExpireTimer);
            ptExpireTimer = $;
         }
         Send(self,@CheckExpire);
      }
      return;
   }

   CheckExpire(timer=$)
   {
      ptExpireTimer = $;
      
      piExpireChecks--;
      
      if piExpireChecks <= 0
         OR (plActive = $ and plPassive = $)
      {
         if poCorpse <> $
            AND IsClass(poCorpse,&DeadBody)
            AND poOwner <> $
         {
            if Send(poOwner,@ReqNewHold,#what=poCorpse,
                                        #new_row=Send(self,@GetRow),
                                        #new_col=Send(self,@GetCol),
                                        #fine_row=Send(self,@GetFineRow),
                                        #fine_col=Send(self,@GetFineCol))
            {
               Send(poOwner,@NewHold,#what=poCorpse,
                                     #new_row=Send(self,@GetRow),
                                     #new_col=Send(self,@GetCol),
                                     #fine_row=Send(self,@GetFineRow),
                                     #fine_col=Send(self,@GetFineCol),
                                     #new_angle=Send(self,@GetAngle));
               Send(poCorpse,@BeginDecay);
            }
            Send(poCorpse,@SetTrappedLootBoxOwner,#oLootBox=$);
            poCorpse = $;
         }
         Send(self,@Delete);
      }
      else
      {
         ptExpireTimer = CreateTimer(self,@CheckExpire,10000);
      }
      
      return;
   }

   ReqNewHold(what = $, who = $, bMonsterDrop = FALSE)
   {
      if bMonsterDrop
      {
         return TRUE;
      }
      return FALSE;
   }

   TryActivate(who=$)
   {
      local bTrapSprung;
      
      bTrapSprung = FALSE;
      if NOT pbMagicallyLocked
      {
         if piTrapNum > 0
         {
            % Attempt to disarm the trap!
            if Random(1,100) <= Send(self,@GetDisarmEstimate,#who=who)
            {
               Send(who,@MsgSendUser,#message_rsc=disarm_trapped_loot_box_success_msg,#parm1=Send(self,@GetTrapName));
               Send(who,@AddExperience,#iAmount=(piBoxPower * Random(80,200))/100);
            }
            else
            {
               Post(self,@SpringTrap,#who=who);
               bTrapSprung = TRUE;
            }
         }
         else
         {
            Send(who,@MsgSendUser,#message_rsc=open_non_trapped_loot_box_msg);
         }
         Post(self,@LockChest,#bLocked=FALSE);
         
         if NOT bTrapSprung
         {
            Post(who,@UserObjectContents,#what=self);
         }
      }
      return TRUE;
   }

   GetTrapName()
   {
      local rTrapDesc;

      rTrapDesc = loot_box_unknown_trap_desc_rsc;
      
      switch(piTrapNum)
      {
         case TRAP_FATE:
            rTrapDesc = loot_box_fate_trap_desc_rsc;
            break;
         case TRAP_PURGE:
            rTrapDesc = loot_box_purge_trap_desc_rsc;
            break;
         case TRAP_LIFE_DRAIN:
            rTrapDesc = loot_box_life_drain_trap_desc_rsc;
            break;
         case TRAP_PETRIFY:
            rTrapDesc = loot_box_petrify_trap_desc_rsc;
            break;
         case TRAP_DISEASE:
            rTrapDesc = loot_box_disease_trap_desc_rsc;
            break;
         case TRAP_ENFEEBLE:
            rTrapDesc = loot_box_enfeeble_trap_desc_rsc;
            break;
         case TRAP_FRIGHT:
            rTrapDesc = loot_box_fright_trap_desc_rsc;
            break;
         case TRAP_SIREN:
            rTrapDesc = loot_box_siren_trap_desc_rsc;
            break;
         case TRAP_EXPLOSION:
            rTrapDesc = loot_box_explosion_trap_desc_rsc;
            break;
         case TRAP_DISCHARGE:
            rTrapDesc = loot_box_discharge_trap_desc_rsc;
            break;
         case TRAP_POISON_GAS:
            rTrapDesc = loot_box_poison_gas_trap_desc_rsc;
            break;
         case TRAP_COLD_BLAST:
            rTrapDesc = loot_box_cold_blast_trap_desc_rsc;
            break;
         case TRAP_TELEPORTER:
            rTrapDesc = loot_box_teleport_trap_desc_rsc;
            break;
         case TRAP_SHATTERING_BLAST:
            rTrapDesc = loot_box_shattering_blast_trap_desc_rsc;
            break;
         case TRAP_GUARDIAN:
            rTrapDesc = loot_box_guardian_trap_desc_rsc;
            break;
         case TRAP_HEX:
            rTrapDesc = loot_box_hex_trap_desc_rsc;
            break;
      }
      
      return rTrapDesc;
   }

   PlayerAssessesTrap(who=$)
   {
      if Random(1,100) <= Send(self,@GetAssessmentEstimate,#who=who)
      {
         % Success!
         piApparentTrapNum = piTrapNum;
      }
      else
      {
         % Misidentify, with a small chance of getting it right by accident.
         piApparentTrapNum = Random(TRAP_NONE, TRAP_MAX);
      }
      return;
   }
   
   GetAssessmentEstimate(who=$)
   {
      local iAssessEstimate;

      iAssessEstimate = ((Send(who,@GetAgility) + Send(who,@GetIntellect)) * (100 + (Send(self,@GetPlayerLevelVsBox,#who=who)/2))) / Bound(piBoxPower,20,$);
      
      return iAssessEstimate;
   }
   
   GetPlayerLevelVsBox(who=$)
   {
      return (Send(who,@GetBaseMaxHealth) * 100) / (100 + Send(who,@GetStamina));
   }
   
   GetAssessmentCertaintyStr(who=$, bShow_All=FALSE)
   {
      local iAssessEstimate, rStr;
      
      rStr = trap_assessment_level_none;
      
      if NOT bShow_All
      {
         if pbArtificed
         {
            return trap_assessment_level_all;
         }
         iAssessEstimate = Send(self,@GetAssessmentEstimate,#who=who);
      }
      else
      {
         iAssessEstimate = 100;
      }

      if iAssessEstimate < 10
      {
         rStr = trap_assessment_level_none;
      }
      else if iAssessEstimate < 30
      {
         rStr = trap_assessment_level_1;
      }
      else if iAssessEstimate < 50
      {
         rStr = trap_assessment_level_2;
      }
      else if iAssessEstimate < 70
      {
         rStr = trap_assessment_level_3;
      }
      else if iAssessEstimate < 90
      {
         rStr = trap_assessment_level_4;
      }
      else if iAssessEstimate < 100
      {
         rStr = trap_assessment_level_5;
      }
      else
      {
         rStr = trap_assessment_level_all;
      }

      return rStr;
   }

   ShowDesc(who=$, bShow_All=FALSE)
   {
      local rTrapDesc, iApparentTrapNum;
      
      if NOT pbLocked
      {
         AddPacket(4,loot_box_open_desc_rsc, 4,vrName, 4,Send(poCorpse,@GetName));
         return;
      }
      
      if pbMagicallyLocked
      {
         AddPacket(4,loot_box_magically_locked_desc_rsc, 4,vrName, 4,Send(poCorpse,@GetName));
         return;
      }
      
      if piApparentTrapNum = -1
      {
         Send(self,@PlayerAssessesTrap,#who=who);
      }

      rTrapDesc = loot_box_unknown_trap_desc_rsc;

      if NOT bShow_All
      {
         if pbArtificed
         {
            AddPacket(4,loot_box_not_trapped_desc_rsc, 4,vrName, 4,Send(poCorpse,@GetName), 4,Send(self,@GetAssessmentCertaintyStr,#who=who));
            return;
         }
         iApparentTrapNum = piApparentTrapNum;
      }
      else
      {
         iApparentTrapNum = piTrapNum;
      }

      if pbCloaked
      {
         AddPacket(4,vrDesc, 4,vrName, 4,Send(poCorpse,@GetName), 4,loot_box_cloaked_desc_rsc);
         return;
      }

      switch(iApparentTrapNum)
      {
         case TRAP_NONE:
            AddPacket(4,loot_box_not_trapped_desc_rsc, 4,vrName, 4,Send(poCorpse,@GetName), 4,Send(self,@GetAssessmentCertaintyStr,#who=who));
            return;
         case TRAP_FATE:
            rTrapDesc = loot_box_fate_trap_desc_rsc;
            break;
         case TRAP_PURGE:
            rTrapDesc = loot_box_purge_trap_desc_rsc;
            break;
         case TRAP_LIFE_DRAIN:
            rTrapDesc = loot_box_life_drain_trap_desc_rsc;
            break;
         case TRAP_PETRIFY:
            rTrapDesc = loot_box_petrify_trap_desc_rsc;
            break;
         case TRAP_DISEASE:
            rTrapDesc = loot_box_disease_trap_desc_rsc;
            break;
         case TRAP_ENFEEBLE:
            rTrapDesc = loot_box_enfeeble_trap_desc_rsc;
            break;
         case TRAP_FRIGHT:
            rTrapDesc = loot_box_fright_trap_desc_rsc;
            break;
         case TRAP_SIREN:
            rTrapDesc = loot_box_siren_trap_desc_rsc;
            break;
         case TRAP_EXPLOSION:
            rTrapDesc = loot_box_explosion_trap_desc_rsc;
            break;
         case TRAP_DISCHARGE:
            rTrapDesc = loot_box_discharge_trap_desc_rsc;
            break;
         case TRAP_POISON_GAS:
            rTrapDesc = loot_box_poison_gas_trap_desc_rsc;
            break;
         case TRAP_COLD_BLAST:
            rTrapDesc = loot_box_cold_blast_trap_desc_rsc;
            break;
         case TRAP_TELEPORTER:
            rTrapDesc = loot_box_teleport_trap_desc_rsc;
            break;
         case TRAP_SHATTERING_BLAST:
            rTrapDesc = loot_box_shattering_blast_trap_desc_rsc;
            break;
         case TRAP_GUARDIAN:
            rTrapDesc = loot_box_guardian_trap_desc_rsc;
            break;
         case TRAP_HEX:
            rTrapDesc = loot_box_hex_trap_desc_rsc;
            break;
      }
      
      AddPacket(4,vrDesc, 4,vrName, 4,Send(poCorpse,@GetName), 4,loot_box_trap_string_rsc, 4,Send(self,@GetAssessmentCertaintyStr,#who=who,#bShow_All=bShow_All),
                4,rTrapDesc, 4,Send(self,@GetDisarmEstimate,#who=who));

      return;
   }
   
   GetDisarmEstimate(who=$)
   {
      local iDisarmChance;

      iDisarmChance = ((Send(who,@GetAgility) + Send(who,@GetAim)) * (50 + (Send(self,@GetPlayerLevelVsBox,#who=who)/2))) / Bound(piBoxPower,20,$);
      
      iDisarmChance = Bound(iDisarmChance,1,100);
      
      return iDisarmChance;
   }
   
   SpringTrap(who=$)
   {
      switch(piTrapNum)
      {
         case TRAP_FATE:
            Send(self,@DoFateTrap,#who=who);
            break;
         case TRAP_PURGE:
            Send(self,@DoPurgeTrap,#who=who);
            break;
         case TRAP_LIFE_DRAIN:
            Send(self,@DoLifeDrainTrap,#who=who);
            break;
         case TRAP_PETRIFY:
            Send(self,@DoPetrifyingTrap,#who=who);
            break;
         case TRAP_ENFEEBLE:
            Send(self,@DoEnfeebleTrap,#who=who);
            break;
         case TRAP_DISEASE:
            Send(self,@DoDiseaseTrap,#who=who);
            break;
         case TRAP_FRIGHT:
            Send(self,@DoFrightTrap,#who=who);
            break;
         case TRAP_SIREN:
            Send(self,@DoSirenTrap,#who=who);
            break;
         case TRAP_EXPLOSION:
            Send(self,@DoExplosionTrap,#who=who);
            break;
         case TRAP_DISCHARGE:
            Send(self,@DoDischargeTrap,#who=who);
            break;
         case TRAP_POISON_GAS:
            Send(self,@DoPoisonGasTrap,#who=who);
            break;
         case TRAP_COLD_BLAST:
            Send(self,@DoColdBlastTrap,#who=who);
            break;
         case TRAP_TELEPORTER:
            Send(self,@DoTeleporterTrap,#who=who);
            break;
         case TRAP_SHATTERING_BLAST:
            Send(self,@DoShatteringBlastTrap,#who=who);
            break;
         case TRAP_GUARDIAN:
            Send(self,@DoGuardianTrap,#who=who);
            break;
         case TRAP_HEX:
            Send(self,@DoHexTrap,#who=who);
            break;
      }
      return;
   }

   DoGuardianTrap(who=$)
   {
      local cMonster, oMonster;
      if poOwner <> $
      {
         if piBoxPower < 60
         {
            cMonster = &TuskedSkeleton;
         }
         else if piBoxPower < 100
         {
            cMonster = &DaemonSkeleton;
         }
         else if piBoxPower < 130
         {
            cMonster = &Thrasher;
         }
         else if piBoxPower < 180
         {
            cMonster = &Shadowbeast;
         }
         else if piBoxPower < 240
         {
            cMonster = &Ghost;
         }
         else
         {
            cMonster = &DarkAngel;
         }
         oMonster = Create(cMonster);
         Send(poOwner,@NewHold,#what=oMonster,#new_row=Send(self,@GetRow),#new_col=Send(self,@GetCol),#fine_row=Send(self,@GetFineRow),#fine_col=Send(self,@GetFineCol));
         Send(who,@MsgSendUser,#message_rsc=guardian_trap_msg_rsc);
         Post(oMonster,@TargetSwitch,#what=who,#iHatred=100);
         Post(oMonster,@EnterStateChase,#target=who,#actnow=TRUE);
      }
      return;
   }

   DoHexTrap(who=$)
   {
      switch(Random(1,3))
      {
         case 1:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_EXECRATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
         case 2:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_VITIATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
         case 3:
            if Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE))
            {
               Send(who,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE));
            }
            Send(Send(SYS,@FindSpellByNum,#num=SID_HEX_MUTILATE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
            return;
      }
      return;
   }
   
   GetHexIncEffect()
   {
      return piBoxPower;
   }

   GetBoxPower()
   {
      return piBoxPower;
   }

   DoShatteringBlastTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=shattering_blast_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_SHATTER),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   DoTeleporterTrap(who=$)
   {
      local i, n, lRooms, iRID;
      
      if poOwner <> $
      {
         lRooms = $;
         
         foreach i in Send(poOwner,@GetYellZone)
         {
            foreach n in Send(Send(SYS,@FindRoomByNum,#num=i),@GetYellZone)
            {
               if n <> Send(poOwner,@GetRoomNum)
               {
                  if lRooms = $
                     OR FindListElem(lRooms,n) = 0
                  {
                     lRooms = Cons(n,lRooms);
                  }
               }
            }
         }

         if lRooms = $
            OR Length(lRooms) <= 1
         {
            iRID = Send(who,@GetHomeRoom);
         }
         else
         {
            iRID = Nth(lRooms,Random(1,Length(lRooms)));
            Send(Send(SYS,@FindRoomByNum,#num=iRID),@Teleport,#what=who);
            Send(who,@MsgSendUser,#message_rsc=teleport_trap_msg_rsc);
            Post(Send(SYS,@FindRoomByNum,#num=iRID),@SomethingWaveRoom,#what=who,#wave_rsc=trap_teleporter_sound);
         }
         
      }
      return;
   }

   DoColdBlastTrap(who=$)
   {
      local drow, dcol, iAngle;

      % build face towards (in fine-units)
      drow = (Send(who,@GetRow) * FINENESS) + Send(who,@GetFineRow);
      dcol = (Send(who,@GetCol) * FINENESS) + Send(who,@GetFineCol);
      drow = drow - ((Send(self,@GetRow) * FINENESS) + Send(self,@GetFineRow));
      dcol = dcol - ((Send(self,@GetCol) * FINENESS) + Send(self,@GetFineCol));

      if poOwner <> $
      {
         iAngle = Send(SYS,@UtilGetAngleTowards,#row=drow,#col=dcol);
         Send(poOwner,@SomethingTurned,#what=self,#new_angle=iAngle);
      }
      Send(Send(SYS,@FindSpellByNum,#num=SID_FROST_BREATH),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   DoPoisonGasTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oGasElement, iGasElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random poison gas.
      
      iGasElements = Random(3,6);
      
      while iGasElements > 0
      {
         oGasElement = Create(&OrangeFogCloud,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE,#Odds=100);
         Send(oOwner,@NewHold,#what=oGasElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iGasElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_POISON),@MakePoisoned,#who=who,#lossrate=piBoxPower*100,#duration=piBoxPower*100);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_ACID,
                                   #what=oCreator);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_poison_gas_sound);
      return;
   }
   
   DoDischargeTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oFireElement, iFireElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random fire.
      
      iFireElements = Random(3,6);
      
      while iFireElements > 0
      {
         oFireElement = Create(&WallofLightning,#MaxDamage=piBoxPower/6,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE);
         Send(oOwner,@NewHold,#what=oFireElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iFireElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_SHOCKING_FURY),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_SHOCK,
                                   #what=oCreator);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_discharge_sound);
      return;
   }
   
   DoExplosionTrap(who=$)
   {
      local oOwner, i, each_obj, lSplashTargets, lBattlers, iBurningDealt, iTotalBurning, iDealtDamage,
            oFireElement, iFireElements, oCreator;
      
      oOwner = Send(self,@GetOwner);
      lBattlers = $;
      
      if oCreator = $
      {
         % Attribute the kill to Chest Trap template mob if we have no creator.
         oCreator = Send(SYS,@FindMonsterByClass,#cClass=&ChestTrap);
      }
      
      % Create random fire.
      
      iFireElements = Random(3,6);
      
      while iFireElements > 0
      {
         oFireElement = Create(&WallOfFire,#MaxDamage=piBoxPower/6,#Caster=oCreator,#Duration=piBoxPower/3,#Illusionary=FALSE);
         Send(oOwner,@NewHold,#what=oFireElement,
              #new_row=Bound(Send(self,@GetRow) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomRows)),
              #new_col=Bound(Send(self,@GetCol) + Random(-(piBoxPower/2)/64,(piBoxPower/2)/64),0,Send(oOwner,@GetRoomCols)),
              #fine_row=Random(0,64),
              #fine_col=Random(0,64));
         iFireElements--;
      }

      % For our splash targets, we find all battlers in range of the target
      %    that aren't the caster or target and which the caster can attack

      foreach i in Send(oOwner,@GetHolderActive)
      {
         each_obj = Send(oOwner,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&Battler)
            AND each_obj <> oCreator
            AND Send(oOwner,@LineOfSight,#obj1=self,#obj2=each_obj)
            AND Send(each_obj,@SquaredFineDistanceTo3D,#what=self) <= (piBoxPower/2)*(piBoxPower/2)
            AND NOT (IsClass(each_obj,&Monster) AND NOT Send(each_obj,@CanMonsterFight))
            AND Send(each_obj,@GetMaster) <> oCreator
         {
            lBattlers = Cons(each_obj,lBattlers);
         }
      }
      
      Send(Send(SYS,@FindSpellByNum,#num=SID_BLAST_OF_FIRE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      % Show bolt from target to new targets
      if lBattlers <> $
      {
         foreach i in lBattlers
         {
            iBurningDealt = Send(i,@ApplyElementalStatusEffects,
                                   #damage=Bound((piBoxPower*Random(7,13))/10,1,$),
                                   #bSecondary=FALSE,
                                   #aspell=ATCK_SPELL_FIRE,
                                   #what=oCreator);
            Send(i,@AddHurtMeRecently,#who=oCreator,#amount=iBurningDealt);
         }
      }
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_explosion_sound);
      return;
   }

   DoSirenTrap(who=$)
   {
      local i, each_obj;
      Send(who,@MsgSendUser,#message_rsc=siren_trap_msg_rsc);
      
      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetHolderActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&Monster)
            {
               Send(each_obj,@TargetSwitch,#what=who,#iHatred=100);
               Send(each_obj,@EnterStateChase,#target=who,#actnow=TRUE);
            }
         }
      }
      
      return;
   }

   DoFrightTrap(who=$)
   {
      local oMinion;
      Send(who,@MsgSendUser,#message_rsc=fright_trap_msg_rsc);
      
      foreach oMinion in Send(who,@GetControlledMinions)
      {
         Send(oMinion,@AddLoyalty,#amount=-piBoxPower);
      }
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_roar_sound);
      }
      
      return;
   }

   DoEnfeebleTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_ENFEEBLE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoDiseaseTrap(who=$)
   {
      if NOT Send(who,@IsEnchanted,#what=Send(SYS,@FindSpellByNum,#num=SID_DEMENT))
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_DEMENT),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      }
      return;
   }
   
   DoLifeDrainTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=life_drain_trap_msg_rsc);
      Send(who,@GainBaseMaxHealth,#amount=-1);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_drain_sound);
      }

      return;
   }

   DoFateTrap(who=$)
   {
      local iHealthLoss, iManaLoss;
      
      iHealthLoss = Random(0,Bound(Send(who,@GetExactHealth)-100,0,$));
      iHealthLoss = Bound(Random(iHealthLoss,iHealthLoss + piBoxPower),0,Bound(Send(who,@GetExactHealth)-100,0,$));
      
      iManaLoss = Random(0,Send(who,@GetMaxMana));
      iManaLoss = Bound(Random(iManaLoss,iManaLoss + piBoxPower),0,Send(who,@GetMaxMana));
   
      Send(who,@LoseHealth,#amount=iHealthLoss,#precision=TRUE);
      Send(who,@LoseMana,#amount=iManaLoss);
      
      Send(who,@MsgSendUser,#message_rsc=fate_trap_msg_rsc);
      
      if poOwner <> $
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=trap_fate_sound);
      }

      return;
   }

   DoPurgeTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=purge_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PURGE),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);

      return;
   }
   
   DoPetrifyingTrap(who=$)
   {
      Send(who,@MsgSendUser,#message_rsc=petrifying_trap_msg_rsc);
      Send(Send(SYS,@FindSpellByNum,#num=SID_PETRIFIED),@CastSpell,#who=self,#lTargets=[who],#iSpellPower=piBoxPower/2);
      return;
   }

   ReqTaker(what=$,taker=$)
   {
      local oTakerOwner;

      oTakerOwner = Send(taker,@GetOwner);

      if (NOT Send(oTakerOwner,@LineOfSight,#obj1=taker,#obj2=self))
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from a chest they cannot see! ");

         return FALSE;
      }

      if IsClass(taker,&User)
         AND NOT IsClass(taker,&Admin)
         AND IsClass(oTakerOwner,&Room) AND IsClass(poOwner,&Room)
         AND oTakerOwner <> poOwner
      {
         Debug("ALERT!  ",Send(taker,@GetTrueName),taker," in RID ",
               Send(oTakerOwner,@GetRoomNum),
               " taking from distant chest in RID ",
               Send(poOwner,@GetRoomNum));

         return FALSE;
      }

      if IsClass(oTakerOwner,&GuildHall)
      {
         return Send(oTakerOwner,@ReqUseGuildChest,#who=taker,#oBox=self);
      }

      propagate;
   }
   
   Delete()
   {
      if ptExpireTimer <> $
      {
         DeleteTimer(ptExpireTimer);
         ptExpireTimer = $;
      }
      
      if poCorpse <> $
      {
         Send(poCorpse,@Delete);
         poCorpse = $;
      }
      
      propagate;
   }

   SendLightingInformation()
   {
      local iLightColor;

      iLightColor = viMagicallyLockedLightColor;
      if poOwner <> $
      {
         if Send(poOwner,@LightingColorOverride)
         {
            iLightColor = Send(poOwner,@GetLightingColorOverride);
         }
      }
      AddPacket(2,LIGHT_FLAG_ON);
      AddPacket(1,100 * pbMagicallyLocked);
      AddPacket(2,iLightColor);
      return;
   }
   
   GetLadderID()
   {
      return piLadderID;
   }
   
   GetCasterMaxHexes()
   {
      return 10;
   }

   GetKiller()
   {
      return poKiller;
   }
   
   GetMagicallyLocked()
   {
      return pbMagicallyLocked;
   }
   
   GetMagicalLockStrength()
   {
      return piMagicalLockStrength;
   }
   
   AddMagicalLockStrength(value=0)
   {
      piMagicalLockStrength = piMagicalLockStrength + value;
      
      if piMagicalLockStrength <= 0
      {
         piMagicalLockStrength = 0;
         Send(self,@LockChest,#bLocked=TRUE,#bMagicalLock=FALSE);
      }
      
      return piMagicalLockStrength;
   }
   
   GetCorpse()
   {
      return poCorpse;
   }

   SetCorpse(oCorpse=$)
   {
      poCorpse = $;
      return;
   }

   PurgeChest(who=$, iSpellPower=0)
   {
      local iMagicalLockReduction, i, oObject;
      
      if piMagicalLockStrength > 0
      {
         iMagicalLockReduction = ((iSpellPower+1) * Random(50,150))/100;
      
         if Send(self,@AddMagicalLockStrength,#value=-1*iMagicalLockReduction) <= 0
         {
            Send(who,@MsgSendUser,#message_rsc=purged_magical_lock_completely);
         }
         else
         {
            Send(who,@MsgSendUser,#message_rsc=purged_magical_lock,#parm1=iMagicalLockReduction);
         }
      }
      
      if plActive <> $
         OR plPassive <> $
      {
         foreach i in plActive
         {
            oObject = Send(self,@HolderExtractObject,#data=i);
            
            if IsClass(oObject,&Weapon)
               OR IsClass(oObject,&DefenseModifier)
               OR IsClass(oObject,&Ring)
               OR IsClass(oObject,&Gauntlet)
               OR IsClass(oObject,&NecromancerAmulet)
               OR IsClass(oObject,&Necklace)
               OR IsClass(oObject,&Instrument)
               OR IsClass(oObject,&JewelofFroz)
               OR IsClass(oObject,&AdventurerCrest)
               OR IsClass(oObject,&ScryingCrystal)
            {
               if Send(oObject,@GetMagicModsNumber) <> 0
               {
                  Send(oObject,@ClearMagicMods);
               }
            }
         }
         foreach i in plPassive
         {
            oObject = Send(self,@HolderExtractObject,#data=i);
            
            if IsClass(oObject,&Weapon)
               OR IsClass(oObject,&DefenseModifier)
               OR IsClass(oObject,&Ring)
               OR IsClass(oObject,&Gauntlet)
               OR IsClass(oObject,&NecromancerAmulet)
               OR IsClass(oObject,&Necklace)
               OR IsClass(oObject,&Instrument)
               OR IsClass(oObject,&JewelofFroz)
               OR IsClass(oObject,&AdventurerCrest)
               OR IsClass(oObject,&ScryingCrystal)
            {
               if Send(oObject,@GetMagicModsNumber) <> 0
               {
                  Send(oObject,@ClearMagicMods);
               }
            }
         }
      }
      return;
   }

   CanBeCastUpon(who=$)
   {
      if pbShrouded
      {
         Send(who,@MsgSendUser,#message_rsc=loot_box_shrouded_resists_rsc);
         return FALSE;
      }
      return TRUE;
   }

   RevealTrap(who=$)
   {
      piApparentTrapNum = piTrapNum;
      
      if pbArtificed
      {
         if who <> $
         {
            Send(who,@MsgSendUser,#message_rsc=artificing_enchantment_fades_rsc);
         }
         pbArtificed = FALSE;
      }
      return;
   }

   SetCloaked(value=FALSE)
   {
      pbCloaked = value;
      return;
   }

   GetCloaked()
   {
      return pbCloaked;
   }

   SetShrouded(value=FALSE)
   {
      pbShrouded = value;
      return;
   }

   GetShrouded()
   {
      return pbShrouded;
   }
   
   SetArtificed(value=FALSE)
   {
      pbArtificed = value;
      return;
   }

   GetArtificed()
   {
      return pbArtificed;
   }
   
   GetLootSize()
   {
      return piLootSize;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
